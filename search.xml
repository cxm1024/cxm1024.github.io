<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EDU-CFR-116-Div.2解题报告</title>
      <link href="/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1606">比赛传送门</a></p><p>做出来五道题。</p><h1 id="A-AB-Balance"><a href="#A-AB-Balance" class="headerlink" title="A. AB Balance"></a>A. AB Balance</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>给你一个只含有 <code>a</code> 和 <code>b</code> 的字符串，问怎样通过修改尽可能少的字符，使得 <code>ab</code> 的数量和 <code>ba</code> 的数量相等。</p></details><p>显然，<code>ab</code> 的数量和 <code>ba</code> 的数量最多差 $1$，而当开头字母和结尾字母相同时，<code>ab</code> 的数量等于 <code>ba</code> 的数量。如果不同，修改开头或结尾字母使它们相同即可。</p><h1 id="B-Update-Files"><a href="#B-Update-Files" class="headerlink" title="B. Update Files"></a>B. Update Files</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 $n$ 个电脑和 $k$ 个数据线，其中一个电脑上有一个文件，每次可以通过数据线将文件从一个电脑传到另一个电脑上，耗时 $1$ 小时。问至少需要几个小时才能让所有电脑都有文件。</p></details><p>设当前有 $x$ 个电脑有文件：若 $x&lt;=k$，则通过 $x$ 条数据线将 $x$ 翻倍；若 $x&gt;k$，则通过 $k$ 条数据线将 $x+=k$。暴力跑第一种情况（$\log(k)$），剩下的情况算一下就行了。</p><h1 id="C-Banknotes"><a href="#C-Banknotes" class="headerlink" title="C. Banknotes"></a>C. Banknotes</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 $n$ 中不同面值的货币，每种货币的面值为 $10^{a_i}$，问至少需要 $x+1$ <strong>个</strong>货币才能组成的价值最小的货币是多少。</p></details><p>暴力贪心模拟。先尽可能多地用面值最小的货币，再用面值第二小的货币，以此类推。具体实现细节比较多，在这里放个代码。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            <span class="keyword">int</span> cur=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(x--)</span><br><span class="line">                cur*=<span class="number">10</span>;</span><br><span class="line">            a[i]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=k;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">                cnt=<span class="built_in">min</span>(cnt,a[i+<span class="number">1</span>]/a[i]<span class="number">-1</span>);</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*cnt;</span><br><span class="line">            k-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="D-Red-Blue-Matrix"><a href="#D-Red-Blue-Matrix" class="headerlink" title="D. Red-Blue Matrix"></a>D. Red-Blue Matrix</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个 $n\times m$ 的矩阵，每个格子有一个正整数，你需要对每一行染成红色或蓝色，使得能够找到竖线，让左边所有红格子都大于所有蓝格子的值，右边相反。输出染色方案以及竖线位置。</p><p>$\sum n\times m\le 10^6$</p></details><p>假设我们已经知道了竖线的位置，如何分配红蓝呢？考虑以行为单位，以每一行的第一个元素为关键字进行从大到小的排序，则我们发现，一定是上面几行为红色，下面几行为蓝色，而这个两条分界线，一横一竖，左上、右上为红，左下、右下为蓝，则必须满足左上的最小值大于左下的最大值，右上的最大值小于右下的最小值。我们可以对矩阵分别求从左上、右下开始的前缀最小值和从左下、右上开始的前缀最大值。枚举横、竖线，然后就可以 $O(1)$ 判断了。总复杂度为 $O(n\times m)$。</p><h1 id="E-Arena"><a href="#E-Arena" class="headerlink" title="E. Arena"></a>E. Arena</h1><p>待更新……</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-755-Div.2解题报告</title>
      <link href="/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1589">比赛传送门</a></p><p>赛时AC三道，补题做出一道。</p><h1 id="A-Mathematical-Addition"><a href="#A-Mathematical-Addition" class="headerlink" title="A. Mathematical Addition"></a>A. Mathematical Addition</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个正整数 $u,v$，求一对合法的 $x,y$ 使得 $\frac{x}{u}+\frac{y}{v}=\frac{x+y}{u+v}$。</p></details><p>解方程。</p><p>$$<br>\frac{vx+uy}{uv}=\frac{x+y}{u+v}\<br>(vx+uy)(u+v)=uv(x+y)\<br>uvx+u^2y+v^2x+uvy=uvx+uvy\<br>u^2y+v^2x=0<br>$$</p><p>则显然一组合法解为 $\begin{cases}x=-u^2\\y=v^2\end{cases}$</p><h1 id="B-Coloring-Rectangles"><a href="#B-Coloring-Rectangles" class="headerlink" title="B. Coloring Rectangles"></a>B. Coloring Rectangles</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>有一个 $n\times m$ 的矩阵，每个方格均为红色。你可以任意多次的横切或纵切（必须贯穿整块），不能出现 $1\times 1$ 的矩阵，问切完后最少需要涂几个蓝色格子才能使得红色格子不相邻。</p><p>example: $2\times 5$</p><p><img data-src="https://espresso.codeforces.com/594fbc0a7f610ebbd39c222d75175364a33218ec.png" alt=""></p></details><div class="tabs" id="solution"><ul class="nav-tabs"><li class="tab active"><a href="#solution-1">Solution 1</a></li><li class="tab"><a href="#solution-2">Solution 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="solution-1"><p>容易发现，把格子割成 $1\times 3$ 是最优的，于是考虑在不对后续操作产生影响的前提下，把它切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/LMrB4f.png" alt=""></p><p>然后再切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/gZylEP.png" alt=""></p><p>最后特判剩下的。注意切的时候要时刻堤防剩下一行或剩下一列的情况，防止出现 $1\times 1$。</p></div><div class="tab-pane" id="solution-2"><p>通过找规律，我们可以发现，答案为 $\lceil\frac{n\times m}{3}\rceil$。</p></div></div></div><h1 id="C-Two-Arrays"><a href="#C-Two-Arrays" class="headerlink" title="C. Two Arrays"></a>C. Two Arrays</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个数组 $a,b$，问能否通过把 $a$ 进行<strong>一次</strong>变换得到 $b$。</p><p>变换方式：在 $a$ 数组中选出若干个数分别 $+1$，然后随意排列顺序。</p></details><p>大水题。$a,b$ 分别排序，看是否每个 $a$ 数组的元素都等于 $b$ 的对应元素或等于 $b$ 的对应元素 $+1$。</p><h1 id="D-Guess-the-Permutation"><a href="#D-Guess-the-Permutation" class="headerlink" title="D. Guess the Permutation"></a>D. Guess the Permutation</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>这是一道交互题。</p><p>有一个初始数组 $a$，满足 $a_i=i$，即 ${1,2,3…}$。现在有 $1&lt;=i&lt;j&lt;=k&lt;=n$，将 $[i,j-1],[j,k]$ 分别翻转。你需要通过不超过 $40$ 次询问得到 $i,j,k$ 的值。</p><p>每一次询问你可以给出 $l,r$，得到 $[l,r]$ 中的逆序对个数。</p><p>$n\le 10^9(\log_2(10^9)\approx 30)$</p></details><ol><li>用一次 $\log$ 找到 $k$：二分 $mid$，询问 $[mid,r]$ 中逆序对个数，如果不为 $0$，则 $k$ 在 $[mid+1,r]$ 中，否则在 $[l,mid]$ 中。</li><li>用两次询问 $[1,k]$ 和 $[1,k-1]$ 来获得 $j$ 的位置：一段降序区间 $[l,r]$ 的逆序对数减去 $[l,r-1]$ 的逆序对数等于 $len-1$，于是 $[1,k]-[1,k-1]=len_{[j,k]}-1$（$j$ 前面的都被抵消了），用 $k-(len-1)$ 即可求出 $j$。</li><li>同理用两次询问 $[1,j-1]$ 和 $[1,j-2]$ 来获得 $i$ 的位置。</li></ol><p>询问次数约为 $\log(n)+4$。</p><p>不开 <code>long long</code> 见祖宗（逆序对个数最多有 $n^2$ 级别）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3383【模板】线性筛-题解</title>
      <link href="/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/"/>
      <url>/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>这道题是线性筛的模板题，所以我们考虑怎么不用线性筛。</p><p>我们都知道有一种筛法叫埃拉托色尼筛，简称埃氏筛，它比线性筛好写，也更好理解，但它过不了这道题，那怎么办呢？我们可以用 $bitset$ 代替 bool 数组来进行优化，这造成的常数优化非常显著，以至于开了 <code>ios::sync_with_stdio(false)</code> 之后能轻松过掉这道题，和线性筛的时间总差距只有 $0.5s$，可以说是非常优秀了。</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,prime[<span class="number">6000000</span>];</span><br><span class="line">bitset&lt;100000000&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">flip</span>();p[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) &#123;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;MAXN;j+=i)</span><br><span class="line">                p[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;prime[x]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-53-Div.2解题报告</title>
      <link href="/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Diverse-Substring"><a href="#A-Diverse-Substring" class="headerlink" title="A. Diverse Substring"></a>A. Diverse Substring</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>定义一个字符串为多变的，当且仅当字符串中没有一个字符的出现次数严格大于 $n/2$。给定一个只由小写字母构成的字符串，问是否能找出一个多变的字串，如果能，任意输出一个。</p><p>$n\le 1000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>只有两个不同字符的字符串时多变的，所以只要给定的字符串中包含至少两个字符就一定可以，输出相邻两个不同字符即可。</p><h1 id="B-Vasya-and-Books"><a href="#B-Vasya-and-Books" class="headerlink" title="B. Vasya and Books"></a>B. Vasya and Books</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一摞书，从上到下依次编号为 $a_1,a_2,a_3…$，现在 Vasya 想把它们分 $n$ 次挪到别的地方，每次他会告诉你他想挪的书的编号，如果这本书还没有被挪动，他将会把这本书以上的书（包括这本书）一块搬走。对于每次挪动，回答他搬了多少本书（没搬输出 0）。</p><p>$n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>开一个桶记录每一本书的位置，记录当前搬到那个位置了，每搬一次就更新一下，减一下即可。</p><h1 id="C-Vasya-and-Robot"><a href="#C-Vasya-and-Robot" class="headerlink" title="C. Vasya and Robot"></a>C. Vasya and Robot</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一个机器人，初始在 $(0,0)$ 点，给你一个长度为 $n$ 的操作序列，每次让机器人向上、下、左、右中的一个方向走一步，你需要修改连续的一段操作序列（这一段中的操作不必全部都修改），使它最终走到 $(x,y)$ 点，问修改的操作序列的最短长度。（不是很严谨，序列长度的详细定义见原题面）</p><p>$n\le 2\times 10^5$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果修改一个长度为 $len$ 的序列可以使它走到终点，那么一定存在一种长度为 $len+1$ 的方案也能走到终点（大不了就加一个空修改），于是我们发现这是可以二分的。二分最终修改的长度 $len$，对于一个长度，我们需要 $O(n)$ 判断是否可行，怎么判断呢？对于每一段长度为 $len$ 的修改，判断不考虑这段修改后机器人会走到哪个位置，再从这个位置开始，判断随便走 $len$ 步能否走到终点（反正允许修改这一段，那想怎么改就怎么改）。</p><p>实现上，我们维护一个走的位置的前缀和和后缀和，就可以 $O(1)$ 判断去除这段修改后机器人会走到那个位置，然后再考虑一些细节问题即可。</p><h1 id="D-Berland-Fair"><a href="#D-Berland-Fair" class="headerlink" title="D. Berland Fair"></a>D. Berland Fair</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p><del>有一个人前来买东西。</del>Polycarp 带了 $T$ 元钱，去逛商铺。有 $n$ 家商铺顺时针排成一圈，编号 $1-n$，第 $i$ 个商铺卖一种价格为 $a_i$ 的商品（数量有无限个）。Polycarp 从一号商铺开始，只要钱足够，就买<strong>一件商品</strong>，否则跳过这家店，直到他一个商品也买不了为止，问他一共会买多少件商品。</p><p>$n\le 2\times 10^5,T\le 10^{18},a_i\le 10^9$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先算出来买一圈要花多少钱，让他买尽可能多的圈。为什么他买不了下一圈了呢？一定是到某一个商铺是他买不起了。现在买不起，以后也不可能买的起，于是直接把这个商铺删掉，不考虑。于是我们暴力跑一圈，看看是哪些商铺买不起，把它们都删掉，删完后再让他转圈，知道所有的商品全都被删完为止。由于每一次至少删掉一个商品，最多删 $n$ 次，每次 $O(n)$，总时间复杂度为 $O(n^2)$。<del>（别问我为什么能过 $2\times 10^5$，我也不知道）</del>（经过同学推导，复杂度为 $O(n\log(n))$）</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-115-Div.2解题报告</title>
      <link href="/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 3道，补题做出来一道</p><h1 id="A-Computer-Game"><a href="#A-Computer-Game" class="headerlink" title="A. Computer Game"></a>A. Computer Game</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一个 $2\times n$ 的01矩阵，1为障碍，你要从 $(1,1)$ 走到 $(2,n)$，每一步只能向右、上、下、右上、右下走，问能不能走到。</p><p>$t\le 100,n\le 100$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果有一列的两个数都是1，则一定会被堵住，否则一定能到，因为每一列至少有1个0，而我们可以斜着走，所以一定可以从一列走到下一列。</p><h1 id="B-Groups"><a href="#B-Groups" class="headerlink" title="B. Groups"></a>B. Groups</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有 $n$ 个学生（$n$ 是偶数），每个学生在星期一到星期五会有若干天空闲，问能否将学生平均分成两组，使得每一组能够挑选一天组织社团活动（两组选的日子不能相同）。</p><p>$t\le 10^4,\sum n\le 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于一周只有五天，考虑枚举选的是哪两天，然后判断可不可行。判断就需要一点脑洞了，我的方法是如果两天的空闲学生人数都 $\ge n/2$，且交集能够覆盖所有学生（即每个学生都在这两天中至少有一天空闲），就一定可行。</p><h1 id="C-Delete-Two-Elements"><a href="#C-Delete-Two-Elements" class="headerlink" title="C. Delete Two Elements"></a>C. Delete Two Elements</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个长度为 $n$ 的序列，问有多少种选出两个数的方案使得删除它们后平均值不变。</p><p>$t\le 10^4,\sum n\le 2\times 10^5,a_i\le 10^9$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>要想删除后平均值不变，取出的两个数的平均值必须等于全部的平均值，即两个数的和必须等于全部平均值的两倍，如果数列的平均值 $\times 2$ 不是整数则一定不可行（选出的两个数的和一定是整数），我们如果已经选出了一个数，就可以知道另一个数应该是多少，于是我们可以想到开一个桶，但 $10^9$ 开不了桶怎么办？用 map 即可。</p><h1 id="D-Training-Session"><a href="#D-Training-Session" class="headerlink" title="D. Training Session"></a>D. Training Session</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>教练有 $n$ 道题，每道题有一个算法主题 $x$ 和难度 $y$，你需要选出恰好 $3$ 道题使得 $x$ 互不相同<strong>或</strong> $y$ 互不相同。问有多少种选法。保证没有两个完全相同的题。</p><p>$t\le 50000,\sum n\le 2\times 10^5,x,y\le n$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑用总方案数减去不合法方案数，不合法的方案就是有两个题的 $x$ 相同，有两个题的 $y$ 相同，表现在坐标系上，每一个点的贡献就是横坐标相同的点数$\times$纵坐标相同的点数，可以开两个桶维护。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-114-Div.2解题报告</title>
      <link href="/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 2道题，赛后补题做出来一道（赛时交了4发，赛后交了十几发才过，太残忍了）</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/wuJBv8.png" alt=""></p><p>总体难度比较高，可能题解会比较冗长</p><h1 id="A-Regular-Bracket-Sequences"><a href="#A-Regular-Bracket-Sequences" class="headerlink" title="A. Regular Bracket Sequences"></a>A. Regular Bracket Sequences</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>输入 $n$，输出 $n$ 个互不相同的、合法的、长度为 $2n$ 的括号序列。</p><p>$t\le 50,n\le 50$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution\ 1$"></a>$Solution\ 1$</h2><p>update: 我的解法非常复杂，可以直接看 $Solution\ 2$ CF官方题解的做法（想看看我的憨批做法也行）</p><p>考虑一开始在 $(0,0)$ 点，左括号往右上走，右括号往右下走，则合法的括号序列一定在 $x$ 轴之上。现在考虑最简单的括号序列：<code>(((...(())...)))</code>，即<br>$${+1,+1,…,+1,+1,-1,-1,…,-1,-1}$$<br>展现在坐标系上，就是一个山峰形，那么我们考虑将山峰的顶砍一刀，让它凹进去，变成<br>$${+1,+1,…,+1,-1,+1,-1,…,-1,-1}$$<br>这样就得到了下一种合法序列，再下一种就再把左边的山峰砍一刀（自始至终都不管右边），每次砍左边的山峰，由于最初的山峰高度为 $n$，每砍一刀左边的山峰高度 $-1$，看 $n-1$ 刀的最终高度为 $1$，加上最初的单峰山，就得到了 $n$ 种合法括号序列。</p><p>实现上，把最初的 ${+1,+1,…,+1,+1,-1,-1,…,-1,-1}$ 序列存到数组里，每次交换一对 $+1,-1$ 变成 $-1,+1$，再转换成括号序列输出即可。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution\ 2$"></a>$Solution\ 2$</h2><p>CF官方题解，让我觉得我的解法太复杂了。直接引用英文原版，肯定能看懂。</p><blockquote><p>start with the sequence <code>()()()()...</code>;<br>merge the first $4$ characters into one sequence to get <code>(())()()...</code>;<br>merge the first $6$ characters into one sequence to get <code>((()))()...</code>;<br>and so on.</p></blockquote><h1 id="B-Combinatorics-Homework"><a href="#B-Combinatorics-Homework" class="headerlink" title="B. Combinatorics Homework"></a>B. Combinatorics Homework</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $a$ 个 <code>A</code>、$b$ 个 <code>B</code>、$c$ 个 <code>C</code>，问能否组成“恰好有 $m$ 对相邻两个字符相同”的字符串。</p><p>$t\le 10^4,a,b,c,m\le 10^8$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p><del>显然</del>，只要 $m$ 在“相邻两个字符相同的对数”的最大值和最小值之间，就一定可以。最大值很简单，若干个 A、若干个 B、若干个 C 这样排，$(a-1)+(b-1)+(c-1)$ 就行（别忘了 $\max(0,…)$），问题是最小值怎么求呢？我们可以发现一种典型情况：最大值太大，两个较小值用尽浑身解数拆散，最大值也还有剩余；还有一种情况就是两个较小值不需要用全部的力气拆散，数量最多的字母已经被拆得一对也没有了。针对后者，我们很轻松的就能<del>猜出来</del>一定总能互相拆的一对也不剩，无需多考虑，而针对前者，需要算出来两个数量较少的字母用尽浑身解数能把数量最大的拆得还剩几对。我们发现 <code>ABABAAAA</code> 和 <code>AABAABAA</code> 是一样的，于是我们又可以得到，尽可能多的拆散，就是把较少的两种字母分散开插进最多的字母里，怎么插无所谓，只要它们自己不连在一起就行。这样我们能够得到，针对前一种情况，能组成的对数的最小值为 $max-1-(all-max)$（感性理解一下），将它和 $m$ 比较即可。</p><h1 id="C-Slay-the-Dragon"><a href="#C-Slay-the-Dragon" class="headerlink" title="C. Slay the Dragon"></a>C. Slay the Dragon</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $n$ 个勇士，每个勇士有一定的能力值 $a_i$，每组数据给出一条龙的防御力 $x$ 和攻击力 $y$，你需要派出<strong>一个</strong>能力值 $\ge x$ 的勇士来攻击龙，剩余的勇士防御，防御的勇士能力值之和必须 $\ge y$。你每次可以花费 $1$ 的代价将一个勇士的能力值提高 $1$，对于每组数据，回答最少花费。<strong>注意：每组数据相互独立，每组数据提高的勇士能力值不会保存到下一组数据。</strong></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p><strong>这题竟然卡常！！！</strong>（痛骂 Codeforces）可能需要用 <code>ios::sync_with_stdio(false)</code> 才能过</p><p>很容易想到，每次可以用比龙的防御力小的能力值最大的人去打龙（给他提高一点），或是用第一个比龙的防御力大的人去打龙（不需要提高），然后再按需提高剩下的人（提高谁都没有区别，只需要考虑他们的和就行），取这两种方案中花费较小的一种。然后你就会发现细节巨多，当调了 n 遍终于调出错来时，你就会发现</p><blockquote><p>Time limit exceeded on test 6</p></blockquote><p>加上 <code>ios::sync_with_stdio(false)</code> 或快读可过（如果你是 <code>scanf</code> 党，当我没说）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-746-Div.2解题报告</title>
      <link href="/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>VP做出来一道，补题又做出来3道。</p><h1 id="A-Gamer-Hemose"><a href="#A-Gamer-Hemose" class="headerlink" title="A. Gamer Hemose"></a>A. Gamer Hemose</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $n$ 个武器，要打一个体力为 $H$ 的敌人，第 $i$ 个武器可以对敌人造成 $a_i$ 的伤害，每把武器不能连续使用两次，问至少需要多少次才能打败敌人。</p><p>$t\le 10^5,\sum n\le 2\times 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>（读错题意调了半天）</p><p>肯定是最厉害的武器和次厉害的武器轮番上阵，把它们看作一组，首先算要用多少组，剩余的再单独处理。</p><p>时间复杂度 $O(1)$。</p><h1 id="B-Hemose-Shopping"><a href="#B-Hemose-Shopping" class="headerlink" title="B. Hemose Shopping"></a>B. Hemose Shopping</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有一个数组，每次操作只能将距离 $\ge x$ 的两个数交换，问能否排好序。</p><p>$t\le 10^5,\sum n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于每次距离只能 $\ge x$，中间可能有一段区间是无论如何也动不了的，为 $[n-m+1,m]$。假设不用考虑这段区间，则剩下的分成左右两边，每次只能交换左右两边的数，是否能排好序呢？能。我们肯定能交换左右两边的数，所以考虑如何交换同一边的数（假设是 $a_x,a_y$），我们需要一个在另一边的辅助变量 $t$，就可以用我们刚学编程是学的用辅助变量来交换变量的方法交换，而 $t$ 的值也不会改变。</p><p>如此，两边的就不用管了，反正总能排好序。接下来考虑中间的部分，因为完全动不了，我们就要求它们已经排好序了。这样就结束了？不。（我就被这个坑了）它们还需要在排好序的数组里处于正确的位置，即，对于排好序的数组 $b$，$\forall i\in[n-m+1,m],a_i=b_i$。</p><h1 id="C-Bakry-and-Partitioning"><a href="#C-Bakry-and-Partitioning" class="headerlink" title="C. Bakry and Partitioning"></a>C. Bakry and Partitioning</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一棵有点权的树，问是否能割断至少 $1$ 条、至多 $k-1$ 条边，将树分成若干个连通块，使得每个连通块中点权的异或和相等。</p><p>$t\le 5\times 10^4,\sum n\le 2\times 10^5$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果异或和是 $0$，随便割一条边即可，因为两边的异或和相等，异或起来的结果才能等于 $0$。</p><p>如果疑惑和不是 $0$，而是 $x$，我们就需要将树分成三个异或和都为 $x$ 的连通块。为什么不是五个、七个？因为可以合并三个异或和都为 $x$ 的连通块得到一个异或和为 $x$ 的连通块。具体实现中跑一边 dfs 即可，跑的过程中一发现出现异或和为 $x$ 的连通块，马上把它分割出去，统计分割了多少次，如果多于两次就成立，否则不成立。</p><h1 id="D-Hemose-in-ICPC"><a href="#D-Hemose-in-ICPC" class="headerlink" title="D. Hemose in ICPC ?"></a>D. Hemose in ICPC ?</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p><strong>这是一道交互题。</strong> 给你一棵有边权的树，但你不知道边权是多少，每次你可以询问一个点集，会得到这个点集中距离最远的两个点的距离（即直径）。距离定义为路径中所有边权的 $\gcd$。你需要在 $12$ 次询问以内输出整棵树直径的两个端点。</p><p>$n\le 10^3$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>有一个很重要的结论，$a\ge gcd(a,b)$，这告诉我们树的“直径”一定只有一条边，所以问题转化为我们要求得最长的边的两个端点。我们先花费一次询问得知整棵树的直径（即最长的边），设它为 $x$。</p><p>假设我们以 $1$ 号结点为根，那么每一条边唯一对应一个点，所以我们用一个点来代表这个点与它父亲结点之间的边。考虑我们先对所有点按照 dfs 序排序，然后二分选相邻的点集（一定要加上前面的），这样它的直径一定是这个点集中最长的边，如果它是 $x$，那么递归再这段，否则递归后面的段（也加上前面的）。</p><p>为什么选的点要相邻呢？以下图为例，如果我们问 ${1,3,4}$，它返回 $10$，我们也不知道是否真的有一条边的权值等于 $10$，这对我们获知答案没有什么意义。</p><p><img data-src="https://i.loli.net/2021/10/09/ahmk2zd1EYy5Rrb.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-745-Div.2解题报告</title>
      <link href="/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>没打比赛，赛后做出3道。<br>这场比赛题目质量很高，非常巧妙。</p><h1 id="A-CQXYM-Count-Permutations"><a href="#A-CQXYM-Count-Permutations" class="headerlink" title="A. CQXYM Count Permutations"></a>A. CQXYM Count Permutations</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>求有多少 $2n$ 的排列满足存在超过 $n$ 个 $i$ 使得 $p_i&lt;p_{i+1}$，答案对 $10^9+7$ 取模。</p><p>$\sum n\le 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>这题就非常巧妙了，当我们使劲想想不出来时，正难则反，考虑有多少 $2n$ 的排列满足存在超过 $n$ 个 $i$ 使得 $p_i&gt;p_{i+1}$，这时候我们就会发现：这不是一样吗？没错，答案就是 $\frac{(2n)!}{2}$。</p><h1 id="B-Diameter-of-Graph"><a href="#B-Diameter-of-Graph" class="headerlink" title="B. Diameter of Graph"></a>B. Diameter of Graph</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>每次给定 $n,m,k$ 问能不能构造一个 $n$ 个点，$m$ 条边的简单无向图使得图的直径小于 $k-1$。</p><p>一张图的直径定义为最短路最长的两个点的最短路长度。</p><p>$t\le 10^5,n,m,k\le 10^9$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>始终没有明白为什么要“小于 $k-1$”，直接 <code>k-=2</code> 后变成 $\le k$。</p><p>考虑这道题可以转化为构造一个 $n$ 个点，$m$ 条边的直径尽可能小的图。</p><p>首先判断能否连通，即 $m&lt;n-1$，然后判断是否必须有重边，即 $m&gt;\frac{n(n-1)}{2}$，如果出现这两种情况则为不合法，直接排除。而且，如果 $k&lt;1$，也直接排除，因为不可能存在两个点的距离 $&lt;1$。</p><p>然后考虑能否构造出直径为 $1$ 的图。我们发现只有完全图的直径为 $1$，因为任意两个点都可以直径过 $1$ 条边到达。所以，如果 $k=1$，只有完全图才成立，否则不成立。接着在考虑能否构造出直径为 $2$ 的图。我们会发现只要图连通，就一定能构造出来直径为 $2$ 的图，因为菊花图的直径为 $2$，而在菊花图上加边不会让直径变大，所以只要 $k&gt;1$ 就一定能构造出来。</p><h1 id="C-Portal"><a href="#C-Portal" class="headerlink" title="C. Portal"></a>C. Portal</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给定一张 $n\times m$ 的矩阵，每个格子有空和黑曜石两种状态，你可以花费一步操作将空格子变成黑曜石或将黑曜石变成空格子。一个子矩阵可以形成传送门需要具备以下条件：</p><ol><li>高度 $\ge 5$，宽度 $\ge 4$。注意，传送门不能横过来看，宽就是宽，高就是高。</li><li>中间部分必须全是空格子。</li><li>四周边框必须全是黑曜石。</li><li>四角不限。</li></ol><p>问至少需要几次操作才能搭建一个传送门。</p><p>$\sum n\le 400,\sum m\le 400$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>这道题我从9月30号读题一直到10月8号才做出来，历尽了千辛万苦。</p><p>记输入的矩阵为 $a$，用 $0$ 表示空格，$1$ 表示黑曜石。</p><p>首先预处理出每一行的前缀和，以便我们 $O(1)$ 查询一段横向区间里有多少块黑曜石，我们用 $s[i][j]$ 表示。</p><p>然后，枚举合法的左右边界（$r-l\ge 3$），我们记 $len=r-l-1$ 表示中间部分的宽度，对于每一个左右边界，记 $t[i]$ 表示前 $i$ 行全变成 $100…001$ 的格式需要花费的步数，本质上是竖向的前缀和：$t[i]=t[i-1]+(s[i][r-1]-s[i][l])+(2-a[i][l]-a[i][r])$。然后我们考虑如何 $O(1)$ 计算搭建一段以 $u$ 为上边界，$d$ 为下边界的传送门的步数：首先让中间和左右边框合法（$t[d-1]-t[u]$），再让上边框合法（$len-(s[u][r-1]-s[u][l])$），同理再让下边框合法（$len-(s[d][r-1]-s[u][l])$）。加起来，则为：</p><p>$t[d-1]-t[u]+(len-(s[d][r-1]-s[d][l]))+(len-(s[u][r-1]-s[u][l]))$</p><p>将与 $u,d$ 有关的项分开，方便处理：</p><p>$2len+(t[d-1]-s[d][r-1]+s[d][l])-(t[u]+s[u][r-1]-s[u][l])$</p><p>我们记 $f[i]=t[i-1]-s[i][r-1]+s[i][l],g[i]=t[i]+s[i][r-1]-s[i][l]$，则上式可简化为 $2len+f[d]-g[u]$。</p><p>现在考虑从上到下扫下边界，对于每一个下边界，我们要使步数尽可能小，即让 $2len+f[d]-g[u]$ 尽可能小，就要让 $g[u]$ 尽可能大，于是我们从上到下扫的时候，记录以下当前扫过的 $g[u]$ 的最大值 $maxn[i]=\max(maxn[i-1],g[i])$，那么对于每一个下边界 $d$，最小步数就为 $2len+f[d]-maxn[d-4]$，整个算法的时间复杂度就可以做到 $O(m^2n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OI术语中英对照表</title>
      <link href="/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/"/>
      <url>/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="mathcal-A"><a href="#mathcal-A" class="headerlink" title="$\mathcal{A}$"></a>$\mathcal{A}$</h1><ul><li>$assume$ 设，令，假设</li><li>$axis$ 坐标轴</li></ul><h1 id="mathcal-B"><a href="#mathcal-B" class="headerlink" title="$\mathcal{B}$"></a>$\mathcal{B}$</h1><ul><li>$block$ 方块，格</li></ul><h1 id="mathcal-C"><a href="#mathcal-C" class="headerlink" title="$\mathcal{C}$"></a>$\mathcal{C}$</h1><ul><li>$column$ 列</li><li>$condition$ 条件</li><li>$corner$ 角，角落</li><li>$calculate$ 计算</li><li>$complexity$ 复杂度</li><li>$contributed$ 贡献</li><li>$communication$ 通信</li><li>$challenge$ 挑战</li><li>$capacity$ 容量</li><li>$coordinate$ 坐标</li></ul><h1 id="mathcal-D"><a href="#mathcal-D" class="headerlink" title="$\mathcal{D}$"></a>$\mathcal{D}$</h1><ul><li>$diameter$ 直径</li><li>$directed$ 有向的</li></ul><h1 id="mathcal-E"><a href="#mathcal-E" class="headerlink" title="$\mathcal{E}$"></a>$\mathcal{E}$</h1><ul><li>$exceed$ 超过</li><li>$enumerate$ 枚举</li></ul><h1 id="mathcal-F"><a href="#mathcal-F" class="headerlink" title="$\mathcal{F}$"></a>$\mathcal{F}$</h1><ul><li>$figure$ 插图</li><li>$flow$ 流量</li></ul><h1 id="mathcal-G"><a href="#mathcal-G" class="headerlink" title="$\mathcal{G}$"></a>$\mathcal{G}$</h1><ul><li>$guarantee$ 保证</li></ul><h1 id="mathcal-H"><a href="#mathcal-H" class="headerlink" title="$\mathcal{H}$"></a>$\mathcal{H}$</h1><h1 id="mathcal-I"><a href="#mathcal-I" class="headerlink" title="$\mathcal{I}$"></a>$\mathcal{I}$</h1><ul><li>$intersection$ 交集，交点</li></ul><h1 id="mathcal-J"><a href="#mathcal-J" class="headerlink" title="$\mathcal{J}$"></a>$\mathcal{J}$</h1><h1 id="mathcal-K"><a href="#mathcal-K" class="headerlink" title="$\mathcal{K}$"></a>$\mathcal{K}$</h1><h1 id="mathcal-L"><a href="#mathcal-L" class="headerlink" title="$\mathcal{L}$"></a>$\mathcal{L}$</h1><h1 id="mathcal-M"><a href="#mathcal-M" class="headerlink" title="$\mathcal{M}$"></a>$\mathcal{M}$</h1><ul><li>$minimum$ 最少的</li><li>$maximum$ 最多的</li><li>$matrix$ 矩阵</li><li>$multiedges$ 重边</li></ul><h1 id="mathcal-N"><a href="#mathcal-N" class="headerlink" title="$\mathcal{N}$"></a>$\mathcal{N}$</h1><h1 id="mathcal-O"><a href="#mathcal-O" class="headerlink" title="$\mathcal{O}$"></a>$\mathcal{O}$</h1><ul><li>$otherwise$ 否则</li><li>$overlap$ 重叠</li></ul><h1 id="mathcal-P"><a href="#mathcal-P" class="headerlink" title="$\mathcal{P}$"></a>$\mathcal{P}$</h1><ul><li>$precalculate$ 预处理</li><li>$prefix$ 前缀</li><li>$permutation$ 排列</li><li>$preceding$ 前面的</li><li>$positive$ 正的</li></ul><h1 id="mathcal-Q"><a href="#mathcal-Q" class="headerlink" title="$\mathcal{Q}$"></a>$\mathcal{Q}$</h1><h1 id="mathcal-R"><a href="#mathcal-R" class="headerlink" title="$\mathcal{R}$"></a>$\mathcal{R}$</h1><ul><li>$rectangle$ 长方形，矩阵</li><li>$row$ 行</li><li>$resources$ 资源</li></ul><h1 id="mathcal-S"><a href="#mathcal-S" class="headerlink" title="$\mathcal{S}$"></a>$\mathcal{S}$</h1><ul><li>$satisfy$ 满足（条件）</li><li>$suffix$ 后缀</li><li>$submatrix$ 子矩阵</li></ul><h1 id="mathcal-T"><a href="#mathcal-T" class="headerlink" title="$\mathcal{T}$"></a>$\mathcal{T}$</h1><ul><li>$therefore$ 因此</li><li>$tutorial$ 题解</li></ul><h1 id="mathcal-U"><a href="#mathcal-U" class="headerlink" title="$\mathcal{U}$"></a>$\mathcal{U}$</h1><ul><li>$utilization$ 利用</li><li>$undirected$ 无向的</li></ul><h1 id="mathcal-V"><a href="#mathcal-V" class="headerlink" title="$\mathcal{V}$"></a>$\mathcal{V}$</h1><h1 id="mathcal-W"><a href="#mathcal-W" class="headerlink" title="$\mathcal{W}$"></a>$\mathcal{W}$</h1><h1 id="mathcal-X"><a href="#mathcal-X" class="headerlink" title="$\mathcal{X}$"></a>$\mathcal{X}$</h1><h1 id="mathcal-Y"><a href="#mathcal-Y" class="headerlink" title="$\mathcal{Y}$"></a>$\mathcal{Y}$</h1><h1 id="mathcal-Z"><a href="#mathcal-Z" class="headerlink" title="$\mathcal{Z}$"></a>$\mathcal{Z}$</h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFR-744-Div.3解题报告</title>
      <link href="/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/"/>
      <url>/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时 AC 2道题，掉大分（哭）</p><h1 id="A-Casimir’s-String-Solitaire"><a href="#A-Casimir’s-String-Solitaire" class="headerlink" title="A. Casimir’s String Solitaire"></a>A. Casimir’s String Solitaire</h1><p><a href="https://codeforces.com/contest/1579/problem/A">题目传送门</a></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个仅含 A,B,C 的字符串，每次可以删掉一个 A 和一个 B，或一个 B 和一个 C，位置、顺序不限，问能不能删完。</p><p>$t\le 1000,len\le 50$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>大水题，只需要判断 A 的数量加 C 的数量是否等于 B 的数量。<del>一开始脑抽还判断 A 的数量是否等于 C 的数量</del></p><h1 id="B-Shifting-Sort"><a href="#B-Shifting-Sort" class="headerlink" title="B. Shifting Sort"></a>B. Shifting Sort</h1><p><a href="https://codeforces.com/contest/1579/problem/B">题目传送门</a></p><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>定义对一段区间的 <code>Cyclically Shift</code>（以下简称<code>Shift</code>） 操作为：</p><ol><li>指定一个数 $x(x\le len)$ 为操作的周期。</li><li>每次将区间左移一位，移出去的那一位放到最右边，重复 $x$ 次。</li></ol><p>给你一个数列 $a$，问如何用不超过 $n$ 次 <code>Shift</code> 操作将 $a$ 排好序（不要求使用次数最少，只要不超过 $n$ 就行）。</p><p>$1\le t \le 1000,2\le n\le 50$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>注意只要求不超过 $n$ 次，也就意味着我们只需要每一次把一个数排好序就行了。我们可以每次挑选最大的数，通过一次 <code>Shift</code> 操作（$x=1$）将它移到最右边的位置，如果已经在该在的位置就不操作，每次都能将一个数归位，重复 $n$ 次即可。</p><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原序列</span><br><span class="line">2 5 1 4 3</span><br><span class="line">将5归位</span><br><span class="line">2 1 4 3 5</span><br><span class="line">将4归位</span><br><span class="line">2 1 3 4 5</span><br><span class="line">将2归位</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>由于 $n$ 很小，暴力找最大值就可以。</p><h1 id="C-Ticks"><a href="#C-Ticks" class="headerlink" title="C. Ticks"></a>C. Ticks</h1><p><a href="https://codeforces.com/contest/1579/problem/C">题目传送门</a></p><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个 $n\times m$ 的网格图，每个格子有 <code>*</code> 和 <code>.</code> 两种状态，<code>*</code> 表示填，<code>.</code> 表示不填，问能不能通过若干个大小超过 $k$ 的“V字形”表示出这个图形（V 的两条边必须一样长，机房的两位大佬就是没判断这个而 FST 了）。</p><p>“V字形”大小的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*...*</span><br><span class="line">.*.*.</span><br><span class="line">..*..</span><br></pre></td></tr></table></figure><p>的大小为 $2$。</p><p>$1\le k\le n\le 10,1\le m\le 19$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>注意到 $n$ 和 $m$ 的范围很小，完全可以通过暴力求解。对于每一个格子，尽可能多的往上延伸，如果超过 $k$ 就把覆盖格子的标记一下，最后判断是否都被覆盖完。</p><h1 id="D-Productive-Meeting"><a href="#D-Productive-Meeting" class="headerlink" title="D. Productive Meeting"></a>D. Productive Meeting</h1><p><a href="https://codeforces.com/contest/1579/problem/D">题目传送门</a></p><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>在一场见面会中有 $n$ 个人，会议开始后他们会两两交谈，每个人有一定的耐心值 $a_i$，第 $i$ 个人在交谈 $a_i$ 次后会离开会议，两个人可以交谈多次，请找出一种方案使得总交谈次数尽可能多。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5,\sum a_i\le 2\times 10^5$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于 $\sum a_i$ 不大，我们可以依次考虑每一次交谈，容易想到每次让耐心值最大的两个人交谈是最优方案。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现 1"></a>实现 1</h3><p>先排好序，每次让剩余耐心值最大的两个人交谈，耐心值–，在考虑维护序列单调性，可以通过一通 <code>lower_bound</code> 和 <code>upper_bound</code> 以及 <code>swap</code> 来实现，时间复杂度 $O((\sum a_i)\log(n))$。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现 2"></a>实现 2</h3><p>使用 <code>lower_bound</code> 和 <code>upper_bound</code> 来维护需要考虑一大堆细节（我调错调了一下午加一晚上），不如用堆来维护。每次从堆里拿出两个耐心值最大的人，耐心值–，如果还有剩余耐心值，就把他们再扔回堆里，用 STL 的优先队列实现非常简洁，时间复杂度也是 $O((\sum a_i)\log(n))$。</p><h1 id="E1-Permutation-Minimization-by-Deque"><a href="#E1-Permutation-Minimization-by-Deque" class="headerlink" title="E1. Permutation Minimization by Deque"></a>E1. Permutation Minimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E1">题目传送门</a></p><p>在 Codeforces 中首次被 hack 祭。</p><h2 id="Problem-4"><a href="#Problem-4" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个 $1-n$ 的排列，你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的数的字典序最小。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution\ 1$"></a>$Solution\ 1$</h2><p>由于要让字典序最小，肯定最小的值放在最前面，最小值之前的数的放法先不管，放完最小值之前的数之后在把最小值放在最前面，最小值后面的数就只能从后面挨个放了。而最小值之前的数我们可以递归处理。</p><p>具体实现中我们需要用 ST 表维护区间最小值，再用分治递归的方法实现。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution\ 2$"></a>$Solution\ 2$</h2><p>从通过人数上看，这道题的简单程度可是仅次于 A 题，怎么会这么复杂呢？</p><p>考虑用贪心的思想，先扔进去第一个数，以后对于每一个数，如果它比队首小，就扔到队首（这样可以让结果的字典序尽可能小），否则就扔到队尾（如果还扔到队首字典序就大了）。就是这么简单。</p><h1 id="E2-Array-Optimization-by-Deque"><a href="#E2-Array-Optimization-by-Deque" class="headerlink" title="E2. Array Optimization by Deque"></a>E2. Array Optimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E2">题目传送门</a></p><h2 id="Problem-5"><a href="#Problem-5" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个长度为 $n$ 的数列（注意不是排列），你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的<a href="https://baike.baidu.com/item/逆序对/11035554">逆序对</a>尽可能少。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5,-10^9\le a_i\le 10^9$</p><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>同样是贪心，对于每个数，如果放在队首，则贡献的逆序对数为前面比它小的数的个数，反之则为比它大的数的个数，这个数放在队首还是队尾对以后的方法不会产生干扰，所以只需要判断它前面是比它大的多还是比它小的多，这可以用树状数组或权值线段树维护。由于 $a_i$ 的值跨度过大，需要先进行离散化处理。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-latex折腾记</title>
      <link href="/2021/09/09/hexo-latex-zhe-teng-ji/"/>
      <url>/2021/09/09/hexo-latex-zhe-teng-ji/</url>
      
        <content type="html"><![CDATA[<p>hexo的LaTeX可算把我给折腾死了。。。</p><p>问题：多行公式无法显示（hexo-renderer-marked，mathjax）</p><p>看到网上说是因为渲染引擎把<code>\\</code>渲染成<code>\</code>，然后才交给mathjax渲染公式</p><p>都说把hexo-renderer-marked换成hexo-renderer-kramed，然后再node_modules/kramed/lib/rules/inline.js里修改escape项，照做了，确实解决了问题，但是却出现了新的问题：复杂公式显示错乱，遂放弃。</p><p>又看到在node_modules/marked/lib/marked.js里修改escape项，失败。</p><p>后来发现那些文章都比较老，于是把hexo-renderer-marked换成了2018年的1.0.0版本，再修改escape，终于成功。</p><p>最终解决步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-marked@1.0.0</span><br></pre></td></tr></table></figure><p>编辑node_modules/marked/lib/marked.js</p><p>第539行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/,</span><br><span class="line">改成</span><br><span class="line">escape: /^\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/,</span><br></pre></td></tr></table></figure><p>第564行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline._escapes = /\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/g;</span><br><span class="line">改成</span><br><span class="line">inline._escapes = /\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/g;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2285打鼹鼠 题解</title>
      <link href="/2021/09/05/p2285-da-yan-shu-ti-jie/"/>
      <url>/2021/09/05/p2285-da-yan-shu-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>基础的DP各位大佬已经讲得很明白了，本文主要讲一讲优化</p><p>DP状态很<del>容易</del>想到：$f[i]$ 表示打完第 $i$ 只鼹鼠能获得的最多数量。</p><p>转移：$f[i]=\min\limits_{j&lt;i,\ t[i]-t[j]&gt;=dis(i,j)}f[j]+1$ ，即对于每一个打完第 $j$ 个能来得及走到第 $i$ 个的 $j$，算最大的 $f[j]+1$。</p><h3 id="重点来了！！"><a href="#重点来了！！" class="headerlink" title="重点来了！！"></a>重点来了！！</h3><p><strong>优化</strong></p><p>我们发现，如果时间差大于 $2\times n$，无论在<del>天涯海角</del>哪里都能走到，又因为输入的时间是升序排列，我们只需要在转移时维护 $g[i]$ 表示 $\max\limits_{j&lt;=i}f[i]$，这样在转移 $f[i]$ 时就可以先用 $start=upper \_ bound-1$ 找出最后一个“时间差大于 $2\times n$” 的鼹鼠，他前面的鼹鼠无论多远都能到达，就可以直接用 $g[start]$ 来代替，枚举时就只需要从 $start$ 开始枚举了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+<span class="number">1</span>,t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续优化</strong></p><p>我们发现，由于时间是递增的，所以 $i$ 的 $start$ 一定不会小于 $i-1$ 的 $start$，所以我们用 $start[i]$ 记录第 $i$ 只鼹鼠的 $start$，那么 $upper \_ bound$ 时就只需要从 $start[i-1]$ 开始查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        start[i]=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+start[i<span class="number">-1</span>],t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start[i]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start[i]);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续继续优化</strong></p><p>我们甚至可以直接不用 $upper \_ bound$ 和 $start$ 数组了（没错），开一个变量 $start$，维护当前的 $start$，转移之前用一个</p><p><code>for(;t[i]-t[start+1]&gt;=2*n;start++);</code></p><p>来更新 $start$，可以发现，整个程序运行下来，$start$ 最多只会更新 $n$次，所以复杂度可忽略。</p><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;t[i]-t[start+<span class="number">1</span>]&gt;=<span class="number">2</span>*n;start++);</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不开O2可达48ms，可见优化非常显著。</p><p><strong>请勿抄袭，如果一定要抄，请理解明白后再抄</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4363一双木棋 题解</title>
      <link href="/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/"/>
      <url>/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/</url>
      
        <content type="html"><![CDATA[<p><del>本篇题解献给和我一样看不懂其他题解的状压DP小白</del></p><p>相信大家都是看了其他题解看不懂才看到这篇题解的（莫名自信），所以什么<strong>每行棋子数递减</strong>啊，<strong>每行的棋子都排在左边</strong>啊，就不用我多说了，直接切入正题（大段文字多，请耐心观看）。</p><h2 id="轮廓线DP"><a href="#轮廓线DP" class="headerlink" title="轮廓线DP"></a>轮廓线DP</h2><p>没见过不用慌，我也没见过（雾</p><p>轮廓线，就是把矩阵从右上角到左下角沿着有棋子和没棋子的分界线描一下，往下走就用1表示，往左走就用0表示。这样我们就得到了一个01串，即一个二进制数，这就是我们的DP状态。</p><p>例如（图丑勿喷）</p><p><img data-src="https://i.loli.net/2021/08/14/6RlDkBPy2JnVS7W.png" alt=""></p><p>这种情况下轮廓线状态为左左下左下下左左下，即$001011001_{(2)}=89$</p><p>我们设$f[s]$（$s$就是轮廓线状态）表示从轮廓线表示的局面一直下到最终下满的过程中“先手-后手”最大是多少。我们可以发现，只根据s就可以知道已经下了那些棋，但不能知道具体是黑棋还是白棋，然而根据$f$的定义，$f[s]$的值和前面怎么下的没有关系，它只管之后怎么下，所以我们只用一维轮廓线就OK，不需要记录之前怎么下的。</p><p>那么状态有了，怎么转移呢？以上图为例，即将要白棋（后手）下棋，后手肯定希望他下的一步棋能使得从现在开始（以前的我们不管）先手-后手得分尽可能小（如果是负数那他更开心了），所以$f[s]=\min\limits_{所有再下一步棋可能得到的方案s’}f[s’]-b[x][y]$（$x,y$就是即将下的那一步棋的坐标）。</p><p>同理，如果即将先手下，就把上面的式子里min改成max（因为他希望下这步棋能使得他的得分-对方的得分最大），$-b[x][y]$改成$+a[x][y]$。</p><p>这样我们就可以用记忆化搜索很容易地跑出来了。</p><p>哎等等，我们还有两个问题没解决，观察上面的式子，我们还不知道怎么枚举“所有再下一步棋可能得到的方案$s’$”，也不知道怎么根据轮廓线的变化找出具体坐标x和y啊？</p><p>我们一个一个解决，先看第一个问题。还是以上图为例，白棋（后手）可以下在$(1,4),(2,3),(4,1)$三个位置，但转移的时候电脑只知道当前的轮廓线，所以我们需要找这三个点的共同特点，那就是处在轮廓线左和下的拐角处，也就是轮廓线中先出现一个0，再出现一个1。现在我们知道了轮廓线上放棋子的位置，怎么得出放棋子后的轮廓线状态呢？我们还是以上图为例，如果我们放在$(2,3)$处，进行一个对比。</p><p>原：$001011001_{(2)}$</p><p>新：$001101001_{(2)}$</p><p><img data-src="https://i.loli.net/2021/08/15/YyPqDZpzrfl43kO.png" alt=""></p><p>我们发现只有第四位和第五位变了，而原先的第四位和第五位就是我们之前说的先出现一个0，再出现一个1，那么转移就是把0变成1，把1变成0。</p><p>具体来说，就是当我们枚举到一个$i$，使得原状态的（从低位数）第$i$位是1，第$i+1$位是0，那么就把状态异或上$3&lt;&lt;i$（可以对照例子手推一下）。</p><p>开始讨论第二个问题，我们知道该在轮廓线的哪一位上下棋，怎么知道那步棋的具体坐标呢？这个问题比较容易解决，只需要在枚举$i$时维护当前看到哪个坐标即可（详见代码）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>],b[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1048580</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1048580</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">bool</span> now)</span><span class="comment">//s是轮廓线状态，now记录是先手还是后手（虽然可以根据s算出来，但这样比较方便）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[s])<span class="comment">//记忆化搜索标配</span></span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;(n+m))-(<span class="number">1</span>&lt;&lt;m))<span class="comment">//已经填满棋子（即n个下加m个左）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num0=<span class="number">0</span>,num1=<span class="number">0</span>;<span class="comment">//维护坐标（已经出现多少个左/多少个下</span></span><br><span class="line">    <span class="keyword">if</span>(now)<span class="comment">//先手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">-2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;<span class="number">0</span>&amp;&amp;(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>)))==<span class="number">0</span>)</span><br><span class="line">                f[s]=<span class="built_in">max</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">0</span>)+a[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//后手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&amp;&amp;!(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>))))</span><br><span class="line">                f[s]=<span class="built_in">min</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">1</span>)-b[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;b[i][j];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//(1&lt;&lt;n)-1是初始状态，即m个左加n个下（一步棋也没下）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能的高精度模板</title>
      <link href="/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/"/>
      <url>/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL=<span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,z[MAXL];</span><br><span class="line">    <span class="built_in">Int</span>()&#123; <span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(z)); len=<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean_pre_zero</span><span class="params">()</span></span>&#123; <span class="keyword">while</span>(len&gt;<span class="number">1</span> &amp;&amp; !z[len<span class="number">-1</span>]) len--; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="keyword">char</span> s[MAXL]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); *<span class="keyword">this</span>=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,z[i]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">    &#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            z[i]=num[len-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[MAXL];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">int</span> num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">char</span> *num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=<span class="built_in">max</span>(len,b.len)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]+b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int &amp;b)<span class="comment">// 必须保证结果为正数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]-b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            <span class="keyword">if</span>(res.z[i]&lt;<span class="number">0</span>)</span><br><span class="line">                res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span><span class="number">-1</span>,</span><br><span class="line">                res.z[i]%=<span class="number">10</span>,res.z[i]+=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len+b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">                res.z[i+j]+=z[i]*b.z[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,</span><br><span class="line">            res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> / (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res,cur;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur*<span class="number">10</span>+z[i];</span><br><span class="line">            <span class="keyword">while</span>(cur&gt;=b)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur-b;</span><br><span class="line">                res.z[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=b.len) <span class="keyword">return</span> len&lt;b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(z[i]!=b.z[i])</span><br><span class="line">                <span class="keyword">return</span> z[i]&lt;b.z[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> b&lt;*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span>&gt;b) &amp;&amp; !(*<span class="keyword">this</span>&lt;b); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&gt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&lt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(b==*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得学习笔记</title>
      <link href="/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/"/>
      <url>/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>温馨提示1：本文推式子比较多，建议跟着文章自己推一推。</p><p>温馨提示2：本文小字比较多，如果分辨率不够可以放大网页。</p><h2 id="0-扩展欧几里得是什么"><a href="#0-扩展欧几里得是什么" class="headerlink" title="0. 扩展欧几里得是什么"></a>0. 扩展欧几里得是什么</h2><p>扩展欧几里得（exgcd）是一个可以用来求$ax+by=c$（$c\% \gcd(a,b)=0$，否则无解）的解的算法</p><p>怎么求$ax+by=c (c\% \gcd(a,b)=0)$的解呢？</p><h2 id="1-ax-by-gcd-a-b"><a href="#1-ax-by-gcd-a-b" class="headerlink" title="1. $ax+by=\gcd(a,b)$"></a>1. $ax+by=\gcd(a,b)$</h2><p>怎么求$ax+by=\gcd(a,b)$的解呢？</p><p>首先，如果$b=0$的话，$\gcd(a,b)=a$，则解为$\begin{cases}x=1 \\ y=0\end{cases}$</p><p>设此方程的解为$\begin{cases}x=x_0 \\ y=y_0\end{cases}$</p><p>那么我们需要做的就是将$ax_0+by_0=\gcd(a,b)$转化为$b=0$的格式，这就要用到辗转相除法了。</p><p>设另一个方程：$bx_1+(a\% b)y_1=\gcd(b,a\% b)$</p><p>设$a_1=b,b_1=a\% b$</p><p>则该方程转化为$a_1x_1+b_1y_1=\gcd(a_1,b_1)$</p><p>我们会发现它和原方程的格式是一样的，而且根据欧几里得原理，它可以一直递推到$a_nx_n+b_ny_n=\gcd(a_n,b_n)$使得$b_n=0$，就可以求得解$\begin{cases}x_n=1 \\ y_n=0\end{cases}$</p><p>那假设我们已经求得了该结果，那如何推导出$x_0$和$y_0$呢？</p><p>我们首先研究如何从$x_1$和$y_1$推导出$x_0$和$y_0$，其他的就同理了</p><p>因为</p><p>$\begin{cases}bx_1+(a\% b)y_1=\gcd(b,a\% b) \\ ax_0+by_0=\gcd(a,b)\end{cases}$</p><p>且根据欧几里得定理，$\gcd(a,b)=\gcd(b,a\% b)$</p><p>所以</p><p>$ax_0+by_0=bx_1+(a\% b)y_1$</p><p>且$a\% b=a-\lfloor\frac{a}{b}\rfloor b$（好好体会一下）</p><p>所以</p><p>$ax_0+by_0=bx_1+(a-\lfloor\frac{a}{b}\rfloor b)y_1$</p><p>$ax_0+by_0=bx_1+ay_1-\lfloor\frac{a}{b}\rfloor b y_1$</p><p>$ax_0+by_0=b(x1-\lfloor\frac{a}{b}\rfloor y_1)+ay_1$</p><p>$ax_0+by_0=ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1)$</p><p>即$\begin{cases}x_0=y_1 \\ y_0=x_1-\lfloor\frac{a}{b}\rfloor y_1\end{cases}$</p><p>这样，我们就由$x_1$和$y_1$推导出了$x_0$和$y_0$，其他同理</p><p>于是乎：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp;</span><br><span class="line">        tmp.x=<span class="number">1</span>,tmp.y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    node tmp=<span class="built_in">exgcd</span>(b,a%b);<span class="comment">//递归求出x_(k+1)和y_(k+1)</span></span><br><span class="line">    node ans;</span><br><span class="line">    ans.x=tmp.y,ans.y=(tmp.x)-a/b*(tmp.y);<span class="comment">//推导出x_k和y_k</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就求出了$ax+by=\gcd(a,b)$的一组解</p><h2 id="2-ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases"><a href="#2-ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases" class="headerlink" title="2. $ax+by=c$的一组解$\begin{cases}x=x_{tmp}\\y=y_{tmp}\end{cases}$"></a>2. $ax+by=c$的一组解$\begin{cases}x=x_{tmp}\\y=y_{tmp}\end{cases}$</h2><p>我们已经求出了$ax+by=\gcd(a,b)$的一组解$\begin{cases}x=x_0 \\ y=y_0\end{cases}$</p><p>那么我们就可以知道$akx_0+bky_0=k\gcd(a,b)$</p><p>又因为要求$c$是$\gcd(a,b)$的倍数（否则无解）</p><p>所以$k=\frac{c}{\gcd(a,b)}$</p><p>所以很简单：</p><p>$\begin{cases}x_{tmp}=kx_0=\frac{c}{\gcd(a,b)}x_0 \\ y_{tmp}=ky_0=\frac{c}{\gcd(a,b)}y_0\end{cases}$</p><h2 id="3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases"><a href="#3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases" class="headerlink" title="3.$ax+by=c$的所有解$\begin{cases}x=x_{ans}\\y=y_{ans}\end{cases}$"></a>3.$ax+by=c$的所有解$\begin{cases}x=x_{ans}\\y=y_{ans}\end{cases}$</h2><p>我们已经求出了$ax+by=c$的一组解$\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>即$ax_{tmp}+by_{tmp}=c$</p><p>将它加上再减去$\frac{ab}{\gcd(a,b)}$，得到</p><p>$ax_{tmp}+\frac{ab}{\gcd(a,b)}+by_{tmp}-\frac{ab}{\gcd(a,b)}=c$</p><p>$a(x_{tmp}+\frac{b}{\gcd(a,b)})+b(y_{tmp}-\frac{a}{\gcd(a,b)})=c$</p><p>在$x_{tmp}$上减，在$y_{tmp}$上加也同理</p><p>所以$\begin{cases}x=x_{tmp}\pm\frac{b}{\gcd(a,b)} \\ y=y_{tmp}\mp\frac{a}{\gcd(a,b)}\end{cases}$也是一组解</p><p>这个变换进行多次，即可得到</p><p>$\begin{cases}x_{ans}=x_{tmp}+t\times\frac{b}{\gcd(a,b)} \\ y_{ans}=y_{tmp}-t\times\frac{a}{\gcd(a,b)}\end{cases}$（$t$的正负可以代替加和减的分类讨论）</p><h2 id="4-x-和-y-各自的最小正整数解"><a href="#4-x-和-y-各自的最小正整数解" class="headerlink" title="4. $x$和$y$各自的最小正整数解"></a>4. $x$和$y$各自的最小正整数解</h2><p>以$x$的最小正整数解为例：</p><p>求出任意一组解$\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>因为将$x_{tmp}$加或减$\frac{b}{\gcd(a,b)}$也成立，所以可设$d=\frac{b}{\gcd(a,b)}$（注意这里分子是$b$）</p><p>$x_{min}=(x_{tmp}\% d+d)\% d$（因为$x_{tmp}$有可能是负数）</p><p>同理对于$y$，设$d=\frac{a}{\gcd(a,b)}$（注意这里分子是$a$）</p><p>$y_{min}=(y_{tmp}\% d+d)\% d$</p><h2 id="5-完结撒花"><a href="#5-完结撒花" class="headerlink" title="5. 完结撒花"></a>5. 完结撒花</h2><p>至此，你已经学完了扩展欧几里得的基础用法，如有不懂的地方，建议对照着文章自己推一推，悟一悟。</p><p>做个题练习一下吧：<a href="https://www.luogu.com.cn/problem/P5656">洛谷 P5656 【模板】二元一次不定方程 (exgcd)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
