<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数论学习笔记</title>
      <link href="/2021/09/06/shu-lun-xue-xi-bi-ji/"/>
      <url>/2021/09/06/shu-lun-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>本文记录一些学习到的数论知识。</p><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p>$a\% b$ 表示 $a\div b$ 的余数。它具有如下几个性质：</p><script type="math/tex; mode=display">(a+b)\% m=(a\% m+b\% m)\% m</script><script type="math/tex; mode=display">(a-b)\% m=(a\% m-b\% m)\% m</script><script type="math/tex; mode=display">(a\times b)\% m=(a\% m)\times (b\% m)\% m</script>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】P2285打鼹鼠</title>
      <link href="/2021/09/05/ti-jie-p2285-da-yan-shu/"/>
      <url>/2021/09/05/ti-jie-p2285-da-yan-shu/</url>
      
        <content type="html"><![CDATA[<p>基础的DP各位大佬已经讲得很明白了，本文主要讲一讲优化</p><p>DP状态很<del>容易</del>想到：$f[i]$ 表示打完第 $i$ 只鼹鼠能获得的最多数量。</p><p>转移：$f[i]=\min\limits_{j<i,\ t[i]-t[j]>=dis(i,j)}f[j]+1$，即对于每一个打完第 $j$ 个能来得及走到第 $i$ 个的 $j$，算最大的 $f[j]+1$。</p><h3 id="重点来了！！"><a href="#重点来了！！" class="headerlink" title="重点来了！！"></a>重点来了！！</h3><p><strong>优化</strong></p><p>我们发现，如果时间差大于 $2\times n$，无论在<del>天涯海角</del>哪里都能走到，又因为输入的时间是升序排列，我们只需要在转移时维护 $g[i]$ 表示 $\max\limits_{j&lt;=i}f[i]$，这样在转移 $f[i]$ 时就可以先用 $start=upper \_ bound-1$ 找出最后一个“时间差大于 $2\times n$” 的鼹鼠，他前面的鼹鼠无论多远都能到达，就可以直接用 $g[start]$ 来代替，枚举时就只需要从 $start$ 开始枚举了。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int t[10010],x[10010],y[10010];int f[10010],g[10010];int dis(int a,int b) &#123;return abs(x[a]-x[b])+abs(y[a]-y[b]);&#125;int main() &#123;int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(int i&#x3D;1;i&lt;&#x3D;m;i++)scanf(&quot;%d%d%d&quot;,&amp;t[i],&amp;x[i],&amp;y[i]);for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123;int start&#x3D;max(0,int(upper_bound(t+1,t+i,t[i]-2*n)-t-1));f[i]&#x3D;g[start]+1;for(int j&#x3D;max(1,start);j&lt;i;j++) &#123;if(t[i]-t[j]&gt;&#x3D;dis(i,j))f[i]&#x3D;max(f[i],f[j]+1);&#125;g[i]&#x3D;max(g[i-1],f[i]);&#125;printf(&quot;%d\n&quot;,g[m]);    return 0;&#125;</code></pre><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续优化</strong></p><p>我们发现，由于时间是递增的，所以 $i$ 的 $start$ 一定不会小于 $i-1$ 的 $start$，所以我们用 $start[i]$ 记录第 $i$ 只鼹鼠的 $start$，那么 $upper \_ bound$ 时就只需要从 $start[i-1]$ 开始查找。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int t[10010],x[10010],y[10010];int f[10010],g[10010],start[10010];int dis(int a,int b) &#123;return abs(x[a]-x[b])+abs(y[a]-y[b]);&#125;int main() &#123;int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(int i&#x3D;1;i&lt;&#x3D;m;i++)scanf(&quot;%d%d%d&quot;,&amp;t[i],&amp;x[i],&amp;y[i]);for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123;start[i]&#x3D;max(0,int(upper_bound(t+start[i-1],t+i,t[i]-2*n)-t-1));f[i]&#x3D;g[start[i]]+1;for(int j&#x3D;max(1,start[i]);j&lt;i;j++) &#123;if(t[i]-t[j]&gt;&#x3D;dis(i,j))f[i]&#x3D;max(f[i],f[j]+1);&#125;g[i]&#x3D;max(g[i-1],f[i]);&#125;printf(&quot;%d\n&quot;,g[m]);return 0;&#125;</code></pre><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续继续优化</strong></p><p>我们甚至可以直接不用 $upper \_ bound$ 和 $start$ 数组了（没错），开一个变量 $start$，维护当前的 $start$，转移之前用一个</p><p><code>for(;t[i]-t[start+1]&gt;=2*n;start++);</code></p><p>来更新 $start$，可以发现，整个程序运行下来，$start$ 最多只会更新 $n$次，所以复杂度可忽略。</p><p>最终代码：</p><pre class="language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int t[10010],x[10010],y[10010];int f[10010],g[10010],start;int dis(int a,int b) &#123;return abs(x[a]-x[b])+abs(y[a]-y[b]);&#125;int main() &#123;int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(int i&#x3D;1;i&lt;&#x3D;m;i++)scanf(&quot;%d%d%d&quot;,&amp;t[i],&amp;x[i],&amp;y[i]);for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123;for(;t[i]-t[start+1]&gt;&#x3D;2*n;start++);f[i]&#x3D;g[start]+1;for(int j&#x3D;max(1,start);j&lt;i;j++) &#123;if(t[i]-t[j]&gt;&#x3D;dis(i,j))f[i]&#x3D;max(f[i],f[j]+1);&#125;g[i]&#x3D;max(g[i-1],f[i]);&#125;printf(&quot;%d\n&quot;,g[m]);return 0;&#125;</code></pre><p>不开O2可达48ms，可见优化非常显著。</p><p><strong>请勿抄袭，如果一定要抄，请理解明白后再抄</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【P4363一双木棋】题解</title>
      <link href="/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/"/>
      <url>/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/</url>
      
        <content type="html"><![CDATA[<p><del>本篇题解献给和我一样看不懂其他题解的状压DP小白</del></p><p>相信大家都是看了其他题解看不懂才看到这篇题解的（莫名自信），所以什么<strong>每行棋子数递减</strong>啊，<strong>每行的棋子都排在左边</strong>啊，就不用我多说了，直接切入正题（大段文字多，请耐心观看）。</p><h2 id="轮廓线DP"><a href="#轮廓线DP" class="headerlink" title="轮廓线DP"></a>轮廓线DP</h2><p>没见过不用慌，我也没见过（雾</p><p>轮廓线，就是把矩阵从右上角到左下角沿着有棋子和没棋子的分界线描一下，往下走就用1表示，往左走就用0表示。这样我们就得到了一个01串，即一个二进制数，这就是我们的DP状态。</p><p>例如（图丑勿喷）</p><p><img src="https://i.loli.net/2021/08/14/6RlDkBPy2JnVS7W.png" alt=""></p><p>这种情况下轮廓线状态为左左下左下下左左下，即$001011001_{(2)}=89$</p><p>我们设$f[s]$（$s$就是轮廓线状态）表示从轮廓线表示的局面一直下到最终下满的过程中“先手-后手”最大是多少。我们可以发现，只根据s就可以知道已经下了那些棋，但不能知道具体是黑棋还是白棋，然而根据$f$的定义，$f[s]$的值和前面怎么下的没有关系，它只管之后怎么下，所以我们只用一维轮廓线就OK，不需要记录之前怎么下的。</p><p>那么状态有了，怎么转移呢？以上图为例，即将要白棋（后手）下棋，后手肯定希望他下的一步棋能使得从现在开始（以前的我们不管）先手-后手得分尽可能小（如果是负数那他更开心了），所以$f[s]=\min\limits_{所有再下一步棋可能得到的方案s’}f[s’]-b[x][y]$（$x,y$就是即将下的那一步棋的坐标）。</p><p>同理，如果即将先手下，就把上面的式子里min改成max（因为他希望下这步棋能使得他的得分-对方的得分最大），$-b[x][y]$改成$+a[x][y]$。</p><p>这样我们就可以用记忆化搜索很容易地跑出来了。</p><p>哎等等，我们还有两个问题没解决，观察上面的式子，我们还不知道怎么枚举“所有再下一步棋可能得到的方案$s’$”，也不知道怎么根据轮廓线的变化找出具体坐标x和y啊？</p><p>我们一个一个解决，先看第一个问题。还是以上图为例，白棋（后手）可以下在$(1,4),(2,3),(4,1)$三个位置，但转移的时候电脑只知道当前的轮廓线，所以我们需要找这三个点的共同特点，那就是处在轮廓线左和下的拐角处，也就是轮廓线中先出现一个0，再出现一个1。现在我们知道了轮廓线上放棋子的位置，怎么得出放棋子后的轮廓线状态呢？我们还是以上图为例，如果我们放在$(2,3)$处，进行一个对比。</p><p>原：$001011001_{(2)}$</p><p>新：$001101001_{(2)}$</p><p><img src="https://i.loli.net/2021/08/15/YyPqDZpzrfl43kO.png" alt=""></p><p>我们发现只有第四位和第五位变了，而原先的第四位和第五位就是我们之前说的先出现一个0，再出现一个1，那么转移就是把0变成1，把1变成0。</p><p>具体来说，就是当我们枚举到一个$i$，使得原状态的（从低位数）第$i$位是1，第$i+1$位是0，那么就把状态异或上$3&lt;&lt;i$（可以对照例子手推一下）。</p><p>开始讨论第二个问题，我们知道该在轮廓线的哪一位上下棋，怎么知道那步棋的具体坐标呢？这个问题比较容易解决，只需要在枚举$i$时维护当前看到哪个坐标即可（详见代码）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;int n,m;int a[20][20],b[20][20];int f[1048580];bool vis[1048580];int dfs(int s,bool now)&#x2F;&#x2F;s是轮廓线状态，now记录是先手还是后手（虽然可以根据s算出来，但这样比较方便）&#123;if(vis[s])&#x2F;&#x2F;记忆化搜索标配return f[s];vis[s]&#x3D;1;if(s&#x3D;&#x3D;(1&lt;&lt;(n+m))-(1&lt;&lt;m))&#x2F;&#x2F;已经填满棋子（即n个下加m个左）return 0;int num0&#x3D;0,num1&#x3D;0;&#x2F;&#x2F;维护坐标（已经出现多少个左&#x2F;多少个下if(now)&#x2F;&#x2F;先手&#123;f[s]&#x3D;-2147483647;for(int i&#x3D;0;i&lt;n+m-1;i++)&#123;num1+&#x3D;((s&amp;(1&lt;&lt;i))&gt;&gt;i);num0+&#x3D;(!((s&amp;(1&lt;&lt;i))&gt;&gt;i));if((s&amp;(1&lt;&lt;i))&gt;0&amp;&amp;(s&amp;(1&lt;&lt;(i+1)))&#x3D;&#x3D;0)f[s]&#x3D;max(f[s],dfs(s^(3&lt;&lt;i),0)+a[n-num1+1][num0+1]);&#x2F;&#x2F;递归计算&#125;return f[s];&#125;else&#x2F;&#x2F;后手&#123;f[s]&#x3D;2147483647;for(int i&#x3D;0;i&lt;n+m-1;i++)&#123;num1+&#x3D;((s&amp;(1&lt;&lt;i))&gt;&gt;i);num0+&#x3D;(!((s&amp;(1&lt;&lt;i))&gt;&gt;i));if((s&amp;(1&lt;&lt;i))&amp;&amp;!(s&amp;(1&lt;&lt;(i+1))))f[s]&#x3D;min(f[s],dfs(s^(3&lt;&lt;i),1)-b[n-num1+1][num0+1]);&#x2F;&#x2F;递归计算&#125;return f[s];&#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;i++)for(int j&#x3D;1;j&lt;&#x3D;m;j++)cin&gt;&gt;a[i][j];for(int i&#x3D;1;i&lt;&#x3D;n;i++)for(int j&#x3D;1;j&lt;&#x3D;m;j++)cin&gt;&gt;b[i][j];cout&lt;&lt;dfs((1&lt;&lt;n)-1,1)&lt;&lt;endl;&#x2F;&#x2F;(1&lt;&lt;n)-1是初始状态，即m个左加n个下（一步棋也没下）return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能的高精度模板</title>
      <link href="/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/"/>
      <url>/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/</url>
      
        <content type="html"><![CDATA[<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;deque&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;class DividedByZeroException &#123;&#125;;class Int &#123;private:vector&lt;char&gt; digits;bool sign;void trim();public:Int(int);Int(string&amp;) ;Int();Int(const Int&amp;);Int operator&#x3D;(const Int&amp; op2);Int abs() const;Int pow(int a);friend Int operator+&#x3D;(Int&amp;, const Int&amp;);friend Int operator-&#x3D;(Int&amp;, const Int&amp;);friend Int operator*&#x3D;(Int&amp;, const Int&amp;);friend Int operator&#x2F;&#x3D;(Int&amp;, const Int&amp;) throw(DividedByZeroException);friend Int operator%&#x3D;(Int&amp;, const Int&amp;) throw(DividedByZeroException);friend Int operator+(const Int&amp;, const Int&amp;);friend Int operator-(const Int&amp;, const Int&amp;);friend Int operator*(const Int&amp;, const Int&amp;);friend Int operator&#x2F;(const Int&amp;, const Int&amp;) throw(DividedByZeroException);friend Int operator%(const Int&amp;, const Int&amp;) throw(DividedByZeroException);friend Int operator-(const Int&amp;);friend Int operator++(Int&amp;);friend Int operator++(Int&amp;, int);friend Int operator--(Int&amp;);friend Int operator--(Int&amp;, int);friend bool operator&gt;(const Int&amp;, const Int&amp;);friend bool operator&lt;(const Int&amp;, const Int&amp;);friend bool operator&#x3D;&#x3D;(const Int&amp;, const Int&amp;);friend bool operator!&#x3D;(const Int&amp;, const Int&amp;);friend bool operator&gt;&#x3D;(const Int&amp;, const Int&amp;);friend bool operator&lt;&#x3D;(const Int&amp;, const Int&amp;);friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Int&amp;);friend istream&amp; operator&gt;&gt;(istream&amp;, Int&amp;);public:static const Int ZERO;static const Int ONE;static const Int TEN;&#125;;const Int Int::ZERO &#x3D; Int(0);const Int Int::ONE &#x3D; Int(1);const Int Int::TEN &#x3D; Int(10);Int::Int() &#123;sign &#x3D; true;&#125;Int::Int(int val) &#123;if (val &gt;&#x3D; 0) &#123;sign &#x3D; true;&#125;else &#123;sign &#x3D; false;val *&#x3D; (-1);&#125;do &#123;digits.push_back((char)(val % 10));val &#x2F;&#x3D; 10;&#125; while (val !&#x3D; 0);&#125;Int::Int(string&amp; def) &#123;sign &#x3D; true;for (string::reverse_iterator iter &#x3D; def.rbegin() ; iter &lt; def.rend();  iter++) &#123;char ch &#x3D; (*iter);if (iter &#x3D;&#x3D; def.rend() - 1) &#123;if (ch &#x3D;&#x3D; &#39;+&#39;) &#123;break;&#125;if (ch &#x3D;&#x3D; &#39;-&#39;) &#123;sign &#x3D; false;break;&#125;&#125;digits.push_back((char)((*iter) - &#39;0&#39;));&#125;trim();&#125;void Int::trim() &#123;vector&lt;char&gt;::reverse_iterator iter &#x3D; digits.rbegin();while (!digits.empty() &amp;&amp; (*iter) &#x3D;&#x3D; 0) &#123;digits.pop_back();iter &#x3D; digits.rbegin();&#125;if (digits.size() &#x3D;&#x3D; 0) &#123;sign &#x3D; true;digits.push_back(0);&#125;&#125;Int::Int(const Int&amp; op2) &#123;sign &#x3D; op2.sign;digits &#x3D; op2.digits;&#125;Int Int::operator&#x3D;(const Int&amp; op2) &#123;digits &#x3D; op2.digits;sign &#x3D; op2.sign;return (*this);&#125;Int Int::abs() const &#123;if (sign) &#123;return *this;&#125;else &#123;return -(*this);&#125;&#125;Int Int::pow(int a) &#123;Int res(1);for (int i &#x3D; 0; i &lt; a; i++) &#123;res *&#x3D; (*this);&#125;return res;&#125;Int operator+&#x3D;(Int&amp; op1, const Int&amp; op2) &#123;if (op1.sign &#x3D;&#x3D; op2.sign) &#123;vector&lt;char&gt;::iterator iter1;vector&lt;char&gt;::const_iterator iter2;iter1 &#x3D; op1.digits.begin();iter2 &#x3D; op2.digits.begin();char to_add &#x3D; 0;while (iter1 !&#x3D; op1.digits.end() &amp;&amp; iter2 !&#x3D; op2.digits.end()) &#123;(*iter1) &#x3D; (*iter1) + (*iter2) + to_add;to_add &#x3D; ((*iter1) &gt; 9);(*iter1) &#x3D; (*iter1) % 10;iter1++;iter2++;&#125;while (iter1 !&#x3D; op1.digits.end()) &#123;(*iter1) &#x3D; (*iter1) + to_add;to_add &#x3D; ((*iter1) &gt; 9);(*iter1) %&#x3D; 10;iter1++;&#125;while (iter2 !&#x3D; op2.digits.end()) &#123;char val &#x3D; (*iter2) + to_add;to_add &#x3D; (val &gt; 9) ;val %&#x3D; 10;op1.digits.push_back(val);iter2++;&#125;if (to_add !&#x3D; 0) &#123;op1.digits.push_back(to_add);&#125;return op1;&#125;else &#123;if (op1.sign) &#123;return op1 -&#x3D; (-op2);&#125;else &#123;return op1 &#x3D; op2 - (-op1);&#125;&#125;&#125;Int operator-&#x3D;(Int&amp; op1, const Int&amp; op2) &#123;if (op1.sign &#x3D;&#x3D; op2.sign) &#123;if (op1.sign) &#123;if (op1 &lt; op2) &#123;return  op1 &#x3D; -(op2 - op1);&#125;&#125;else &#123;if (-op1 &gt; -op2) &#123;return op1 &#x3D; -((-op1) - (-op2));&#125;else &#123;return op1 &#x3D; (-op2) - (-op1);&#125;&#125;vector&lt;char&gt;::iterator iter1;vector&lt;char&gt;::const_iterator iter2;iter1 &#x3D; op1.digits.begin();iter2 &#x3D; op2.digits.begin();char to_substract &#x3D; 0;while (iter1 !&#x3D; op1.digits.end() &amp;&amp; iter2 !&#x3D; op2.digits.end()) &#123;(*iter1) &#x3D; (*iter1) - (*iter2) - to_substract;to_substract &#x3D; 0;if ((*iter1) &lt; 0) &#123;to_substract &#x3D; 1;(*iter1) +&#x3D; 10;&#125;iter1++;iter2++;&#125;while (iter1 !&#x3D; op1.digits.end()) &#123;(*iter1) &#x3D; (*iter1) - to_substract;to_substract &#x3D; 0;if ((*iter1) &lt; 0) &#123;to_substract &#x3D; 1;(*iter1) +&#x3D; 10;&#125;else &#123;break;&#125;iter1++;&#125;op1.trim();return op1;&#125;else &#123;if (op1 &gt; Int::ZERO) &#123;return op1 +&#x3D; (-op2);&#125;else &#123;return op1 &#x3D; -(op2 + (-op1));&#125;&#125;&#125;Int operator*&#x3D;(Int&amp; op1, const Int&amp; op2) &#123;Int result(0);if (op1 &#x3D;&#x3D; Int::ZERO || op2 &#x3D;&#x3D; Int::ZERO) &#123;result &#x3D; Int::ZERO;&#125;else &#123;vector&lt;char&gt;::const_iterator iter2 &#x3D; op2.digits.begin();while (iter2 !&#x3D; op2.digits.end()) &#123;if (*iter2 !&#x3D; 0) &#123;deque&lt;char&gt; temp(op1.digits.begin(), op1.digits.end());char to_add &#x3D; 0;deque&lt;char&gt;::iterator iter1 &#x3D; temp.begin();while (iter1 !&#x3D; temp.end()) &#123;(*iter1) *&#x3D; (*iter2);(*iter1) +&#x3D; to_add;to_add &#x3D; (*iter1) &#x2F; 10;(*iter1) %&#x3D; 10;iter1++;&#125;if (to_add !&#x3D; 0) &#123;temp.push_back(to_add);&#125;int num_of_zeros &#x3D; iter2 - op2.digits.begin();while (num_of_zeros--) &#123;temp.push_front(0);&#125;Int temp2;temp2.digits.insert(temp2.digits.end(), temp.begin(), temp.end());temp2.trim();result &#x3D; result + temp2;&#125;iter2++;&#125;result.sign &#x3D; ((op1.sign &amp;&amp; op2.sign) || (!op1.sign &amp;&amp; !op2.sign));&#125;op1 &#x3D; result;return op1;&#125;Int operator&#x2F;&#x3D;(Int&amp; op1, const Int&amp; op2) throw(DividedByZeroException) &#123;if (op2 &#x3D;&#x3D; Int::ZERO) &#123;throw DividedByZeroException();&#125;Int t1 &#x3D; op1.abs(), t2 &#x3D; op2.abs();if (t1 &lt; t2) &#123;op1 &#x3D; Int::ZERO;return op1;&#125;deque&lt;char&gt; temp;vector&lt;char&gt;::reverse_iterator iter &#x3D; t1.digits.rbegin();Int temp2(0);while (iter !&#x3D; t1.digits.rend()) &#123;temp2 &#x3D; temp2 * Int::TEN + Int((int)(*iter));char s &#x3D; 0;while (temp2 &gt;&#x3D; t2) &#123;temp2 &#x3D; temp2 - t2;s &#x3D; s + 1;&#125;temp.push_front(s);iter++;&#125;op1.digits.clear();op1.digits.insert(op1.digits.end(), temp.begin(), temp.end());op1.trim();op1.sign &#x3D; ((op1.sign &amp;&amp; op2.sign) || (!op1.sign &amp;&amp; !op2.sign));return op1;&#125;Int operator%&#x3D;(Int&amp; op1, const Int&amp; op2) throw(DividedByZeroException) &#123;return op1 -&#x3D; ((op1 &#x2F; op2) * op2);&#125;Int operator+(const Int&amp; op1, const Int&amp; op2) &#123;Int temp(op1);temp +&#x3D; op2;return temp;&#125;Int operator-(const Int&amp; op1, const Int&amp; op2) &#123;Int temp(op1);temp -&#x3D; op2;return temp;&#125;Int operator*(const Int&amp; op1, const Int&amp; op2) &#123;Int temp(op1);temp *&#x3D; op2;return temp;&#125;Int operator&#x2F;(const Int&amp; op1, const Int&amp; op2) throw(DividedByZeroException) &#123;Int temp(op1);temp &#x2F;&#x3D; op2;return temp;&#125;Int operator%(const Int&amp; op1, const Int&amp; op2) throw(DividedByZeroException) &#123;Int temp(op1);temp %&#x3D; op2;return temp;&#125;Int operator-(const Int&amp; op) &#123;Int temp &#x3D; Int(op);temp.sign &#x3D; !temp.sign;return temp;&#125;Int operator++(Int&amp; op) &#123;op +&#x3D; Int::ONE;return op;&#125;Int operator++(Int&amp; op, int x) &#123;Int temp(op);++op;return temp;&#125;Int operator--(Int&amp; op) &#123;op -&#x3D;  Int::ONE;return op;&#125;Int operator--(Int&amp; op, int x) &#123;Int temp(op);--op;return temp;&#125;bool operator&lt;(const Int&amp; op1, const Int&amp; op2) &#123;if (op1.sign !&#x3D; op2.sign) &#123;return !op1.sign;&#125;else &#123;if (op1.digits.size() !&#x3D; op2.digits.size())return (op1.sign &amp;&amp; op1.digits.size() &lt; op2.digits.size())|| (!op1.sign &amp;&amp; op1.digits.size() &gt; op2.digits.size());vector&lt;char&gt;::const_reverse_iterator iter1, iter2;iter1 &#x3D; op1.digits.rbegin();iter2 &#x3D; op2.digits.rbegin();while (iter1 !&#x3D; op1.digits.rend()) &#123;if (op1.sign &amp;&amp;  *iter1 &lt; *iter2) &#123;return true;&#125;if (op1.sign &amp;&amp;  *iter1 &gt; *iter2) &#123;return false;&#125;if (!op1.sign &amp;&amp;  *iter1 &gt; *iter2) &#123;return true;&#125;if (!op1.sign &amp;&amp;  *iter1 &lt; *iter2) &#123;return false;&#125;iter1++;iter2++;&#125;return false;&#125;&#125;bool operator&#x3D;&#x3D;(const Int&amp; op1, const Int&amp; op2) &#123;if (op1.sign !&#x3D; op2.sign  || op1.digits.size() !&#x3D; op2.digits.size()) &#123;return false;&#125;vector&lt;char&gt;::const_iterator iter1, iter2;iter1 &#x3D; op1.digits.begin();iter2 &#x3D; op2.digits.begin();while (iter1 !&#x3D; op1.digits.end()) &#123;if (*iter1 !&#x3D; *iter2) &#123;return false;&#125;iter1++;iter2++;&#125;return true;&#125;bool operator!&#x3D;(const Int&amp; op1, const Int&amp; op2) &#123;return !(op1 &#x3D;&#x3D; op2);&#125;bool operator&gt;&#x3D;(const Int&amp; op1, const Int&amp; op2) &#123;return (op1 &gt; op2) || (op1 &#x3D;&#x3D; op2);&#125;bool operator&lt;&#x3D;(const Int&amp; op1, const Int&amp; op2) &#123;return (op1 &lt; op2) || (op1 &#x3D;&#x3D; op2);&#125;bool operator&gt;(const Int&amp; op1, const Int&amp; op2) &#123;return !(op1 &lt;&#x3D; op2);&#125;ostream&amp; operator&lt;&lt;(ostream&amp; stream, const Int&amp; val) &#123;if (!val.sign) &#123;stream &lt;&lt; &quot;-&quot;;&#125;for (vector&lt;char&gt;::const_reverse_iterator iter &#x3D; val.digits.rbegin(); iter !&#x3D; val.digits.rend() ; iter++) &#123;stream &lt;&lt; (char)((*iter) + &#39;0&#39;);&#125;return stream;&#125;istream&amp; operator&gt;&gt;(istream&amp; stream, Int&amp; val) &#123;string str;stream &gt;&gt; str;val &#x3D; Int(str);return stream;&#125;int main() &#123;Int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;a*b&lt;&lt;endl;return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得学习笔记</title>
      <link href="/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/"/>
      <url>/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>温馨提示1：本文推式子比较多，建议跟着文章自己推一推。</p><p>温馨提示2：本文小字比较多，如果分辨率不够可以放大网页。</p><h2 id="0-扩展欧几里得是什么"><a href="#0-扩展欧几里得是什么" class="headerlink" title="0. 扩展欧几里得是什么"></a>0. 扩展欧几里得是什么</h2><p>扩展欧几里得（exgcd）是一个可以用来求$ax+by=c$（$c\% \gcd(a,b)=0$，否则无解）的解的算法</p><p>怎么求$ax+by=c (c\% \gcd(a,b)=0)$的解呢？</p><h2 id="1-ax-by-gcd-a-b"><a href="#1-ax-by-gcd-a-b" class="headerlink" title="1. $ax+by=\gcd(a,b)$"></a>1. $ax+by=\gcd(a,b)$</h2><p>怎么求$ax+by=\gcd(a,b)$的解呢？</p><p>首先，如果$b=0$的话，$\gcd(a,b)=a$，则解为$\begin{cases}x=1 \\ y=0\end{cases}$</p><p>设此方程的解为$\begin{cases}x=x_0 \\ y=y_0\end{cases}$</p><p>那么我们需要做的就是将$ax_0+by_0=\gcd(a,b)$转化为$b=0$的格式，这就要用到辗转相除法了。</p><p>设另一个方程：$bx_1+(a\% b)y_1=\gcd(b,a\% b)$</p><p>设$a_1=b,b_1=a\% b$</p><p>则该方程转化为$a_1x_1+b_1y_1=\gcd(a_1,b_1)$</p><p>我们会发现它和原方程的格式是一样的，而且根据欧几里得原理，它可以一直递推到$a_nx_n+b_ny_n=\gcd(a_n,b_n)$使得$b_n=0$，就可以求得解$\begin{cases}x_n=1 \\ y_n=0\end{cases}$</p><p>那假设我们已经求得了该结果，那如何推导出$x_0$和$y_0$呢？</p><p>我们首先研究如何从$x_1$和$y_1$推导出$x_0$和$y_0$，其他的就同理了</p><p>因为</p><p>$\begin{cases}bx_1+(a\% b)y_1=\gcd(b,a\% b) \\ ax_0+by_0=\gcd(a,b)\end{cases}$</p><p>且根据欧几里得定理，$\gcd(a,b)=\gcd(b,a\% b)$</p><p>所以</p><p>$ax_0+by_0=bx_1+(a\% b)y_1$</p><p>且$a\% b=a-\lfloor\frac{a}{b}\rfloor b$（好好体会一下）</p><p>所以</p><p>$ax_0+by_0=bx_1+(a-\lfloor\frac{a}{b}\rfloor b)y_1$</p><p>$ax_0+by_0=bx_1+ay_1-\lfloor\frac{a}{b}\rfloor b y_1$</p><p>$ax_0+by_0=b(x1-\lfloor\frac{a}{b}\rfloor y_1)+ay_1$</p><p>$ax_0+by_0=ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1)$</p><p>即$\begin{cases}x_0=y_1 \\ y_0=x_1-\lfloor\frac{a}{b}\rfloor y_1\end{cases}$</p><p>这样，我们就由$x_1$和$y_1$推导出了$x_0$和$y_0$，其他同理</p><p>于是乎：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct node&#123;int x,y;&#125;;node exgcd(int a,int b)&#123;if(b&#x3D;&#x3D;0)&#123;node tmp;tmp.x&#x3D;1,tmp.y&#x3D;0;return tmp;&#125;node tmp&#x3D;exgcd(b,a%b);&#x2F;&#x2F;递归求出x_(k+1)和y_(k+1)node ans;ans.x&#x3D;tmp.y,ans.y&#x3D;(tmp.x)-a&#x2F;b*(tmp.y);&#x2F;&#x2F;推导出x_k和y_kreturn ans;&#125;</code></pre><p>这样，我们就求出了$ax+by=\gcd(a,b)$的一组解</p><h2 id="2-ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases"><a href="#2-ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases" class="headerlink" title="2. $ax+by=c$的一组解$\begin{cases}x=x_{tmp}\\y=y_{tmp}\end{cases}$"></a>2. $ax+by=c$的一组解$\begin{cases}x=x_{tmp}\\y=y_{tmp}\end{cases}$</h2><p>我们已经求出了$ax+by=\gcd(a,b)$的一组解$\begin{cases}x=x_0 \\ y=y_0\end{cases}$</p><p>那么我们就可以知道$akx_0+bky_0=k\gcd(a,b)$</p><p>又因为要求$c$是$\gcd(a,b)$的倍数（否则无解）</p><p>所以$k=\frac{c}{\gcd(a,b)}$</p><p>所以很简单：</p><p>$\begin{cases}x_{tmp}=kx_0=\frac{c}{\gcd(a,b)}x_0 \\ y_{tmp}=ky_0=\frac{c}{\gcd(a,b)}y_0\end{cases}$</p><h2 id="3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases"><a href="#3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases" class="headerlink" title="3.$ax+by=c$的所有解$\begin{cases}x=x_{ans}\\y=y_{ans}\end{cases}$"></a>3.$ax+by=c$的所有解$\begin{cases}x=x_{ans}\\y=y_{ans}\end{cases}$</h2><p>我们已经求出了$ax+by=c$的一组解$\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>即$ax_{tmp}+by_{tmp}=c$</p><p>将它加上再减去$\frac{ab}{\gcd(a,b)}$，得到</p><p>$ax_{tmp}+\frac{ab}{\gcd(a,b)}+by_{tmp}-\frac{ab}{\gcd(a,b)}=c$</p><p>$a(x_{tmp}+\frac{b}{\gcd(a,b)})+b(y_{tmp}-\frac{a}{\gcd(a,b)})=c$</p><p>在$x_{tmp}$上减，在$y_{tmp}$上加也同理</p><p>所以$\begin{cases}x=x_{tmp}\pm\frac{b}{\gcd(a,b)} \\ y=y_{tmp}\mp\frac{a}{\gcd(a,b)}\end{cases}$也是一组解</p><p>这个变换进行多次，即可得到</p><p>$\begin{cases}x_{ans}=x_{tmp}+t\times\frac{b}{\gcd(a,b)} \\ y_{ans}=y_{tmp}-t\times\frac{a}{\gcd(a,b)}\end{cases}$（$t$的正负可以代替加和减的分类讨论）</p><h2 id="4-x-和-y-各自的最小正整数解"><a href="#4-x-和-y-各自的最小正整数解" class="headerlink" title="4. $x$和$y$各自的最小正整数解"></a>4. $x$和$y$各自的最小正整数解</h2><p>以$x$的最小正整数解为例：</p><p>求出任意一组解$\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>因为将$x_{tmp}$加或减$\frac{b}{\gcd(a,b)}$也成立，所以可设$d=\frac{b}{\gcd(a,b)}$（注意这里分子是$b$）</p><p>$x_{min}=(x_{tmp}\% d+d)\% d$（因为$x_{tmp}$有可能是负数）</p><p>同理对于$y$，设$d=\frac{a}{\gcd(a,b)}$（注意这里分子是$a$）</p><p>$y_{min}=(y_{tmp}\% d+d)\% d$</p><h2 id="5-完结撒花"><a href="#5-完结撒花" class="headerlink" title="5. 完结撒花"></a>5. 完结撒花</h2><p>至此，你已经学完了扩展欧几里得的基础用法，如有不懂的地方，建议对照着文章自己推一推，悟一悟。</p><p>做个题练习一下吧：<a href="https://www.luogu.com.cn/problem/P5656">洛谷 P5656 【模板】二元一次不定方程 (exgcd)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/14/hello-world/"/>
      <url>/2021/08/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
