<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ABC-269解题报告</title>
      <link href="/2022/09/18/abc-269-jie-ti-bao-gao/"/>
      <url>/2022/09/18/abc-269-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc269/">比赛传送门</a></p><h2 id="D-Do-use-hexagon-grid"><a href="#D-Do-use-hexagon-grid" class="headerlink" title="D. Do use hexagon grid"></a>D. Do use hexagon grid</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_d">题目传送门</a></p><p>$n^2$ 枚举两个格点，判断是否能直接走，能则连边，最后用 dfs 计算连通块个数。</p><h2 id="E-Last-Rook"><a href="#E-Last-Rook" class="headerlink" title="E. Last Rook"></a>E. Last Rook</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_e">题目传送门</a></p><p>由于不需要考虑斜向的冲突，所以考虑行和列分开二分。以行为例：</p><p>如果有若干连续行的棋子数量小于行数，则答案一定在这些行中，以此作为二分的 check。</p><h2 id="F-Numbered-Checker"><a href="#F-Numbered-Checker" class="headerlink" title="F. Numbered Checker"></a>F. Numbered Checker</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_f">题目传送门</a></p><p>显然每一行剩下的数都是一个等差数列。</p><p>考虑奇偶行分开计算：对于奇数行，只有奇数列能产生贡献；对于偶数行，只有偶数列能产生贡献。以奇数行为例：</p><p>若输入的四界分别为 $u,d,l,r$，则只考虑奇数行时，我们将四界缩紧为 $u’,d’,l’,r’$（为方便接下来处理），此时能产生贡献的列数为 $len_{row}=(r’-l’)/2+1$，行数为 $len_{column}=(d’-u’)/2+1$。</p><p>显然贡献的左上角的值为 $s_1=(u’-1)\times m+l’$，右上角为 $s_2=(u’-1)\times m+r’$，则第一行的和 $sum_{u’}=(s_1+s_2)\times len_{row}$。</p><p>第二个产生贡献的行（即 $u’+2$ 行）的和为 $sum_{u’+2}=sum_{u’}+len_{row}\times 2m$，第三行为 $sum_{u’+4}=sum_{u’}+len_{row}\times 4m$ 以此类推。可以发现每一行都含有一个 $sum_{u’}$ 的项，单独提出来，得到 $sum_{u’}\times len_{column}$，而每一行新加的贡献为 $len_{row}\times 0m+len_{row}\times 2m+len_{row}\times 4m\cdots$，这也可以很容易得用等差数列求得。</p><p>偶数行偶数列的情况同理，由于操作完全相同，可以封装成函数调用两遍。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,u,d,ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;d&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">auto</span> solve=[&amp;](<span class="keyword">bool</span> flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> u1=u,d1=d,l1=l,r1=r;</span><br><span class="line">            <span class="keyword">if</span>(u1%<span class="number">2</span>==flag) u1++;</span><br><span class="line">            <span class="keyword">if</span>(d1%<span class="number">2</span>==flag) d1--;</span><br><span class="line">            <span class="keyword">if</span>(l1%<span class="number">2</span>==flag) l1++;</span><br><span class="line">            <span class="keyword">if</span>(r1%<span class="number">2</span>==flag) r1--;</span><br><span class="line">            <span class="keyword">int</span> lenrow=(r1-l1)/<span class="number">2</span>+<span class="number">1</span>,lencol=(d1-u1)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">add</span>(<span class="built_in">add</span>(<span class="built_in">mul</span>(u1<span class="number">-1</span>,m),l1),<span class="built_in">add</span>(<span class="built_in">mul</span>(u1<span class="number">-1</span>,m),r1)),lenrow),inv2);</span><br><span class="line">            (ans+=<span class="built_in">mul</span>(res,lencol))%=mod;</span><br><span class="line">            (ans+=<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="number">2</span>*(lencol<span class="number">-1</span>),m),lencol),inv2),lenrow))%=mod;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>),<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博弈论学习笔记</title>
      <link href="/2022/07/12/bo-yi-lun-xue-xi-bi-ji/"/>
      <url>/2022/07/12/bo-yi-lun-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>挖个巨坑，慢慢填。</p><h2 id="从-Nim-游戏入手"><a href="#从-Nim-游戏入手" class="headerlink" title="从 Nim 游戏入手"></a>从 Nim 游戏入手</h2><p>问题：有 $n$ 堆石子，第 $i$ 堆石子有 $s_i$ 个，两个人轮流取石子，每人每次只能从一堆中取任意数量的石子，可以取完，不能不取。问先手必胜还是必败。</p><blockquote><p>前置知识：</p><ol><li>异或 $\oplus$：有两个数均为 $0$ 或 $1$，若它们相等则异或结果为 $0$，不相等结果为 $1$</li><li>按位异或 $\oplus$：将两个正整数分别表示成二进制，对应位进行异或。易证，按位异或满足交换律、结合律，同时有自反性，即 $a\oplus a=0$</li><li>异或和：若干个正整数 $a_1,a_2,a_3,\ldots,a_n$ 的异或和为 $a_1\oplus a_2\oplus a_3\oplus\ldots\oplus a_n$。容易发现，若 $s$（二进制）中某一位为 $1$ 的数字个数为奇数，则异或和中该位为 $1$；若为偶数，则异或和中该位为 $0$</li></ol></blockquote><p><strong>结论：若 $s$ 的异或和为 $0$，先手必败，反之则先手必胜。</strong></p><p>感性理解一下。考虑只有两堆的特殊情况，如果两堆的数量相等，那么先手必败，策略为：先手从一堆中取若干个，后手从另一堆中取相同个数，则易证一定被后手取完。反之，如果两堆的数量不等，那么先手必胜，策略为：先从多的那堆里取若干个，使两堆数量相等，接下来同上（后手变为上面的先手）。</p><p>考虑用异或来解释。若先手取时两堆不相等（即异或和不为 $0$），则从多的那堆里取若干个使两堆相等（使得异或和变为 $0$）。接下来无论后手怎么取，一定会导致两堆数量不相等（使异或和不为 $0$）。先手从另一堆中模仿后手操作，使两堆再次相等（异或和重新变成 $0$），以此类推。</p><p>有了以上感性理解，我们就可以尝试推广到 $n$ 堆的普遍情况。</p><p><strong>定理一：当异或和不为 $0$ 时，一定存在一种取石子方式使得异或和变为 $0$。</strong></p><p>证明：</p><p>若我们所在的状态满足 $s_1\oplus s_2\oplus\ldots\oplus s_n=m (m\ne 0)$（$s_i$ 表示第 $i$ 堆的石子数），则$s_1\oplus s_2\oplus\ldots\oplus s_n\oplus m=m\oplus m=0$（自反性），所以只要随便选择一堆 $s_i$ 变为 $s_i\oplus m$ 即可。但是由于要“取”石子，所以要求变化后石子数必须减少，那么是否一定存在一堆 $s_i$ 满足 $s_i\oplus m&lt;s_i$ 呢？答案是肯定的。</p><p>$m$（二进制）的最高位（设为第 $k$ 位）的 $1$ 一定是由 $s$ 中奇数个 $1$ 得来的，也就是在 $s$ 中一定存在至少一个第 $k$ 位为 $1$ 的数。随便选一个，假设为第 $i$ 个，则将上式最后的 $\oplus m$ 与 $s_i$ 结合，结果一定会比 $s_i$ 小。因为 $s_i$ 比 $k$ 高的位不变，第 $k$ 位由 $1$ 变为了 $0$，剩下的无论怎么变结果都会比 $s_i$ 小。</p><p>所以只要异或和不为 $0$，一定可以通过选合适的一堆取若干个石子使得 $s_i\to s_i\oplus m$，则异或和 $m\to 0$。</p><p><strong>定理二：当异或和为 $0$ 时，无论如何取石子，取后异或和都将不为 $0$。</strong></p><p>证明：</p><p>假设取后异或和仍然为 $0$，则 $m=0$，又因为 $m$ 只能选一堆结合，所以 $s_i$ 只能不变。但题目要求必须取，与假设矛盾，所以取后异或和一定不为 $0$。</p><p>综上所述，当先手处于异或和不为 $0$ 的状态时：</p><ol><li>先手一定可以通过一定方式变成异或和为 $0$（定理一）</li><li>此时后手只能变成异或和不为 $0$（定理二），接下来重复步骤 1</li><li>胜利状态的 $s$ 全为 $0$，异或和为 $0$，而对手只能变成异或和不为 $0$，所以永远取不到胜利状态</li><li>由于每步石子数必然会减少，最终一定会达到胜利状态，则胜利状态必然由先手取到</li></ol><p>若先手处于异或和为 $0$ 的状态，则任何操作都将导致异或和不为 $0$，接下来后手如上操作，则后手必胜。</p><p>未完待续，不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>儒略日-题解</title>
      <link href="/2022/07/07/ru-lue-ri-ti-jie/"/>
      <url>/2022/07/07/ru-lue-ri-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时隔两年，这个极为经典的题目终于被我 AC 了。经过诸多优化改良，最终得到了这个个人认为比较优美的做法，写篇题解纪念一下，也供参考。</p><p>首先，建议读者先对照无注释代码自行理解一下大致过程。</p><h2 id="无注释代码"><a href="#无注释代码" class="headerlink" title="无注释代码"></a>无注释代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _1=<span class="number">365</span>,_100=_1*<span class="number">100</span>+<span class="number">24</span>,_400=_100*<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span><span class="keyword">int</span> y,m,d,ru;&#125; t[<span class="number">4000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrun</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year&lt;<span class="number">0</span>) <span class="keyword">return</span> (year+<span class="number">1</span>)%<span class="number">4</span>==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;(year&lt;=<span class="number">1582</span>||year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">date <span class="title">nxtday</span><span class="params">(date a)</span> </span>&#123;</span><br><span class="line">    a.d++,a.ru++;</span><br><span class="line">    <span class="keyword">if</span>(a.y==<span class="number">1582</span>&amp;&amp;a.m==<span class="number">10</span>&amp;&amp;a.d==<span class="number">5</span>) <span class="keyword">return</span> a.d=<span class="number">15</span>,a;</span><br><span class="line">    <span class="keyword">if</span>(a.m==<span class="number">2</span>&amp;&amp;a.d==<span class="number">29</span>&amp;&amp;<span class="built_in">isrun</span>(a.y));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.d&gt;mon[a.m]) a.m++,a.d=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.m&gt;<span class="number">12</span>) a.y++,a.y+=!a.y,a.m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(date x)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;x.d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x.m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">abs</span>(x.y)&lt;&lt;(x.y&lt;<span class="number">0</span>?<span class="string">&quot; BC&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>]=&#123;<span class="number">-4713</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> _20000101;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;t[i<span class="number">-1</span>].y&lt;=<span class="number">2000</span>;i++) &#123;</span><br><span class="line">        t[i]=<span class="built_in">nxtday</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(t[i].y==<span class="number">2000</span>&amp;&amp;t[i].m==<span class="number">1</span>&amp;&amp;t[i].d==<span class="number">1</span>)</span><br><span class="line">            _20000101=t[i].ru;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _0=_20000101-_400*<span class="number">5</span>,T,x;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=_20000101) <span class="built_in">print</span>(t[x]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            date ans&#123;(x-_0)/_400*<span class="number">400</span>,<span class="number">1</span>,<span class="number">1</span>,(x-_0)/_400*_400+_0&#125;;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_100+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_100+<span class="built_in">isrun</span>(ans.y),ans.y+=<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_1+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_1+<span class="built_in">isrun</span>(ans.y),ans.y++;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru&lt;x) ans=<span class="built_in">nxtday</span>(ans);</span><br><span class="line">            <span class="built_in">print</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>大体思路是这样的：$1582$ 年之前的暴力 <code>nxtday</code> 跑出来，而 $1582$ 年之后的想办法逐渐逼近计算。</p><p>这里我们暴力跑到了 $2000$ 年（以下讲解只考虑 $2000$ 年以后），并保存了 <code>_20000101</code> 这个常数，表示 $2000$ 年 $1$ 月 $1$ 日的儒略日。原因之一是避免考虑边界情况，而原因之二，就是本做法的灵魂所在：</p><blockquote><p>重点在于 <code>_20000101</code> 这个常数。将这个常数减去五个 $400$ 年（代码中的 <code>_400</code>），就可以反推出“理想状态下”公元 $0$ 年 $1$ 月 $1$ 日的儒略日 <code>_0</code>。这样，我们就可以 $O(1)$ 计算出所求儒略日位于哪一个“$400$ 年周期”中，并得到该周期的第一天的确切 <code>date</code>：</p><ul><li><code>year=(x-_0)/_400*400</code></li><li><code>ru=(x-_0)/_400*_400+_0</code></li></ul><p>这两行为本 trick 的精华，建议仔细理解（见程序第 36 行）</p></blockquote><p>求出了本周期第一天的儒略日，接下来就是简单的逼近答案了：先尝试每次加上 $100$ 年（不超过 $4$ 次），再每次加上 $1$ 年（不超过 $100$ 次），最后暴力 <code>nxtday</code> 跑到答案（不超过 $365$ 次）。时间复杂度在可接受范围之内。</p><h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _1=<span class="number">365</span>,_100=_1*<span class="number">100</span>+<span class="number">24</span>,_400=_100*<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//方便计算，预处理出格里高利历1年、100年和400年的天数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span><span class="keyword">int</span> y,m,d,ru;&#125; t[<span class="number">4000010</span>];</span><br><span class="line"><span class="comment">//公元前的y为负数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrun</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123; <span class="comment">//闰年判断</span></span><br><span class="line">    <span class="keyword">if</span>(year&lt;<span class="number">0</span>) <span class="keyword">return</span> (year+<span class="number">1</span>)%<span class="number">4</span>==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;(year&lt;=<span class="number">1582</span>||year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">date <span class="title">nxtday</span><span class="params">(date a)</span> </span>&#123; <span class="comment">//暴力计算下一天</span></span><br><span class="line">    a.d++,a.ru++; <span class="comment">//天数和儒略日首先增加</span></span><br><span class="line">    <span class="keyword">if</span>(a.y==<span class="number">1582</span>&amp;&amp;a.m==<span class="number">10</span>&amp;&amp;a.d==<span class="number">5</span>) <span class="keyword">return</span> a.d=<span class="number">15</span>,a;</span><br><span class="line">    <span class="comment">//特判中间消失的10天</span></span><br><span class="line">    <span class="keyword">if</span>(a.m==<span class="number">2</span>&amp;&amp;a.d==<span class="number">29</span>&amp;&amp;<span class="built_in">isrun</span>(a.y)); <span class="comment">//闰年的2月29无需进位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.d&gt;mon[a.m]) a.m++,a.d=<span class="number">1</span>; <span class="comment">//由日向月进位</span></span><br><span class="line">    <span class="keyword">if</span>(a.m&gt;<span class="number">12</span>) a.y++,a.y+=!a.y,a.m=<span class="number">1</span>; <span class="comment">//由月向年进位（特判了公元0年不存在）</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(date x)</span> </span>&#123; <span class="comment">//输出</span></span><br><span class="line">    cout&lt;&lt;x.d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x.m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">abs</span>(x.y)&lt;&lt;(x.y&lt;<span class="number">0</span>?<span class="string">&quot; BC&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>]=&#123;<span class="number">-4713</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> _20000101;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;t[i<span class="number">-1</span>].y&lt;=<span class="number">2000</span>;i++) &#123; <span class="comment">//暴力打表到2000年</span></span><br><span class="line">        t[i]=<span class="built_in">nxtday</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(t[i].y==<span class="number">2000</span>&amp;&amp;t[i].m==<span class="number">1</span>&amp;&amp;t[i].d==<span class="number">1</span>)</span><br><span class="line">            _20000101=t[i].ru; <span class="comment">//保存常数2000.1.1儒略日</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _0=_20000101-_400*<span class="number">5</span>,T,x; <span class="comment">//计算“理想状态”下0.1.1儒略日</span></span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=_20000101) <span class="built_in">print</span>(t[x]); <span class="comment">//直接查表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            date ans&#123;(x-_0)/_400*<span class="number">400</span>,<span class="number">1</span>,<span class="number">1</span>,(x-_0)/_400*_400+_0&#125;;</span><br><span class="line">            <span class="comment">//计算400周期的第一天（格式为y,m,d,ru）</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_100+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_100+<span class="built_in">isrun</span>(ans.y),ans.y+=<span class="number">100</span>;</span><br><span class="line">            <span class="comment">//100年为步长逼近</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_1+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_1+<span class="built_in">isrun</span>(ans.y),ans.y++;</span><br><span class="line">            <span class="comment">//1年为步长逼近</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru&lt;x) ans=<span class="built_in">nxtday</span>(ans);</span><br><span class="line">            <span class="comment">//暴力nxtday得到答案</span></span><br><span class="line">            <span class="built_in">print</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC-138解题报告</title>
      <link href="/2022/05/01/arc-138-jie-ti-bao-gao/"/>
      <url>/2022/05/01/arc-138-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/arc138">比赛传送门</a></p><h2 id="A-Larger-Score"><a href="#A-Larger-Score" class="headerlink" title="A. Larger Score"></a><a href="https://atcoder.jp/contests/arc138/tasks/arc138_a">A. Larger Score</a></h2><p>因为只需要增加而不限制增加量，所以找到一对前小后大的数对，设法将它们交换即可。具体来说，所以对于 $k+1$ 到 $n$ 的一个位置 $i$，找到在前 $k$ 个当中离它最近的（最后的）、比它小的位置 $j$（取后缀 $\min$ 后用 <code>lower_bound</code> 找出），用 $k-j$ 次操作将 $j$ 移到位置 $k$，用 $i-k-1$ 次操作将 $i$ 移到位置 $k+1$，再用一次操作交换即可，总操作数为 $(k-j)+(i-k-1)+1=i-j$ 次。这就是一个位置的答案。计算每个位置的答案，取最小值即可。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,ans=<span class="number">1e9</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        a[i]=<span class="built_in">min</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+k+<span class="number">1</span>,a[i])-a<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,i-tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-01-Generation"><a href="#B-01-Generation" class="headerlink" title="B. 01 Generation"></a><a href="https://atcoder.jp/contests/arc138/tasks/arc138_b">B. 01 Generation</a></h2><p>由于只有前面加1反转和后面加0两种操作，所以考虑它们的分界线。</p><p>在前面的部分全部由添加1反转构成，所以一定是 <code>010101...</code> 这种形式，找出最长的满足要求的前缀，这就是第一部分。第一部分的0必须依次插入，可以发现，每插入一个0，第二部分就会受到影响，得到反转，所以当在第二部分中遇到连续的若干个0或连续的1的时候，它们一定（在最优解中）是同一块插入的。</p><p>而两块0、1的交界处必然进行了一次一操作（最优解中）。这样只需要比较操作一的次数（即最长01前缀的长度）和操作二的变化次数即可。如果操作一的次数小于第二部分的变化次数则不可行，反之可行。</p><p>这道题还有另一种思考方式，即倒序思考，将插入操作转化为删除。读者可自行考虑。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(now&lt;n&amp;&amp;a[now]!=a[now+<span class="number">1</span>]) now++;</span><br><span class="line">    <span class="keyword">if</span>(now==n) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;now;i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[i+<span class="number">1</span>]) ans++;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=now) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Rotate-and-Play-Game"><a href="#C-Rotate-and-Play-Game" class="headerlink" title="C. Rotate and Play Game"></a><a href="https://atcoder.jp/contests/arc138/tasks/arc138_c">C. Rotate and Play Game</a></h2><p>题目问最好情况，那么有一个很自然的猜测：最好情况一定可以取得最优解，即拿走大的那一半，留下小的那一半。这就要求我们在翻转之后，在任何一个前缀当中，小的数的个数 $\ge$ 大的数的个数（这样才能保证对方走到大的数之前，我已经把它拿掉了）。设较小的一半数为 $+1$，较大的一半为 $-1$，则相当于要求前缀和中不存在负数。在坐标系中表现出来就是这样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/On30hU.png" alt=""></p><p>（数据 <code>3 4 1 2</code> 的图像）</p><p>那么，分成两半后互换就可以表示为，选一个点，以它为原点开始，再走回自己结束。这样结论就很显然了：选最低的点，以它为起点，坐标为0，那么之后无论怎么走也不会比它更低，满足要求。在此例子中，选择点 $C$ 为起点，这样答案序列为 <code>1 2 3 4</code>，满足要求。</p><p>（不得不说是一道非常巧妙的转化题）</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>],b[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fen=b[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mini=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=fen) a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[mini])</span><br><span class="line">            mini=i;</span><br><span class="line">    cout&lt;&lt;mini&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理证明</title>
      <link href="/2022/04/28/gou-gu-ding-li-zheng-ming/"/>
      <url>/2022/04/28/gou-gu-ding-li-zheng-ming/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/gSEQDf.png" alt=""></p><p>在这个直角三角形中，我们设以 $c$ 为底的大三角形面积为 $S_c$，以 $a,b$ 为底的两个小三角形的面积分别为 $S_a,S_b$。</p><p>显然，$S_c=\frac{ch}{2}=c^2\cdot\frac{h}{2c}$。令 $m=\frac{h}{2c}$，则有 $S_c=mc^2$。</p><p>同理，$S_a=a^2\cdot\frac{h_a}{2a}$（其中 $h_a$ 表示三角形 $BPC$ 中以 $a$ 为底的高）。显然该三角形与大三角形 $ABC$ 相似，所以 $\frac{ha}{h}=\frac{a}{c}$，即 $\frac{h_a}{2a}=\frac{h}{2c}=m$，所以 $S_a=ma^2$。同理 $S_b=mb^2$。</p><p>又因为，$S_c=S_a+S_b$，所以 $mc^2=ma^2+mb^2$，即 $c^2=a^2+b^2$。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包DP学习笔记</title>
      <link href="/2022/01/22/bei-bao-dp-xue-xi-bi-ji/"/>
      <url>/2022/01/22/bei-bao-dp-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><strong>由于01背包太过经典，所以一定要把每一个细节理解透彻！</strong></p><blockquote><p>有 $n$ 个物品和一个容量为 $m$ 的背包，每个物品有体积 $w_i$ 和价值 $v_i$，求用这个背包所能装下的最大价值。</p></blockquote><p>设 $f_{i,j}$ 表示只考虑前 $i$ 个物品，体积不超过 $j$ 的最大价值。如果我们算完了前 $i-1$ 个物品的所有结果，那么第 $i$ 个物品有选和不选两种情况。如果不选，则结果为 $f_{i-1,j}$；如果买，则：由于选了 $i$ 后体积不超过 $j$，那么选 $i$ 之前体积就不能超过 $j-w_i$，而选了 $i$ 之后获得的价值就多了 $v_i$，所以结果为 $f_{i-1,j-w_i}+v_i$。这样，我们就得出了经典的状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-1,j-w_i}+v_i)$。</p><p>接下来，我们再考虑一些细节。对于 $f$ 数组的初始化，我们可以将所有的方案全部赋值为 $0$，因为无论考虑多少物品，无论体积不超过多少，都一定有一种符合要求的方案：一个也不选。这时的价值就是 $0$。</p><p>然后就到了经典的空间优化：我们可以发现 $f_i$ 这一行只与 $f_{i-1}$ 这一行有关，所以我们可以将 $i$ 这一维省略。这样，当我们准备求 $f_j$ 时，我们要求 $f_j$ 和 $f_{j-w_i}$ 都还没有被更新过。因为我们正准备更新 $f_j$，所以第一个要求可以保证，那么怎么保证 $f_{j-w_i}$ 没有被更新过呢？答案就是倒序更新（这样就在更新 $f_j$ 之后才会更新到 $f_{j-w_i}$ 了）。</p><p>接下来还有一个经典的常数优化：因为当 $j&lt;w_i$ 时，转移方程中 $f_{j-w_i}$ 不存在，不需要考虑更新，所以 $j$ 必须大于等于 $w_i$，也就是倒序枚举时 $j$ 只需要从 $m$ 枚举到 $w_i$。</p><p>所以，我们就得到了经典的01背包代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w_i;j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1048">采药</a></p><h3 id="正好填满的01背包"><a href="#正好填满的01背包" class="headerlink" title="正好填满的01背包"></a>正好填满的01背包</h3><p>是一个01背包经典的变形，题意基本与01背包相同，但要求背包必须填满。</p><p>这时，$f$ 数组的意义发生了一点变化：$f_{i,j}$ 表示只考虑前 $i$ 个物品，体积<strong>恰好为</strong> $j$ 的最大价值。</p><p>但是，仔细推理一下，就会发现，状态转移方程和01背包一模一样，空间优化和常数优化也都通用。那不一样的地方在哪里呢？答案是初始化。由于要求体积恰好为 $j$，所以当 $j\ne 0$ 时，不允许一个也不选，所以初始化为负无穷（表示目前没有任何方案满足条件），当 $j=0$ 时，才存在一个也不选的方案，这时才能初始化为 $0$。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><p>有两维费用（如：一个事件既要消耗时间也要消耗金钱，获得一定价值）的01背包。</p><p>将01背包多开两维费用，其他完全相同。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包第一维容量为m，背包第二维容量为t</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w1[i];j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=t;k&gt;=w2[i];k--)</span><br><span class="line">            f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-w1[i]][k-w2[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m][t]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1855">榨取kkksc03</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>又是一个经典模型，也必须要理解透彻。题意与01背包基本相同，但每个物品能选无数遍。</p><p>同样设 $f_{i,j}$ 表示只考虑前 $i$ 种物品，体积不超过 $j$ 的最大价值。这时如何更新呢？如果我们不选这个物品，那么结果为 $f_{i-1,j}$；如果选，那么结果为 $f_{i,j-w_i}+v_i$。这是为什么呢？在01背包中，我们当前要选 $i$，那么选这个 $i$ 之前，只能考虑前 $i-1$ 个物品，所以要从 $f_{i-1,j-w_i}$ 转移，但是在完全背包中，每个物品可以选无数次，所以选这个 $i$ 之前，$i$ 也是可以选的，所以要从 $f_{i,j-w_i}$ 转移而来。这样，我们就得到了最终的转移方程：$f_{i,j}=max(f_{i-1,j},f_{i,j-w_i}+v_i)$。</p><p>同01背包一样，我们也可以省略掉 $i$ 这一维。这时，当我们求 $f_j$ 时，要求变成 $f_j$ 还没有更新，而 $f_{j-w_i}$ 已经更新过了（因为我们要用的是 $f_{i,j-w_i}$ 而不是 $f_{i-1,j-w_i}$）。同样，第一个要求能直接满足，对于第二个要求，我们只需要正序枚举 $j$ 即可。所以，最终转移方程与01背包一样，但 $j$ 的枚举顺序变成了正序。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1616">疯狂的采药</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>题意与01背包基本相同，但每种物品能选 $x_i$ 次。</p><p>一个很容易想到的思路为将一种物品选 $x$ 次转换成 $x$ 个完全相同的物品，再做01背包。</p><p>这样的复杂度显然不够优秀，所以我们考虑优化。我们希望将每个物品选 $x$ 次转换成若干个物品，使得无论想选多少次都能用这若干个物品凑出来。一个较为明显的做法就是二进制分解。例如，我们有一个物品能选20次，我们就将它分解成一个 $1$ 倍物品、一个 $2$ 倍物品、一个 $4$ 倍物品、一个 $8$ 倍物品和一个 $5$ 倍物品（几倍物品指的是体积和价值都为原物品的几倍）。易证，这一定满足我们的条件。这样，我们就将一个物品选 $x$ 次分解成了 $\log(x)$ 个物品，然后再跑一遍01背包即可。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int tmp=1;x[i];tmp*=2) &#123;</span><br><span class="line">        int num=min(tmp,x[i]);</span><br><span class="line">        int wt=w[i]*num,vt=v[i]*num;</span><br><span class="line">        for(int j=m;j&gt;=wt;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-wt]+vt);</span><br><span class="line">        x[i]-=num;</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a></p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>将01背包、完全背包和多重背包缝合在一起的问题。</p><p>思路很简单，无需多讲解，分别考虑即可。形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(枚举物品)  &#123;</span><br><span class="line">    if(01背包)</span><br><span class="line">        01背包代码</span><br><span class="line">    else if(完全背包)</span><br><span class="line">        完全背包代码</span><br><span class="line">    else</span><br><span class="line">        多重背包代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，01背包和多重背包可以共用多重背包的代码，因为01背包可以当成只能取一次的多重背包。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P1833">樱花</a></p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i]==<span class="number">0</span>) &#123;<span class="comment">//完全背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//01背包和多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tmp=<span class="number">1</span>;x[i];tmp*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="built_in">min</span>(tmp,x[i]);</span><br><span class="line">            <span class="keyword">int</span> wt=w[i]*num,vt=v[i]*num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=wt;j--)</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-wt]+vt);</span><br><span class="line">            x[i]-=num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>至此，基本模型已经讲完，其他变种模型以后有空再更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC-229解题报告</title>
      <link href="/2021/11/28/abc-229-jie-ti-bao-gao/"/>
      <url>/2021/11/28/abc-229-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc229">比赛传送门</a></p><p>赛时做出来五道题，涨大分（开心）</p><h1 id="A-First-Grid"><a href="#A-First-Grid" class="headerlink" title="A. First Grid"></a>A. First Grid</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个两行两列的矩阵，每个格子有黑和白两种颜色，至少有两个黑色格子，问黑色格子是否构成一个连通块（四连通）。</p></details><p>显然，如果左上、右下都是白色或右上、左下都是白色，那么不能构成，否则能。</p><h1 id="B-Hard-Calculation"><a href="#B-Hard-Calculation" class="headerlink" title="B. Hard Calculation"></a>B. Hard Calculation</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有两个正整数 $a$ 和 $b$ 做加法，问是否需要进位。</p></details><p>大水题，一位一位地判断即可。</p><h1 id="C-Cheese"><a href="#C-Cheese" class="headerlink" title="C. Cheese"></a>C. Cheese</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 $n$ 种奶酪，第 $i$ 种奶酪每千克能提供 $a_i$ 的美味度，但最多能使用 $b_i$ 千克。你一共最多能使用 $W$ 千克奶酪，问获得的总美味度最大是多少。</p><p>$n\le 3\times 10^5,W\le 3\times 10^8,b_i\le 1000$</p></details><p>这题太坑了，我本来以为是个奇怪的背包，后来发现，既然每个物品的重量都是 $1$，那不就是优先选最美味的奶酪的简单贪心吗？</p><h1 id="D-Longest-X"><a href="#D-Longest-X" class="headerlink" title="D. Longest X"></a>D. Longest X</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个只包含 <code>X</code> 和 <code>.</code> 的字符串 $S$，你每次可以将一个 <code>.</code> 变成 <code>X</code>，问最多 $K$ 次操作后能获得的最长连续 <code>X</code> 字串的长度。</p><p>$|S|\le 2\times 10^5,K\le 2\times 10^5$</p></details><p>如果 $K$ 次操作足以把所有的 <code>.</code> 都变成 <code>X</code>（即点的个数 $\le K$），那么答案一定是 $|S|$。</p><p>如果不能，那么容易发现，答案一定是把 $K$ 次操作全部用完。那么我们就从后往前扫，维护一个数组 $t_i$ 表示从第 $i$ 位开始往后用 $K$ 次操作能到达的最远位置（如果用不完 $K$ 次就到了末尾，那么就是结尾下标）。维护完后就可以直接取长度最大值输出。这里放一下维护的代码实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[i]为0则是点，为1则是X</span></span><br><span class="line"><span class="comment">//now表示当前的i能到达的最远位置</span></span><br><span class="line"><span class="comment">//nowf表示到达最远位置需要花费几次操作</span></span><br><span class="line"><span class="keyword">int</span> now=n,nowf=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    nowf+=(!a[i]);</span><br><span class="line">    <span class="keyword">while</span>(nowf&gt;k)</span><br><span class="line">        nowf-=(!a[now--]);</span><br><span class="line">    t[i]=now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Graph-Destruction"><a href="#E-Graph-Destruction" class="headerlink" title="E. Graph Destruction"></a>E. Graph Destruction</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>给你一个 $n$ 个点、$m$ 条边的无向图，依次删除编号为 $1-n$ 的结点，每次删完后问剩下的连通块个数。</p></details><p>正着删边没法维护，我们考虑反向处理，每次加边。仔细像一下就会知道，每次加一个点，就要加上这个点与已有结点的边，即 $\min(u,v)=i$ 的边。所以我们按照 $\min(u,v)$ 排一个序，每加一个点就加上符合条件的边，然后用并查集维护连通性即可。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元学习笔记</title>
      <link href="/2021/11/26/cheng-fa-ni-yuan-xue-xi-bi-ji/"/>
      <url>/2021/11/26/cheng-fa-ni-yuan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>有很多题的答案可能会很大，这时候通常会让我们输出模一个数的结果。当我们的计算中只用到了加法，可以边加边模；只用到了乘法，可以边乘边模。但如果有除法，就不能边除边模了。这时候就要用到乘法逆元：$a\times inv(b)\times inv(c)\%mod=\frac{a}{b\times c}\%mod$。</p><p>有了乘法逆元，在过程中想怎么模就怎么模，非常方便。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>我们都知道，当模数为质数时，可以用快速幂求 $a^{mod-2}$，否则可以用扩展欧几里得来求。</p><p>在组合数中，我们经常会用到阶乘逆元。当我们算出了 $1-n$ 的阶乘（$\%mod$）后，就可以 $O(n)$算出每一个阶乘逆元：首先用上面两种方法之一算出 $inv(n!)$，我们知道 $inv(n!)=\frac{1}{n!}\%mod$，那么 $inv((n-1)!)=\frac{1}{n!}\times n\%mod=inv(n)\times n\%mod$，以此类推即可倒推出每一个数的阶乘逆元。</p><p>将其扩展为一般形式，就能得到线性求任意 $n$ 个数的逆元：将这 $n$ 个数求出前缀积，记为 $s_1-s_n$，求出 $inv(s_n)$，则 $inv(s_{n-1})=inv(s_n)\times n$，以此类推，求出每一个 $inv(s_i)$，即可得出 $inv(a_i)=inv(s_i)\times s_{i-1}$。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan学习笔记</title>
      <link href="/2021/11/26/tarjan-xue-xi-bi-ji/"/>
      <url>/2021/11/26/tarjan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>众所周知，Tarjan 可以用来求有向图的强连通分量，我们就不扯那些 dfs 生成树，前向边、返祖边之类的东西，直接步入正题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Tarjan 算法本质上是一次 dfs 的过程，我们用 $dfn[u]$ 记录 $u$ 结点是第几次被 dfs 到的，用 $low[u]$ 记录 $u$ 能到达的所有结点中最小的 $dfn$（包括自己）（详细定义：能够回溯到的最早的已经在栈中的结点。设以 $u$ 为根的子树为 $subtree_u$。 定义为以下结点的 $dfn$ 的最小值：$subtree_u$ 中的结点；从 $subtree_u$ 通过<strong>一条</strong>不在搜索树上的边能到达的结点。）。$dfn$ 很好维护，dfs 的过程中记录一下即可，$low$ 的维护也不难，为 $\min\limits_{u\to v}{low[v]}$，dfs 的过程中顺便维护即可。我们还需要一个栈 $s$ 来维护有哪些结点被 dfs 过，且还没计算出属于哪个强连通分量，用一个 $vis$ 数组来记录结点是否在栈中。</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>考虑从一个结点 $u$ 到另一个结点 $v$ 的过程中会发生什么。</p><ol><li>如果 $v$ 在栈中（即那个节点还没操作完），那么 $v$ 一定是 $u$ 的祖先，则用 $dfn[v]$ 更新 $low[u]$。</li><li>如果 $v$ 访问过且不在栈中（即访问完了），那么装作无事发生。</li><li>如果 $v$ 还没被访问过，那么递归访问。</li></ol><p>将 $u$ 能直接到达的所有 $v$ 都算完后，就可以结算强连通分量了。我们发现，如果一个结点算完后 $low[u]=dfn[u]$，则能告诉我们两个信息：</p><ol><li>这个结点能到达自己（出现环了！）</li><li>这个结点是这个环中最先到达的（我们称之为这个强连通分量的根）</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/wF29Sl.png" alt=""></p><p>在这个图中，$2$ 号节点就是强连通分量 ${2,3,4,5,6,7}$ 中的根。</p><p>这时候，我们就可以处理 $u$ 的强连通分量了！循环让结点出栈，直到栈顶元素为 $u$ 自己（因为 $u$ 是强连通分量的根，所以它一定是该强连通分量在栈中最靠前的），这些节点都在同一个以 $u$ 为根的强连通分量里。</p><p>如果一个结点算完后 $low[u]\ne dfn[u]$，则意味着它能到达一个它的祖先，我们暂时先不处理它，也不出栈（还没算完强连通分量怎么能出栈呢），直接返回，到他的那个强连通分量的根的时候再去算强连通分量。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num记录当前一共遍历了几个结点，用于计算新结点的dfn</span></span><br><span class="line"><span class="comment">//col[i]记录第节点i在哪个强连通分量里，root[i]表示i所在强连通分量的根</span></span><br><span class="line"><span class="comment">//colnum记录当前一共算完了几个强连通分量，用来计算新强连通分量的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">push</span>(now),vis[now]=<span class="number">1</span>;</span><br><span class="line">    low[now]=dfn[now]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[e[i].to])</span><br><span class="line">            low[now]=<span class="built_in">min</span>(low[now],<span class="built_in">tarjan</span>(e[i].to));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[e[i].to])</span><br><span class="line">            low[now]=<span class="built_in">min</span>(low[now],dfn[e[i].to]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[now]==low[now]) &#123;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        col[now]=++colnum,root[now]=now;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">top</span>()!=now) &#123;</span><br><span class="line">            col[s.<span class="built_in">top</span>()]=colnum,root[s.<span class="built_in">top</span>()]=now;</span><br><span class="line">            vis[s.<span class="built_in">top</span>()]=<span class="number">0</span>,s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>建议参考阅读<a href="https://blog.csdn.net/qq_34374664/article/details/77488976">这篇文章</a>的手动模拟算法的部分，会有更直观的理解。</p><p>有兴趣看看更严谨的说明，请上 <a href="https://oi-wiki.org/graph/scc/">oi-wiki</a> 观看。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-116-Div.2解题报告</title>
      <link href="/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1606">比赛传送门</a></p><p>做出来五道题。</p><h1 id="A-AB-Balance"><a href="#A-AB-Balance" class="headerlink" title="A. AB Balance"></a>A. AB Balance</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>给你一个只含有 <code>a</code> 和 <code>b</code> 的字符串，问怎样通过修改尽可能少的字符，使得 <code>ab</code> 的数量和 <code>ba</code> 的数量相等。</p></details><p>显然，<code>ab</code> 的数量和 <code>ba</code> 的数量最多差 $1$，而当开头字母和结尾字母相同时，<code>ab</code> 的数量等于 <code>ba</code> 的数量。如果不同，修改开头或结尾字母使它们相同即可。</p><h1 id="B-Update-Files"><a href="#B-Update-Files" class="headerlink" title="B. Update Files"></a>B. Update Files</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 $n$ 个电脑和 $k$ 个数据线，其中一个电脑上有一个文件，每次可以通过数据线将文件从一个电脑传到另一个电脑上，耗时 $1$ 小时。问至少需要几个小时才能让所有电脑都有文件。</p></details><p>设当前有 $x$ 个电脑有文件：若 $x&lt;=k$，则通过 $x$ 条数据线将 $x$ 翻倍；若 $x&gt;k$，则通过 $k$ 条数据线将 $x+=k$。暴力跑第一种情况（$\log(k)$），剩下的情况算一下就行了。</p><h1 id="C-Banknotes"><a href="#C-Banknotes" class="headerlink" title="C. Banknotes"></a>C. Banknotes</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 $n$ 中不同面值的货币，每种货币的面值为 $10^{a_i}$，问至少需要 $x+1$ <strong>个</strong>货币才能组成的价值最小的货币是多少。</p></details><p>暴力贪心模拟。先尽可能多地用面值最小的货币，再用面值第二小的货币，以此类推。具体实现细节比较多，在这里放个代码。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            <span class="keyword">int</span> cur=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(x--)</span><br><span class="line">                cur*=<span class="number">10</span>;</span><br><span class="line">            a[i]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=k;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">                cnt=<span class="built_in">min</span>(cnt,a[i+<span class="number">1</span>]/a[i]<span class="number">-1</span>);</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*cnt;</span><br><span class="line">            k-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="D-Red-Blue-Matrix"><a href="#D-Red-Blue-Matrix" class="headerlink" title="D. Red-Blue Matrix"></a>D. Red-Blue Matrix</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个 $n\times m$ 的矩阵，每个格子有一个正整数，你需要对每一行染成红色或蓝色，使得能够找到竖线，让左边所有红格子都大于所有蓝格子的值，右边相反。输出染色方案以及竖线位置。</p><p>$\sum n\times m\le 10^6$</p></details><p>假设我们已经知道了竖线的位置，如何分配红蓝呢？考虑以行为单位，以每一行的第一个元素为关键字进行从大到小的排序，则我们发现，一定是上面几行为红色，下面几行为蓝色，而这个两条分界线，一横一竖，左上、右上为红，左下、右下为蓝，则必须满足左上的最小值大于左下的最大值，右上的最大值小于右下的最小值。我们可以对矩阵分别求从左上、右下开始的前缀最小值和从左下、右上开始的前缀最大值。枚举横、竖线，然后就可以 $O(1)$ 判断了。总复杂度为 $O(n\times m)$。</p><h1 id="E-Arena"><a href="#E-Arena" class="headerlink" title="E. Arena"></a>E. Arena</h1><p>待更新……</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-755-Div.2解题报告</title>
      <link href="/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1589">比赛传送门</a></p><p>赛时AC三道，补题做出一道。</p><h1 id="A-Mathematical-Addition"><a href="#A-Mathematical-Addition" class="headerlink" title="A. Mathematical Addition"></a>A. Mathematical Addition</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个正整数 $u,v$，求一对合法的 $x,y$ 使得 $\frac{x}{u}+\frac{y}{v}=\frac{x+y}{u+v}$。</p></details><p>解方程。</p><p>$$<br>\begin{array}{c} \frac{vx+uy}{uv}=\frac{x+y}{u+v} \\ (vx+uy)(u+v)=uv(x+y) \\ uvx+u^2y+v^2x+uvy=uvx+uvy \\ u^2y+v^2x=0 \end{array}<br>$$</p><p>则显然一组合法解为 $\begin{cases}x=-u^2\\y=v^2\end{cases}$</p><h1 id="B-Coloring-Rectangles"><a href="#B-Coloring-Rectangles" class="headerlink" title="B. Coloring Rectangles"></a>B. Coloring Rectangles</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>有一个 $n\times m$ 的矩阵，每个方格均为红色。你可以任意多次的横切或纵切（必须贯穿整块），不能出现 $1\times 1$ 的矩阵，问切完后最少需要涂几个蓝色格子才能使得红色格子不相邻。</p><p>example: $2\times 5$</p><p><img data-src="https://espresso.codeforces.com/594fbc0a7f610ebbd39c222d75175364a33218ec.png" alt=""></p></details><div class="tabs" id="solution"><ul class="nav-tabs"><li class="tab active"><a href="#solution-1">Solution 1</a></li><li class="tab"><a href="#solution-2">Solution 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="solution-1"><p>容易发现，把格子割成 $1\times 3$ 是最优的，于是考虑在不对后续操作产生影响的前提下，把它切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/LMrB4f.png" alt=""></p><p>然后再切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/gZylEP.png" alt=""></p><p>最后特判剩下的。注意切的时候要时刻堤防剩下一行或剩下一列的情况，防止出现 $1\times 1$。</p></div><div class="tab-pane" id="solution-2"><p>通过找规律，我们可以发现，答案为 $\lceil\frac{n\times m}{3}\rceil$。</p></div></div></div><h1 id="C-Two-Arrays"><a href="#C-Two-Arrays" class="headerlink" title="C. Two Arrays"></a>C. Two Arrays</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个数组 $a,b$，问能否通过把 $a$ 进行<strong>一次</strong>变换得到 $b$。</p><p>变换方式：在 $a$ 数组中选出若干个数分别 $+1$，然后随意排列顺序。</p></details><p>大水题。$a,b$ 分别排序，看是否每个 $a$ 数组的元素都等于 $b$ 的对应元素或等于 $b$ 的对应元素 $+1$。</p><h1 id="D-Guess-the-Permutation"><a href="#D-Guess-the-Permutation" class="headerlink" title="D. Guess the Permutation"></a>D. Guess the Permutation</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>这是一道交互题。</p><p>有一个初始数组 $a$，满足 $a_i=i$，即 ${1,2,3…}$。现在有 $1&lt;=i&lt;j&lt;=k&lt;=n$，将 $[i,j-1],[j,k]$ 分别翻转。你需要通过不超过 $40$ 次询问得到 $i,j,k$ 的值。</p><p>每一次询问你可以给出 $l,r$，得到 $[l,r]$ 中的逆序对个数。</p><p>$n\le 10^9(\log_2(10^9)\approx 30)$</p></details><ol><li>用一次 $\log$ 找到 $k$：二分 $mid$，询问 $[mid,r]$ 中逆序对个数，如果不为 $0$，则 $k$ 在 $[mid+1,r]$ 中，否则在 $[l,mid]$ 中。</li><li>用两次询问 $[1,k]$ 和 $[1,k-1]$ 来获得 $j$ 的位置：一段降序区间 $[l,r]$ 的逆序对数减去 $[l,r-1]$ 的逆序对数等于 $len-1$，于是 $[1,k]-[1,k-1]=len_{[j,k]}-1$（$j$ 前面的都被抵消了），用 $k-(len-1)$ 即可求出 $j$。</li><li>同理用两次询问 $[1,j-1]$ 和 $[1,j-2]$ 来获得 $i$ 的位置。</li></ol><p>询问次数约为 $\log(n)+4$。</p><p>不开 <code>long long</code> 见祖宗（逆序对个数最多有 $n^2$ 级别）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3383【模板】线性筛-题解</title>
      <link href="/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/"/>
      <url>/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>这道题是线性筛的模板题，所以我们考虑怎么不用线性筛。</p><p>我们都知道有一种筛法叫埃拉托色尼筛，简称埃氏筛，它比线性筛好写，也更好理解，但它过不了这道题，那怎么办呢？我们可以用 $bitset$ 代替 bool 数组来进行优化，这造成的常数优化非常显著，以至于开了 <code>ios::sync_with_stdio(false)</code> 之后能轻松过掉这道题，和线性筛的时间总差距只有 $0.5s$，可以说是非常优秀了。</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,prime[<span class="number">6000000</span>];</span><br><span class="line">bitset&lt;100000000&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">flip</span>();p[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) &#123;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;MAXN;j+=i)</span><br><span class="line">                p[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;prime[x]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-53-Div.2解题报告</title>
      <link href="/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Diverse-Substring"><a href="#A-Diverse-Substring" class="headerlink" title="A. Diverse Substring"></a>A. Diverse Substring</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>定义一个字符串为多变的，当且仅当字符串中没有一个字符的出现次数严格大于 $n/2$。给定一个只由小写字母构成的字符串，问是否能找出一个多变的字串，如果能，任意输出一个。</p><p>$n\le 1000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>只有两个不同字符的字符串时多变的，所以只要给定的字符串中包含至少两个字符就一定可以，输出相邻两个不同字符即可。</p><h1 id="B-Vasya-and-Books"><a href="#B-Vasya-and-Books" class="headerlink" title="B. Vasya and Books"></a>B. Vasya and Books</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一摞书，从上到下依次编号为 $a_1,a_2,a_3…$，现在 Vasya 想把它们分 $n$ 次挪到别的地方，每次他会告诉你他想挪的书的编号，如果这本书还没有被挪动，他将会把这本书以上的书（包括这本书）一块搬走。对于每次挪动，回答他搬了多少本书（没搬输出 0）。</p><p>$n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>开一个桶记录每一本书的位置，记录当前搬到那个位置了，每搬一次就更新一下，减一下即可。</p><h1 id="C-Vasya-and-Robot"><a href="#C-Vasya-and-Robot" class="headerlink" title="C. Vasya and Robot"></a>C. Vasya and Robot</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一个机器人，初始在 $(0,0)$ 点，给你一个长度为 $n$ 的操作序列，每次让机器人向上、下、左、右中的一个方向走一步，你需要修改连续的一段操作序列（这一段中的操作不必全部都修改），使它最终走到 $(x,y)$ 点，问修改的操作序列的最短长度。（不是很严谨，序列长度的详细定义见原题面）</p><p>$n\le 2\times 10^5$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果修改一个长度为 $len$ 的序列可以使它走到终点，那么一定存在一种长度为 $len+1$ 的方案也能走到终点（大不了就加一个空修改），于是我们发现这是可以二分的。二分最终修改的长度 $len$，对于一个长度，我们需要 $O(n)$ 判断是否可行，怎么判断呢？对于每一段长度为 $len$ 的修改，判断不考虑这段修改后机器人会走到哪个位置，再从这个位置开始，判断随便走 $len$ 步能否走到终点（反正允许修改这一段，那想怎么改就怎么改）。</p><p>实现上，我们维护一个走的位置的前缀和和后缀和，就可以 $O(1)$ 判断去除这段修改后机器人会走到那个位置，然后再考虑一些细节问题即可。</p><h1 id="D-Berland-Fair"><a href="#D-Berland-Fair" class="headerlink" title="D. Berland Fair"></a>D. Berland Fair</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p><del>有一个人前来买东西。</del>Polycarp 带了 $T$ 元钱，去逛商铺。有 $n$ 家商铺顺时针排成一圈，编号 $1-n$，第 $i$ 个商铺卖一种价格为 $a_i$ 的商品（数量有无限个）。Polycarp 从一号商铺开始，只要钱足够，就买<strong>一件商品</strong>，否则跳过这家店，直到他一个商品也买不了为止，问他一共会买多少件商品。</p><p>$n\le 2\times 10^5,T\le 10^{18},a_i\le 10^9$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先算出来买一圈要花多少钱，让他买尽可能多的圈。为什么他买不了下一圈了呢？一定是到某一个商铺是他买不起了。现在买不起，以后也不可能买的起，于是直接把这个商铺删掉，不考虑。于是我们暴力跑一圈，看看是哪些商铺买不起，把它们都删掉，删完后再让他转圈，知道所有的商品全都被删完为止。由于每一次至少删掉一个商品，最多删 $n$ 次，每次 $O(n)$，总时间复杂度为 $O(n^2)$。<del>（别问我为什么能过 $2\times 10^5$，我也不知道）</del>（经过同学推导，复杂度为 $O(n\log(n))$）</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-115-Div.2解题报告</title>
      <link href="/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 3道，补题做出来一道</p><h1 id="A-Computer-Game"><a href="#A-Computer-Game" class="headerlink" title="A. Computer Game"></a>A. Computer Game</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有一个 $2\times n$ 的01矩阵，1为障碍，你要从 $(1,1)$ 走到 $(2,n)$，每一步只能向右、上、下、右上、右下走，问能不能走到。</p><p>$t\le 100,n\le 100$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果有一列的两个数都是1，则一定会被堵住，否则一定能到，因为每一列至少有1个0，而我们可以斜着走，所以一定可以从一列走到下一列。</p><h1 id="B-Groups"><a href="#B-Groups" class="headerlink" title="B. Groups"></a>B. Groups</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>有 $n$ 个学生（$n$ 是偶数），每个学生在星期一到星期五会有若干天空闲，问能否将学生平均分成两组，使得每一组能够挑选一天组织社团活动（两组选的日子不能相同）。</p><p>$t\le 10^4,\sum n\le 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于一周只有五天，考虑枚举选的是哪两天，然后判断可不可行。判断就需要一点脑洞了，我的方法是如果两天的空闲学生人数都 $\ge n/2$，且交集能够覆盖所有学生（即每个学生都在这两天中至少有一天空闲），就一定可行。</p><h1 id="C-Delete-Two-Elements"><a href="#C-Delete-Two-Elements" class="headerlink" title="C. Delete Two Elements"></a>C. Delete Two Elements</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个长度为 $n$ 的序列，问有多少种选出两个数的方案使得删除它们后平均值不变。</p><p>$t\le 10^4,\sum n\le 2\times 10^5,a_i\le 10^9$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>要想删除后平均值不变，取出的两个数的平均值必须等于全部的平均值，即两个数的和必须等于全部平均值的两倍，如果数列的平均值 $\times 2$ 不是整数则一定不可行（选出的两个数的和一定是整数），我们如果已经选出了一个数，就可以知道另一个数应该是多少，于是我们可以想到开一个桶，但 $10^9$ 开不了桶怎么办？用 map 即可。</p><h1 id="D-Training-Session"><a href="#D-Training-Session" class="headerlink" title="D. Training Session"></a>D. Training Session</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>教练有 $n$ 道题，每道题有一个算法主题 $x$ 和难度 $y$，你需要选出恰好 $3$ 道题使得 $x$ 互不相同<strong>或</strong> $y$ 互不相同。问有多少种选法。保证没有两个完全相同的题。</p><p>$t\le 50000,\sum n\le 2\times 10^5,x,y\le n$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑用总方案数减去不合法方案数，不合法的方案就是有两个题的 $x$ 相同，有两个题的 $y$ 相同，表现在坐标系上，每一个点的贡献就是横坐标相同的点数$\times$纵坐标相同的点数，可以开两个桶维护。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-114-Div.2解题报告</title>
      <link href="/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 2道题，赛后补题做出来一道（赛时交了4发，赛后交了十几发才过，太残忍了）</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/wuJBv8.png" alt=""></p><p>总体难度比较高，可能题解会比较冗长</p><h1 id="A-Regular-Bracket-Sequences"><a href="#A-Regular-Bracket-Sequences" class="headerlink" title="A. Regular Bracket Sequences"></a>A. Regular Bracket Sequences</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>输入 $n$，输出 $n$ 个互不相同的、合法的、长度为 $2n$ 的括号序列。</p><p>$t\le 50,n\le 50$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution\ 1$"></a>$Solution\ 1$</h2><p>update: 我的解法非常复杂，可以直接看 $Solution\ 2$ CF官方题解的做法（想看看我的憨批做法也行）</p><p>考虑一开始在 $(0,0)$ 点，左括号往右上走，右括号往右下走，则合法的括号序列一定在 $x$ 轴之上。现在考虑最简单的括号序列：<code>(((...(())...)))</code>，即<br>$${+1,+1,…,+1,+1,-1,-1,…,-1,-1}$$<br>展现在坐标系上，就是一个山峰形，那么我们考虑将山峰的顶砍一刀，让它凹进去，变成<br>$${+1,+1,…,+1,-1,+1,-1,…,-1,-1}$$<br>这样就得到了下一种合法序列，再下一种就再把左边的山峰砍一刀（自始至终都不管右边），每次砍左边的山峰，由于最初的山峰高度为 $n$，每砍一刀左边的山峰高度 $-1$，看 $n-1$ 刀的最终高度为 $1$，加上最初的单峰山，就得到了 $n$ 种合法括号序列。</p><p>实现上，把最初的 ${+1,+1,…,+1,+1,-1,-1,…,-1,-1}$ 序列存到数组里，每次交换一对 $+1,-1$ 变成 $-1,+1$，再转换成括号序列输出即可。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution\ 2$"></a>$Solution\ 2$</h2><p>CF官方题解，让我觉得我的解法太复杂了。直接引用英文原版，肯定能看懂。</p><blockquote><p>start with the sequence <code>()()()()...</code>;<br>merge the first $4$ characters into one sequence to get <code>(())()()...</code>;<br>merge the first $6$ characters into one sequence to get <code>((()))()...</code>;<br>and so on.</p></blockquote><h1 id="B-Combinatorics-Homework"><a href="#B-Combinatorics-Homework" class="headerlink" title="B. Combinatorics Homework"></a>B. Combinatorics Homework</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $a$ 个 <code>A</code>、$b$ 个 <code>B</code>、$c$ 个 <code>C</code>，问能否组成“恰好有 $m$ 对相邻两个字符相同”的字符串。</p><p>$t\le 10^4,a,b,c,m\le 10^8$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p><del>显然</del>，只要 $m$ 在“相邻两个字符相同的对数”的最大值和最小值之间，就一定可以。最大值很简单，若干个 A、若干个 B、若干个 C 这样排，$(a-1)+(b-1)+(c-1)$ 就行（别忘了 $\max(0,…)$），问题是最小值怎么求呢？我们可以发现一种典型情况：最大值太大，两个较小值用尽浑身解数拆散，最大值也还有剩余；还有一种情况就是两个较小值不需要用全部的力气拆散，数量最多的字母已经被拆得一对也没有了。针对后者，我们很轻松的就能<del>猜出来</del>一定总能互相拆的一对也不剩，无需多考虑，而针对前者，需要算出来两个数量较少的字母用尽浑身解数能把数量最大的拆得还剩几对。我们发现 <code>ABABAAAA</code> 和 <code>AABAABAA</code> 是一样的，于是我们又可以得到，尽可能多的拆散，就是把较少的两种字母分散开插进最多的字母里，怎么插无所谓，只要它们自己不连在一起就行。这样我们能够得到，针对前一种情况，能组成的对数的最小值为 $max-1-(all-max)$（感性理解一下），将它和 $m$ 比较即可。</p><h1 id="C-Slay-the-Dragon"><a href="#C-Slay-the-Dragon" class="headerlink" title="C. Slay the Dragon"></a>C. Slay the Dragon</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $n$ 个勇士，每个勇士有一定的能力值 $a_i$，每组数据给出一条龙的防御力 $x$ 和攻击力 $y$，你需要派出<strong>一个</strong>能力值 $\ge x$ 的勇士来攻击龙，剩余的勇士防御，防御的勇士能力值之和必须 $\ge y$。你每次可以花费 $1$ 的代价将一个勇士的能力值提高 $1$，对于每组数据，回答最少花费。<strong>注意：每组数据相互独立，每组数据提高的勇士能力值不会保存到下一组数据。</strong></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p><strong>这题竟然卡常！！！</strong>（痛骂 Codeforces）可能需要用 <code>ios::sync_with_stdio(false)</code> 才能过</p><p>很容易想到，每次可以用比龙的防御力小的能力值最大的人去打龙（给他提高一点），或是用第一个比龙的防御力大的人去打龙（不需要提高），然后再按需提高剩下的人（提高谁都没有区别，只需要考虑他们的和就行），取这两种方案中花费较小的一种。然后你就会发现细节巨多，当调了 n 遍终于调出错来时，你就会发现</p><blockquote><p>Time limit exceeded on test 6</p></blockquote><p>加上 <code>ios::sync_with_stdio(false)</code> 或快读可过（如果你是 <code>scanf</code> 党，当我没说）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-746-Div.2解题报告</title>
      <link href="/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>VP做出来一道，补题又做出来3道。</p><h1 id="A-Gamer-Hemose"><a href="#A-Gamer-Hemose" class="headerlink" title="A. Gamer Hemose"></a>A. Gamer Hemose</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有 $n$ 个武器，要打一个体力为 $H$ 的敌人，第 $i$ 个武器可以对敌人造成 $a_i$ 的伤害，每把武器不能连续使用两次，问至少需要多少次才能打败敌人。</p><p>$t\le 10^5,\sum n\le 2\times 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>（读错题意调了半天）</p><p>肯定是最厉害的武器和次厉害的武器轮番上阵，把它们看作一组，首先算要用多少组，剩余的再单独处理。</p><p>时间复杂度 $O(1)$。</p><h1 id="B-Hemose-Shopping"><a href="#B-Hemose-Shopping" class="headerlink" title="B. Hemose Shopping"></a>B. Hemose Shopping</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>你有一个数组，每次操作只能将距离 $\ge x$ 的两个数交换，问能否排好序。</p><p>$t\le 10^5,\sum n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于每次距离只能 $\ge x$，中间可能有一段区间是无论如何也动不了的，为 $[n-m+1,m]$。假设不用考虑这段区间，则剩下的分成左右两边，每次只能交换左右两边的数，是否能排好序呢？能。我们肯定能交换左右两边的数，所以考虑如何交换同一边的数（假设是 $a_x,a_y$），我们需要一个在另一边的辅助变量 $t$，就可以用我们刚学编程是学的用辅助变量来交换变量的方法交换，而 $t$ 的值也不会改变。</p><p>如此，两边的就不用管了，反正总能排好序。接下来考虑中间的部分，因为完全动不了，我们就要求它们已经排好序了。这样就结束了？不。（我就被这个坑了）它们还需要在排好序的数组里处于正确的位置，即，对于排好序的数组 $b$，$\forall i\in[n-m+1,m],a_i=b_i$。</p><h1 id="C-Bakry-and-Partitioning"><a href="#C-Bakry-and-Partitioning" class="headerlink" title="C. Bakry and Partitioning"></a>C. Bakry and Partitioning</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一棵有点权的树，问是否能割断至少 $1$ 条、至多 $k-1$ 条边，将树分成若干个连通块，使得每个连通块中点权的异或和相等。</p><p>$t\le 5\times 10^4,\sum n\le 2\times 10^5$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果异或和是 $0$，随便割一条边即可，因为两边的异或和相等，异或起来的结果才能等于 $0$。</p><p>如果疑惑和不是 $0$，而是 $x$，我们就需要将树分成三个异或和都为 $x$ 的连通块。为什么不是五个、七个？因为可以合并三个异或和都为 $x$ 的连通块得到一个异或和为 $x$ 的连通块。具体实现中跑一边 dfs 即可，跑的过程中一发现出现异或和为 $x$ 的连通块，马上把它分割出去，统计分割了多少次，如果多于两次就成立，否则不成立。</p><h1 id="D-Hemose-in-ICPC"><a href="#D-Hemose-in-ICPC" class="headerlink" title="D. Hemose in ICPC ?"></a>D. Hemose in ICPC ?</h1><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p><strong>这是一道交互题。</strong> 给你一棵有边权的树，但你不知道边权是多少，每次你可以询问一个点集，会得到这个点集中距离最远的两个点的距离（即直径）。距离定义为路径中所有边权的 $\gcd$。你需要在 $12$ 次询问以内输出整棵树直径的两个端点。</p><p>$n\le 10^3$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>有一个很重要的结论，$a\ge gcd(a,b)$，这告诉我们树的“直径”一定只有一条边，所以问题转化为我们要求得最长的边的两个端点。我们先花费一次询问得知整棵树的直径（即最长的边），设它为 $x$。</p><p>假设我们以 $1$ 号结点为根，那么每一条边唯一对应一个点，所以我们用一个点来代表这个点与它父亲结点之间的边。考虑我们先对所有点按照 dfs 序排序，然后二分选相邻的点集（一定要加上前面的），这样它的直径一定是这个点集中最长的边，如果它是 $x$，那么递归再这段，否则递归后面的段（也加上前面的）。</p><p>为什么选的点要相邻呢？以下图为例，如果我们问 ${1,3,4}$，它返回 $10$，我们也不知道是否真的有一条边的权值等于 $10$，这对我们获知答案没有什么意义。</p><p><img data-src="https://i.loli.net/2021/10/09/ahmk2zd1EYy5Rrb.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-745-Div.2解题报告</title>
      <link href="/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>没打比赛，赛后做出3道。<br>这场比赛题目质量很高，非常巧妙。</p><h1 id="A-CQXYM-Count-Permutations"><a href="#A-CQXYM-Count-Permutations" class="headerlink" title="A. CQXYM Count Permutations"></a>A. CQXYM Count Permutations</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>求有多少 $2n$ 的排列满足存在超过 $n$ 个 $i$ 使得 $p_i&lt;p_{i+1}$，答案对 $10^9+7$ 取模。</p><p>$\sum n\le 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>这题就非常巧妙了，当我们使劲想想不出来时，正难则反，考虑有多少 $2n$ 的排列满足存在超过 $n$ 个 $i$ 使得 $p_i&gt;p_{i+1}$，这时候我们就会发现：这不是一样吗？没错，答案就是 $\frac{(2n)!}{2}$。</p><h1 id="B-Diameter-of-Graph"><a href="#B-Diameter-of-Graph" class="headerlink" title="B. Diameter of Graph"></a>B. Diameter of Graph</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>每次给定 $n,m,k$ 问能不能构造一个 $n$ 个点，$m$ 条边的简单无向图使得图的直径小于 $k-1$。</p><p>一张图的直径定义为最短路最长的两个点的最短路长度。</p><p>$t\le 10^5,n,m,k\le 10^9$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>始终没有明白为什么要“小于 $k-1$”，直接 <code>k-=2</code> 后变成 $\le k$。</p><p>考虑这道题可以转化为构造一个 $n$ 个点，$m$ 条边的直径尽可能小的图。</p><p>首先判断能否连通，即 $m&lt;n-1$，然后判断是否必须有重边，即 $m&gt;\frac{n(n-1)}{2}$，如果出现这两种情况则为不合法，直接排除。而且，如果 $k&lt;1$，也直接排除，因为不可能存在两个点的距离 $&lt;1$。</p><p>然后考虑能否构造出直径为 $1$ 的图。我们发现只有完全图的直径为 $1$，因为任意两个点都可以直径过 $1$ 条边到达。所以，如果 $k=1$，只有完全图才成立，否则不成立。接着在考虑能否构造出直径为 $2$ 的图。我们会发现只要图连通，就一定能构造出来直径为 $2$ 的图，因为菊花图的直径为 $2$，而在菊花图上加边不会让直径变大，所以只要 $k&gt;1$ 就一定能构造出来。</p><h1 id="C-Portal"><a href="#C-Portal" class="headerlink" title="C. Portal"></a>C. Portal</h1><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给定一张 $n\times m$ 的矩阵，每个格子有空和黑曜石两种状态，你可以花费一步操作将空格子变成黑曜石或将黑曜石变成空格子。一个子矩阵可以形成传送门需要具备以下条件：</p><ol><li>高度 $\ge 5$，宽度 $\ge 4$。注意，传送门不能横过来看，宽就是宽，高就是高。</li><li>中间部分必须全是空格子。</li><li>四周边框必须全是黑曜石。</li><li>四角不限。</li></ol><p>问至少需要几次操作才能搭建一个传送门。</p><p>$\sum n\le 400,\sum m\le 400$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>这道题我从9月30号读题一直到10月8号才做出来，历尽了千辛万苦。</p><p>记输入的矩阵为 $a$，用 $0$ 表示空格，$1$ 表示黑曜石。</p><p>首先预处理出每一行的前缀和，以便我们 $O(1)$ 查询一段横向区间里有多少块黑曜石，我们用 $s[i][j]$ 表示。</p><p>然后，枚举合法的左右边界（$r-l\ge 3$），我们记 $len=r-l-1$ 表示中间部分的宽度，对于每一个左右边界，记 $t[i]$ 表示前 $i$ 行全变成 $100…001$ 的格式需要花费的步数，本质上是竖向的前缀和：$t[i]=t[i-1]+(s[i][r-1]-s[i][l])+(2-a[i][l]-a[i][r])$。然后我们考虑如何 $O(1)$ 计算搭建一段以 $u$ 为上边界，$d$ 为下边界的传送门的步数：首先让中间和左右边框合法（$t[d-1]-t[u]$），再让上边框合法（$len-(s[u][r-1]-s[u][l])$），同理再让下边框合法（$len-(s[d][r-1]-s[u][l])$）。加起来，则为：</p><p>$t[d-1]-t[u]+(len-(s[d][r-1]-s[d][l]))+(len-(s[u][r-1]-s[u][l]))$</p><p>将与 $u,d$ 有关的项分开，方便处理：</p><p>$2len+(t[d-1]-s[d][r-1]+s[d][l])-(t[u]+s[u][r-1]-s[u][l])$</p><p>我们记 $f[i]=t[i-1]-s[i][r-1]+s[i][l],g[i]=t[i]+s[i][r-1]-s[i][l]$，则上式可简化为 $2len+f[d]-g[u]$。</p><p>现在考虑从上到下扫下边界，对于每一个下边界，我们要使步数尽可能小，即让 $2len+f[d]-g[u]$ 尽可能小，就要让 $g[u]$ 尽可能大，于是我们从上到下扫的时候，记录以下当前扫过的 $g[u]$ 的最大值 $maxn[i]=\max(maxn[i-1],g[i])$，那么对于每一个下边界 $d$，最小步数就为 $2len+f[d]-maxn[d-4]$，整个算法的时间复杂度就可以做到 $O(m^2n)$。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OI术语中英对照表</title>
      <link href="/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/"/>
      <url>/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="mathcal-A"><a href="#mathcal-A" class="headerlink" title="$\mathcal{A}$"></a>$\mathcal{A}$</h1><ul><li>$assume$ 设，令，假设</li><li>$axis$ 坐标轴</li></ul><h1 id="mathcal-B"><a href="#mathcal-B" class="headerlink" title="$\mathcal{B}$"></a>$\mathcal{B}$</h1><ul><li>$block$ 方块，格</li></ul><h1 id="mathcal-C"><a href="#mathcal-C" class="headerlink" title="$\mathcal{C}$"></a>$\mathcal{C}$</h1><ul><li>$column$ 列</li><li>$condition$ 条件</li><li>$corner$ 角，角落</li><li>$calculate$ 计算</li><li>$complexity$ 复杂度</li><li>$contributed$ 贡献</li><li>$communication$ 通信</li><li>$challenge$ 挑战</li><li>$capacity$ 容量</li><li>$coordinate$ 坐标</li></ul><h1 id="mathcal-D"><a href="#mathcal-D" class="headerlink" title="$\mathcal{D}$"></a>$\mathcal{D}$</h1><ul><li>$diameter$ 直径</li><li>$directed$ 有向的</li></ul><h1 id="mathcal-E"><a href="#mathcal-E" class="headerlink" title="$\mathcal{E}$"></a>$\mathcal{E}$</h1><ul><li>$exceed$ 超过</li><li>$enumerate$ 枚举</li></ul><h1 id="mathcal-F"><a href="#mathcal-F" class="headerlink" title="$\mathcal{F}$"></a>$\mathcal{F}$</h1><ul><li>$figure$ 插图</li><li>$flow$ 流量</li></ul><h1 id="mathcal-G"><a href="#mathcal-G" class="headerlink" title="$\mathcal{G}$"></a>$\mathcal{G}$</h1><ul><li>$guarantee$ 保证</li></ul><h1 id="mathcal-H"><a href="#mathcal-H" class="headerlink" title="$\mathcal{H}$"></a>$\mathcal{H}$</h1><h1 id="mathcal-I"><a href="#mathcal-I" class="headerlink" title="$\mathcal{I}$"></a>$\mathcal{I}$</h1><ul><li>$intersection$ 交集，交点</li></ul><h1 id="mathcal-J"><a href="#mathcal-J" class="headerlink" title="$\mathcal{J}$"></a>$\mathcal{J}$</h1><h1 id="mathcal-K"><a href="#mathcal-K" class="headerlink" title="$\mathcal{K}$"></a>$\mathcal{K}$</h1><h1 id="mathcal-L"><a href="#mathcal-L" class="headerlink" title="$\mathcal{L}$"></a>$\mathcal{L}$</h1><h1 id="mathcal-M"><a href="#mathcal-M" class="headerlink" title="$\mathcal{M}$"></a>$\mathcal{M}$</h1><ul><li>$minimum$ 最少的</li><li>$maximum$ 最多的</li><li>$matrix$ 矩阵</li><li>$multiedges$ 重边</li></ul><h1 id="mathcal-N"><a href="#mathcal-N" class="headerlink" title="$\mathcal{N}$"></a>$\mathcal{N}$</h1><h1 id="mathcal-O"><a href="#mathcal-O" class="headerlink" title="$\mathcal{O}$"></a>$\mathcal{O}$</h1><ul><li>$otherwise$ 否则</li><li>$overlap$ 重叠</li></ul><h1 id="mathcal-P"><a href="#mathcal-P" class="headerlink" title="$\mathcal{P}$"></a>$\mathcal{P}$</h1><ul><li>$precalculate$ 预处理</li><li>$prefix$ 前缀</li><li>$permutation$ 排列</li><li>$preceding$ 前面的</li><li>$positive$ 正的</li></ul><h1 id="mathcal-Q"><a href="#mathcal-Q" class="headerlink" title="$\mathcal{Q}$"></a>$\mathcal{Q}$</h1><h1 id="mathcal-R"><a href="#mathcal-R" class="headerlink" title="$\mathcal{R}$"></a>$\mathcal{R}$</h1><ul><li>$rectangle$ 长方形，矩阵</li><li>$row$ 行</li><li>$resources$ 资源</li></ul><h1 id="mathcal-S"><a href="#mathcal-S" class="headerlink" title="$\mathcal{S}$"></a>$\mathcal{S}$</h1><ul><li>$satisfy$ 满足（条件）</li><li>$suffix$ 后缀</li><li>$submatrix$ 子矩阵</li></ul><h1 id="mathcal-T"><a href="#mathcal-T" class="headerlink" title="$\mathcal{T}$"></a>$\mathcal{T}$</h1><ul><li>$therefore$ 因此</li><li>$tutorial$ 题解</li></ul><h1 id="mathcal-U"><a href="#mathcal-U" class="headerlink" title="$\mathcal{U}$"></a>$\mathcal{U}$</h1><ul><li>$utilization$ 利用</li><li>$undirected$ 无向的</li></ul><h1 id="mathcal-V"><a href="#mathcal-V" class="headerlink" title="$\mathcal{V}$"></a>$\mathcal{V}$</h1><h1 id="mathcal-W"><a href="#mathcal-W" class="headerlink" title="$\mathcal{W}$"></a>$\mathcal{W}$</h1><h1 id="mathcal-X"><a href="#mathcal-X" class="headerlink" title="$\mathcal{X}$"></a>$\mathcal{X}$</h1><h1 id="mathcal-Y"><a href="#mathcal-Y" class="headerlink" title="$\mathcal{Y}$"></a>$\mathcal{Y}$</h1><h1 id="mathcal-Z"><a href="#mathcal-Z" class="headerlink" title="$\mathcal{Z}$"></a>$\mathcal{Z}$</h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFR-744-Div.3解题报告</title>
      <link href="/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/"/>
      <url>/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时 AC 2道题，掉大分（哭）</p><h1 id="A-Casimir’s-String-Solitaire"><a href="#A-Casimir’s-String-Solitaire" class="headerlink" title="A. Casimir’s String Solitaire"></a>A. Casimir’s String Solitaire</h1><p><a href="https://codeforces.com/contest/1579/problem/A">题目传送门</a></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个仅含 A,B,C 的字符串，每次可以删掉一个 A 和一个 B，或一个 B 和一个 C，位置、顺序不限，问能不能删完。</p><p>$t\le 1000,len\le 50$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>大水题，只需要判断 A 的数量加 C 的数量是否等于 B 的数量。<del>一开始脑抽还判断 A 的数量是否等于 C 的数量</del></p><h1 id="B-Shifting-Sort"><a href="#B-Shifting-Sort" class="headerlink" title="B. Shifting Sort"></a>B. Shifting Sort</h1><p><a href="https://codeforces.com/contest/1579/problem/B">题目传送门</a></p><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>定义对一段区间的 <code>Cyclically Shift</code>（以下简称<code>Shift</code>） 操作为：</p><ol><li>指定一个数 $x(x\le len)$ 为操作的周期。</li><li>每次将区间左移一位，移出去的那一位放到最右边，重复 $x$ 次。</li></ol><p>给你一个数列 $a$，问如何用不超过 $n$ 次 <code>Shift</code> 操作将 $a$ 排好序（不要求使用次数最少，只要不超过 $n$ 就行）。</p><p>$1\le t \le 1000,2\le n\le 50$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>注意只要求不超过 $n$ 次，也就意味着我们只需要每一次把一个数排好序就行了。我们可以每次挑选最大的数，通过一次 <code>Shift</code> 操作（$x=1$）将它移到最右边的位置，如果已经在该在的位置就不操作，每次都能将一个数归位，重复 $n$ 次即可。</p><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原序列</span><br><span class="line">2 5 1 4 3</span><br><span class="line">将5归位</span><br><span class="line">2 1 4 3 5</span><br><span class="line">将4归位</span><br><span class="line">2 1 3 4 5</span><br><span class="line">将2归位</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>由于 $n$ 很小，暴力找最大值就可以。</p><h1 id="C-Ticks"><a href="#C-Ticks" class="headerlink" title="C. Ticks"></a>C. Ticks</h1><p><a href="https://codeforces.com/contest/1579/problem/C">题目传送门</a></p><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个 $n\times m$ 的网格图，每个格子有 <code>*</code> 和 <code>.</code> 两种状态，<code>*</code> 表示填，<code>.</code> 表示不填，问能不能通过若干个大小超过 $k$ 的“V字形”表示出这个图形（V 的两条边必须一样长，机房的两位大佬就是没判断这个而 FST 了）。</p><p>“V字形”大小的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*...*</span><br><span class="line">.*.*.</span><br><span class="line">..*..</span><br></pre></td></tr></table></figure><p>的大小为 $2$。</p><p>$1\le k\le n\le 10,1\le m\le 19$</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>注意到 $n$ 和 $m$ 的范围很小，完全可以通过暴力求解。对于每一个格子，尽可能多的往上延伸，如果超过 $k$ 就把覆盖格子的标记一下，最后判断是否都被覆盖完。</p><h1 id="D-Productive-Meeting"><a href="#D-Productive-Meeting" class="headerlink" title="D. Productive Meeting"></a>D. Productive Meeting</h1><p><a href="https://codeforces.com/contest/1579/problem/D">题目传送门</a></p><h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>在一场见面会中有 $n$ 个人，会议开始后他们会两两交谈，每个人有一定的耐心值 $a_i$，第 $i$ 个人在交谈 $a_i$ 次后会离开会议，两个人可以交谈多次，请找出一种方案使得总交谈次数尽可能多。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5,\sum a_i\le 2\times 10^5$</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于 $\sum a_i$ 不大，我们可以依次考虑每一次交谈，容易想到每次让耐心值最大的两个人交谈是最优方案。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现 1"></a>实现 1</h3><p>先排好序，每次让剩余耐心值最大的两个人交谈，耐心值–，在考虑维护序列单调性，可以通过一通 <code>lower_bound</code> 和 <code>upper_bound</code> 以及 <code>swap</code> 来实现，时间复杂度 $O((\sum a_i)\log(n))$。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现 2"></a>实现 2</h3><p>使用 <code>lower_bound</code> 和 <code>upper_bound</code> 来维护需要考虑一大堆细节（我调错调了一下午加一晚上），不如用堆来维护。每次从堆里拿出两个耐心值最大的人，耐心值–，如果还有剩余耐心值，就把他们再扔回堆里，用 STL 的优先队列实现非常简洁，时间复杂度也是 $O((\sum a_i)\log(n))$。</p><h1 id="E1-Permutation-Minimization-by-Deque"><a href="#E1-Permutation-Minimization-by-Deque" class="headerlink" title="E1. Permutation Minimization by Deque"></a>E1. Permutation Minimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E1">题目传送门</a></p><p>在 Codeforces 中首次被 hack 祭。</p><h2 id="Problem-4"><a href="#Problem-4" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个 $1-n$ 的排列，你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的数的字典序最小。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5$</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution\ 1$"></a>$Solution\ 1$</h2><p>由于要让字典序最小，肯定最小的值放在最前面，最小值之前的数的放法先不管，放完最小值之前的数之后在把最小值放在最前面，最小值后面的数就只能从后面挨个放了。而最小值之前的数我们可以递归处理。</p><p>具体实现中我们需要用 ST 表维护区间最小值，再用分治递归的方法实现。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution\ 2$"></a>$Solution\ 2$</h2><p>从通过人数上看，这道题的简单程度可是仅次于 A 题，怎么会这么复杂呢？</p><p>考虑用贪心的思想，先扔进去第一个数，以后对于每一个数，如果它比队首小，就扔到队首（这样可以让结果的字典序尽可能小），否则就扔到队尾（如果还扔到队首字典序就大了）。就是这么简单。</p><h1 id="E2-Array-Optimization-by-Deque"><a href="#E2-Array-Optimization-by-Deque" class="headerlink" title="E2. Array Optimization by Deque"></a>E2. Array Optimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E2">题目传送门</a></p><h2 id="Problem-5"><a href="#Problem-5" class="headerlink" title="$Problem$"></a>$Problem$</h2><p>给你一个长度为 $n$ 的数列（注意不是排列），你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的<a href="https://baike.baidu.com/item/逆序对/11035554">逆序对</a>尽可能少。</p><p>$1\le t\le 1000,\sum n\le 2\times 10^5,-10^9\le a_i\le 10^9$</p><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>同样是贪心，对于每个数，如果放在队首，则贡献的逆序对数为前面比它小的数的个数，反之则为比它大的数的个数，这个数放在队首还是队尾对以后的方法不会产生干扰，所以只需要判断它前面是比它大的多还是比它小的多，这可以用树状数组或权值线段树维护。由于 $a_i$ 的值跨度过大，需要先进行离散化处理。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-latex折腾记</title>
      <link href="/2021/09/09/hexo-latex-zhe-teng-ji/"/>
      <url>/2021/09/09/hexo-latex-zhe-teng-ji/</url>
      
        <content type="html"><![CDATA[<p>hexo的LaTeX可算把我给折腾死了。。。</p><p>问题：多行公式无法显示（hexo-renderer-marked，mathjax）</p><p>看到网上说是因为渲染引擎把<code>\\</code>渲染成<code>\</code>，然后才交给mathjax渲染公式</p><p>都说把hexo-renderer-marked换成hexo-renderer-kramed，然后再node_modules/kramed/lib/rules/inline.js里修改escape项，照做了，确实解决了问题，但是却出现了新的问题：复杂公式显示错乱，遂放弃。</p><p>又看到在node_modules/marked/lib/marked.js里修改escape项，失败。</p><p>后来发现那些文章都比较老，于是把hexo-renderer-marked换成了2018年的1.0.0版本，再修改escape，终于成功。</p><p>最终解决步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-marked@1.0.0</span><br></pre></td></tr></table></figure><p>编辑node_modules/marked/lib/marked.js</p><p>第539行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/,</span><br><span class="line">改成</span><br><span class="line">escape: /^\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/,</span><br></pre></td></tr></table></figure><p>第564行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline._escapes = /\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/g;</span><br><span class="line">改成</span><br><span class="line">inline._escapes = /\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/g;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2285打鼹鼠 题解</title>
      <link href="/2021/09/05/p2285-da-yan-shu-ti-jie/"/>
      <url>/2021/09/05/p2285-da-yan-shu-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>基础的DP各位大佬已经讲得很明白了，本文主要讲一讲优化</p><p>DP状态很<del>容易</del>想到：$f[i]$ 表示打完第 $i$ 只鼹鼠能获得的最多数量。</p><p>转移：$f[i]=\min\limits_{j&lt;i,\ t[i]-t[j]&gt;=dis(i,j)}f[j]+1$ ，即对于每一个打完第 $j$ 个能来得及走到第 $i$ 个的 $j$，算最大的 $f[j]+1$。</p><h3 id="重点来了！！"><a href="#重点来了！！" class="headerlink" title="重点来了！！"></a>重点来了！！</h3><p><strong>优化</strong></p><p>我们发现，如果时间差大于 $2\times n$，无论在<del>天涯海角</del>哪里都能走到，又因为输入的时间是升序排列，我们只需要在转移时维护 $g[i]$ 表示 $\max\limits_{j&lt;=i}f[i]$，这样在转移 $f[i]$ 时就可以先用 $start=upper \_ bound-1$ 找出最后一个“时间差大于 $2\times n$” 的鼹鼠，他前面的鼹鼠无论多远都能到达，就可以直接用 $g[start]$ 来代替，枚举时就只需要从 $start$ 开始枚举了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+<span class="number">1</span>,t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续优化</strong></p><p>我们发现，由于时间是递增的，所以 $i$ 的 $start$ 一定不会小于 $i-1$ 的 $start$，所以我们用 $start[i]$ 记录第 $i$ 只鼹鼠的 $start$，那么 $upper \_ bound$ 时就只需要从 $start[i-1]$ 开始查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        start[i]=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+start[i<span class="number">-1</span>],t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start[i]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start[i]);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续继续优化</strong></p><p>我们甚至可以直接不用 $upper \_ bound$ 和 $start$ 数组了（没错），开一个变量 $start$，维护当前的 $start$，转移之前用一个</p><p><code>for(;t[i]-t[start+1]&gt;=2*n;start++);</code></p><p>来更新 $start$，可以发现，整个程序运行下来，$start$ 最多只会更新 $n$次，所以复杂度可忽略。</p><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;t[i]-t[start+<span class="number">1</span>]&gt;=<span class="number">2</span>*n;start++);</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不开O2可达48ms，可见优化非常显著。</p><p><strong>请勿抄袭，如果一定要抄，请理解明白后再抄</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4363一双木棋 题解</title>
      <link href="/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/"/>
      <url>/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/</url>
      
        <content type="html"><![CDATA[<p><del>本篇题解献给和我一样看不懂其他题解的状压DP小白</del></p><p>相信大家都是看了其他题解看不懂才看到这篇题解的（莫名自信），所以什么<strong>每行棋子数递减</strong>啊，<strong>每行的棋子都排在左边</strong>啊，就不用我多说了，直接切入正题（大段文字多，请耐心观看）。</p><h2 id="轮廓线DP"><a href="#轮廓线DP" class="headerlink" title="轮廓线DP"></a>轮廓线DP</h2><p>没见过不用慌，我也没见过（雾</p><p>轮廓线，就是把矩阵从右上角到左下角沿着有棋子和没棋子的分界线描一下，往下走就用1表示，往左走就用0表示。这样我们就得到了一个01串，即一个二进制数，这就是我们的DP状态。</p><p>例如（图丑勿喷）</p><p><img data-src="https://i.loli.net/2021/08/14/6RlDkBPy2JnVS7W.png" alt=""></p><p>这种情况下轮廓线状态为左左下左下下左左下，即$001011001_{(2)}=89$</p><p>我们设$f[s]$（$s$就是轮廓线状态）表示从轮廓线表示的局面一直下到最终下满的过程中“先手-后手”最大是多少。我们可以发现，只根据s就可以知道已经下了那些棋，但不能知道具体是黑棋还是白棋，然而根据$f$的定义，$f[s]$的值和前面怎么下的没有关系，它只管之后怎么下，所以我们只用一维轮廓线就OK，不需要记录之前怎么下的。</p><p>那么状态有了，怎么转移呢？以上图为例，即将要白棋（后手）下棋，后手肯定希望他下的一步棋能使得从现在开始（以前的我们不管）先手-后手得分尽可能小（如果是负数那他更开心了），所以$f[s]=\min\limits_{所有再下一步棋可能得到的方案s’}f[s’]-b[x][y]$（$x,y$就是即将下的那一步棋的坐标）。</p><p>同理，如果即将先手下，就把上面的式子里min改成max（因为他希望下这步棋能使得他的得分-对方的得分最大），$-b[x][y]$改成$+a[x][y]$。</p><p>这样我们就可以用记忆化搜索很容易地跑出来了。</p><p>哎等等，我们还有两个问题没解决，观察上面的式子，我们还不知道怎么枚举“所有再下一步棋可能得到的方案$s’$”，也不知道怎么根据轮廓线的变化找出具体坐标x和y啊？</p><p>我们一个一个解决，先看第一个问题。还是以上图为例，白棋（后手）可以下在$(1,4),(2,3),(4,1)$三个位置，但转移的时候电脑只知道当前的轮廓线，所以我们需要找这三个点的共同特点，那就是处在轮廓线左和下的拐角处，也就是轮廓线中先出现一个0，再出现一个1。现在我们知道了轮廓线上放棋子的位置，怎么得出放棋子后的轮廓线状态呢？我们还是以上图为例，如果我们放在$(2,3)$处，进行一个对比。</p><p>原：$001011001_{(2)}$</p><p>新：$001101001_{(2)}$</p><p><img data-src="https://i.loli.net/2021/08/15/YyPqDZpzrfl43kO.png" alt=""></p><p>我们发现只有第四位和第五位变了，而原先的第四位和第五位就是我们之前说的先出现一个0，再出现一个1，那么转移就是把0变成1，把1变成0。</p><p>具体来说，就是当我们枚举到一个$i$，使得原状态的（从低位数）第$i$位是1，第$i+1$位是0，那么就把状态异或上$3&lt;&lt;i$（可以对照例子手推一下）。</p><p>开始讨论第二个问题，我们知道该在轮廓线的哪一位上下棋，怎么知道那步棋的具体坐标呢？这个问题比较容易解决，只需要在枚举$i$时维护当前看到哪个坐标即可（详见代码）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>],b[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1048580</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1048580</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">bool</span> now)</span><span class="comment">//s是轮廓线状态，now记录是先手还是后手（虽然可以根据s算出来，但这样比较方便）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[s])<span class="comment">//记忆化搜索标配</span></span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;(n+m))-(<span class="number">1</span>&lt;&lt;m))<span class="comment">//已经填满棋子（即n个下加m个左）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num0=<span class="number">0</span>,num1=<span class="number">0</span>;<span class="comment">//维护坐标（已经出现多少个左/多少个下</span></span><br><span class="line">    <span class="keyword">if</span>(now)<span class="comment">//先手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">-2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;<span class="number">0</span>&amp;&amp;(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>)))==<span class="number">0</span>)</span><br><span class="line">                f[s]=<span class="built_in">max</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">0</span>)+a[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//后手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&amp;&amp;!(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>))))</span><br><span class="line">                f[s]=<span class="built_in">min</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">1</span>)-b[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;b[i][j];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//(1&lt;&lt;n)-1是初始状态，即m个左加n个下（一步棋也没下）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能的高精度模板</title>
      <link href="/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/"/>
      <url>/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL=<span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,z[MAXL];</span><br><span class="line">    <span class="built_in">Int</span>()&#123; <span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(z)); len=<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean_pre_zero</span><span class="params">()</span></span>&#123; <span class="keyword">while</span>(len&gt;<span class="number">1</span> &amp;&amp; !z[len<span class="number">-1</span>]) len--; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="keyword">char</span> s[MAXL]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); *<span class="keyword">this</span>=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,z[i]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">    &#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            z[i]=num[len-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[MAXL];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">int</span> num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">char</span> *num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=<span class="built_in">max</span>(len,b.len)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]+b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int &amp;b)<span class="comment">// 必须保证结果为正数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]-b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            <span class="keyword">if</span>(res.z[i]&lt;<span class="number">0</span>)</span><br><span class="line">                res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span><span class="number">-1</span>,</span><br><span class="line">                res.z[i]%=<span class="number">10</span>,res.z[i]+=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len+b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">                res.z[i+j]+=z[i]*b.z[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,</span><br><span class="line">            res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> / (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res,cur;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur*<span class="number">10</span>+z[i];</span><br><span class="line">            <span class="keyword">while</span>(cur&gt;=b)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur-b;</span><br><span class="line">                res.z[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=b.len) <span class="keyword">return</span> len&lt;b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(z[i]!=b.z[i])</span><br><span class="line">                <span class="keyword">return</span> z[i]&lt;b.z[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> b&lt;*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span>&gt;b) &amp;&amp; !(*<span class="keyword">this</span>&lt;b); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&gt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&lt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(b==*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得学习笔记</title>
      <link href="/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/"/>
      <url>/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>温馨提示：本文推式子比较多，建议跟着文章自己推一推。</p><h2 id="扩展欧几里得是什么"><a href="#扩展欧几里得是什么" class="headerlink" title="扩展欧几里得是什么"></a>扩展欧几里得是什么</h2><p>扩展欧几里得（exgcd）是一个可以用来求 $ax+by=c$（$c\%\gcd(a,b)=0$，否则无解）的解的算法</p><h2 id="求解-ax-by-gcd-a-b"><a href="#求解-ax-by-gcd-a-b" class="headerlink" title="求解 $ax+by=\gcd(a,b)$"></a>求解 $ax+by=\gcd(a,b)$</h2><p>首先，如果 $b=0$ 的话，$\gcd(a,b)=a$，则解为 $\begin{cases}x=1 \\ y=0\end{cases}$</p><p>设此方程的解为 $\begin{cases}x=x_0 \\ y=y_0\end{cases}$</p><p>那么我们需要做的就是将 $ax_0+by_0=\gcd(a,b)$ 转化为 $b=0$ 的格式，这就要用到辗转相除法了。</p><p>设另一个方程：$bx_1+(a\%b)y_1=\gcd(b,a\%b)$</p><p>令 $a_1=b,b_1=a\%b$</p><p>则该方程转化为 $a_1x_1+b_1y_1=\gcd(a_1,b_1)$</p><p>我们会发现它和原方程的格式是一样的，而且根据欧几里得原理，它可以一直递推到 $a_nx_n+b_ny_n=\gcd(a_n,b_n)$ 使得 $b_n=0$，就可以求得解 $\begin{cases}x_n=1 \\ y_n=0\end{cases}$</p><p>那假设我们已经求得了该结果，那如何推导出 $x_0$ 和 $y_0$ 呢？</p><p>我们首先研究如何从 $x_1$ 和 $y_1$ 推导出一组合法的 $x_0$ 和 $y_0$，其他的就同理了</p><p>因为</p><p>$$\begin{cases}bx_1+(a\%b)y_1=\gcd(b,a\%b) \\ ax_0+by_0=\gcd(a,b)\end{cases}$$</p><p>且根据欧几里得定理，$\gcd(a,b)=\gcd(b,a\%b)$</p><p>所以</p><p>$$ax_0+by_0=bx_1+(a\%b)y_1$$</p><p>且 $a\%b=a-\lfloor\frac{a}{b}\rfloor b$（模运算的意义）</p><p>所以</p><p>$$<br>\begin{matrix} \begin{aligned} ax_0+by_0&amp;=bx_1+(a-\lfloor\frac{a}{b}\rfloor b)y_1 \\ &amp;=bx_1+ay_1-\lfloor\frac{a}{b}\rfloor b y_1 \\ &amp;=b(x1-\lfloor\frac{a}{b}\rfloor y_1)+ay_1 \\ &amp;=ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1) \end{aligned} \\ \begin{cases}x_0=y_1 \\ y_0=x_1-\lfloor\frac{a}{b}\rfloor y_1 \end{cases} \end{matrix}<br>$$</p><p>这样，我们就由 $x_1$ 和 $y_1$ 推导出了 $x_0$ 和 $y_0$，其他同理</p><p>于是乎：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp;</span><br><span class="line">        tmp.x=<span class="number">1</span>,tmp.y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    node tmp=<span class="built_in">exgcd</span>(b,a%b);<span class="comment">//递归求出x_(k+1)和y_(k+1)</span></span><br><span class="line">    node ans;</span><br><span class="line">    ans.x=tmp.y,ans.y=(tmp.x)-a/b*(tmp.y);<span class="comment">//推导出x_k和y_k</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就求出了 $ax+by=\gcd(a,b)$ 的一组解</p><h2 id="ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases"><a href="#ax-by-c-的一组解-begin-cases-x-x-tmp-y-y-tmp-end-cases" class="headerlink" title="$ax+by=c$ 的一组解 $\begin{cases} x=x_{tmp}\\y=y_{tmp} \end{cases}$"></a>$ax+by=c$ 的一组解 $\begin{cases} x=x_{tmp}\\y=y_{tmp} \end{cases}$</h2><p>我们已经求出了 $ax+by=\gcd(a,b)$ 的一组解 $\begin{cases} x=x_0 \\ y=y_0 \end{cases}$</p><p>那么我们就可以知道 $akx_0+bky_0=k\gcd(a,b)$</p><p>又因为要求 $c$ 是 $\gcd(a,b)$ 的倍数（否则无解）</p><p>所以 $k=\frac{c}{\gcd(a,b)}$</p><p>所以很简单：</p><p>$$\begin{cases} x_{tmp}=kx_0=\frac{c}{\gcd(a,b)}x_0 \\ y_{tmp}=ky_0=\frac{c}{\gcd(a,b)}y_0 \end{cases}$$</p><h2 id="3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases"><a href="#3-ax-by-c-的所有解-begin-cases-x-x-ans-y-y-ans-end-cases" class="headerlink" title="3.$ax+by=c$ 的所有解 $\begin{cases} x=x_{ans}\\y=y_{ans} \end{cases}$"></a>3.$ax+by=c$ 的所有解 $\begin{cases} x=x_{ans}\\y=y_{ans} \end{cases}$</h2><p>我们已经求出了 $ax+by=c$ 的一组解 $\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>即 $ax_{tmp}+by_{tmp}=c$</p><p>将它加上再减去 $\frac{ab}{\gcd(a,b)}$，得到</p><p>$$\begin{matrix} ax_{tmp}+\frac{ab}{\gcd(a,b)}+by_{tmp}-\frac{ab}{\gcd(a,b)}=c \\ a(x_{tmp}+\frac{b}{\gcd(a,b)})+b(y_{tmp}-\frac{a}{\gcd(a,b)})=c \end{matrix}$$</p><p>在 $x_{tmp}$ 上减，在 $y_{tmp}$ 上加也同理</p><p>所以 $\begin{cases} x=x_{tmp}\pm\frac{b}{\gcd(a,b)} \\ y=y_{tmp}\mp\frac{a}{\gcd(a,b)} \end{cases}$ 也是一组解</p><p>这个变换进行多次，即可得到</p><p>$$\begin{cases} x_{ans}=x_{tmp}+t\times\frac{b}{\gcd(a,b)} \\ y_{ans}=y_{tmp}-t\times\frac{a}{\gcd(a,b)} \end{cases}$$</p><h2 id="x-和-y-各自的最小正整数解"><a href="#x-和-y-各自的最小正整数解" class="headerlink" title="$x$ 和 $y$ 各自的最小正整数解"></a>$x$ 和 $y$ 各自的最小正整数解</h2><p>以 $x$ 的最小正整数解为例：</p><p>求出任意一组解 $\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}$</p><p>因为将 $x_{tmp}$ 加或减 $\frac{b}{\gcd(a,b)}$ 也成立，所以可设 $d=\frac{b}{\gcd(a,b)}$（注意这里分子是 $b$ ）</p><p>$x_{min}=(x_{tmp}\%d+d)\%d$（因为 $x_{tmp}$ 有可能是负数）</p><p>同理对于 $y$，设 $d=\frac{a}{\gcd(a,b)}$（注意这里分子是 $a$）</p><p>$y_{min}=(y_{tmp}\%d+d)\%d$</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>至此，你已经学完了扩展欧几里得的基础用法，如有不懂的地方，建议对照着文章自己推一推，悟一悟。</p><p>做个题练习一下吧：<a href="https://www.luogu.com.cn/problem/P5656">洛谷 P5656 【模板】二元一次不定方程 (exgcd)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
