<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF杂题题解</title>
      <link href="/2022/09/26/cf-za-ti-ti-jie/"/>
      <url>/2022/09/26/cf-za-ti-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="cf129b.-students-and-shoelaces"><a href="https://codeforces.com/contest/129/problem/B">CF129B. Students and Shoelaces</a></h2><p>题意：一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，每一轮删去所有度数为 <span class="math inline">\(1\)</span> 的点，问删几轮停止。</p><p>暴力模拟每一轮即可，每次删点更新邻居度数。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">110</span>],tmp[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        t[u]++,t[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            tmp[i]=t[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="number">1</span>&amp;&amp;!vis[i]) &#123;</span><br><span class="line">                flag=<span class="number">1</span>,vis[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> v:a[i])</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v]) tmp[v]--;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            t[i]=tmp[i];</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="b.-coloring-a-tree"><a href="https://codeforces.com/contest/902/problem/B">902B. Coloring a Tree</a></h2><p>题意：一棵有根树，根结点为 <span class="math inline">\(1\)</span>，初始每个节点的颜色为 <span class="math inline">\(0\)</span>，每次操作可以将一个子树全部涂上一种颜色，问达到目标颜色状态的最小操作数。</p><h3 id="做法-1">做法 1</h3><p>显然要从上往下涂色，dfs 时参数里传入子树目前的颜色，判断要不要更改。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">10010</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col!=c[now]) ans++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:a[now]) <span class="built_in">dfs</span>(v,c[now]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        a[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="做法-2">做法 2</h3><p>可以直接判断一个节点和其父亲的目标颜色是否相同，如果不同则一定需要一次操作。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>],fa[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[fa[i]]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="c.-rumor"><a href="https://codeforces.com/contest/893/problem/C">893C. Rumor</a></h2><p>题意：有一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，第 <span class="math inline">\(i\)</span> 个点有点权 <span class="math inline">\(a_i\)</span>。每次可以花费 <span class="math inline">\(a_i\)</span> 的代价来将 <span class="math inline">\(i\)</span> 所在的连通块染色，求将整个图染色的最小代价。</p><p>显然对于每个连通块只需要 dfs 找到权值最小的点染色即可。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">100010</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[now]) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    vis[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=c[now];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:a[now])</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">dfs</span>(v));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) ans+=<span class="built_in">dfs</span>(i);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC.E-DP题目集锦</title>
      <link href="/2022/09/26/abc.e-dp-ti-mu-ji-jin/"/>
      <url>/2022/09/26/abc.e-dp-ti-mu-ji-jin/</url>
      
        <content type="html"><![CDATA[<h2 id="abc266e.-throwing-the-die"><a href="https://atcoder.jp/contests/abc266/tasks/abc266_e">ABC266E. Throwing the Die</a></h2><p>题意：有 <span class="math inline">\(n\)</span> 次扔骰子机会，每次随机扔到 <span class="math inline">\([1,6]\)</span> 中的一个整数，每次扔完可以选择结束游戏（此时游戏结果为扔到的点数）或者再扔一次，求最佳策略下结果的期望。</p><p>设 <span class="math inline">\(f_i\)</span> 表示有 <span class="math inline">\(i\)</span> 次机会时的得分期望，则 <span class="math inline">\(f_i\)</span> 可以由 <span class="math inline">\(f_{i-1}\)</span> 转移而来：如果第一次扔到的值小于 <span class="math inline">\(f_{i-1}\)</span>，那么继续游戏，答案为 <span class="math inline">\(f_{i-1}\)</span>；如果大于 <span class="math inline">\(f_{i-1}\)</span>，那么结束游戏，答案为当前扔到的值。</p><details class="note success"><summary><p>code:</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> g[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">3.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)</span><br><span class="line">            g[i]+=<span class="built_in">max</span>((<span class="keyword">long</span> <span class="keyword">double</span>)j,g[i<span class="number">-1</span>])/<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.7Lf\n&quot;</span>,g[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="abc265e.-warp"><a href="https://atcoder.jp/contests/abc265/tasks/abc265_e">ABC265E. Warp</a></h2><p>题意：平面直角坐标系，一开始你在 <span class="math inline">\((0,0)\)</span>，每次可以从以下三种方向中选择一种移动：<span class="math inline">\((A,B),(C,D),(E,F)\)</span>；有 <span class="math inline">\(m\)</span> 个障碍物，第 <span class="math inline">\(i\)</span> 个位于 <span class="math inline">\((x_i,y_i)\)</span>，求不碰到障碍物的情况下走 <span class="math inline">\(n\)</span> 步的方案数。</p><p><span class="math inline">\(f[i][j][k]\)</span> 表示走 <span class="math inline">\(i\)</span> 步 1 操作、<span class="math inline">\(j\)</span> 步 2 操作，<span class="math inline">\(k\)</span> 步 3 操作的方案数，则</p><p><span class="math display">\[f[i][j][k]=\begin{cases}0,\ \ \ \ \ \ \ \ \text{if }(iA+jC+kE,iB+jD+kF)\text{ is an obstacle}\\ f[i-1][j][k]+f[i][j-1][k]+f[i][j][k-1],\ \text{ otherwise}\end{cases}\]</span></p><p>由于在每一层中 <span class="math inline">\(i+j+k\)</span> 为定值，可以优化掉一维状态 <span class="math inline">\(k\)</span>。</p><details class="note success"><summary><p>code:</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">3</span>],y[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; t[<span class="number">100010</span>];</span><br><span class="line">set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        cin&gt;&gt;t[i].first&gt;&gt;t[i].second;</span><br><span class="line">        s.<span class="built_in">insert</span>(t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len-i;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> k=len-i-j;</span><br><span class="line">                <span class="keyword">int</span> nowx=i*x[<span class="number">0</span>]+j*x[<span class="number">1</span>]+k*x[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">int</span> nowy=i*y[<span class="number">0</span>]+j*y[<span class="number">1</span>]+k*y[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">auto</span> tmp=s.<span class="built_in">lower_bound</span>(<span class="built_in">make_pair</span>(nowx,nowy));</span><br><span class="line">                <span class="keyword">if</span>(tmp!=s.<span class="built_in">end</span>()&amp;&amp;(*tmp)==<span class="built_in">make_pair</span>(nowx,nowy)) f[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) (f[i][j]+=f[i<span class="number">-1</span>][j])%=mod;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span>) (f[i][j]+=f[i][j<span class="number">-1</span>])%=mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">            (ans+=f[i][j])%=mod;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="abc263e.-sugoroku-3"><a href="https://atcoder.jp/contests/abc263/tasks/abc263_e">ABC263E. Sugoroku 3</a></h2><p>题意：有 <span class="math inline">\(n\)</span> 个格子，第 <span class="math inline">\(i\)</span> 个格子有一个 <span class="math inline">\([0,a_i]\)</span> 的骰子，每到一个格子都会扔一次该格子的骰子，扔到几往前走几步，问走到 <span class="math inline">\(n\)</span> 的期望步数。</p><p><span class="math inline">\(f[i]\)</span> 表示从 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(n\)</span> 的期望步数，则</p><p><span class="math display">\[\begin{aligned}f[i]&amp;=\sum\limits_{j=0}^{a_i}\frac{1}{a_i+1} (f[i+j]+1)\\&amp;=\frac{1}{a_i+1}(f[i]+1)+\frac{1}{a_i+1}\sum\limits_{j=1}^{a_i} (f[i+j]+1)\\&amp;=\frac{1}{a_i+1}f[i]+\frac{1}{a_i+1}\left(1+\sum\limits_{j=1}^{a_i} (f[i+j]+1)\right)\\\frac{a_i}{a_i+1}f[i]&amp;=\frac{1}{a_i+1}\left(1+\sum\limits_{j=1}^{a_i} (f[i+j]+1)\right)\\f[i]&amp;=\frac{1}{a_i}\left(1+\sum\limits_{j=1}^{a_i} (f[i+j]+1)\right)\end{aligned}\]</span></p><p><span class="math inline">\(\sum\)</span> 可以使用前缀和维护。</p><details class="note success"><summary><p>code:</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>],inv[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200010</span>],suf[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        inv[i]=<span class="number">1ll</span>*(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    f[n]=suf[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=(suf[i+<span class="number">1</span>]-suf[i+a[i]+<span class="number">1</span>]+<span class="number">1</span>+mod)%mod;</span><br><span class="line">        f[i]=(<span class="number">1ll</span>*x*inv[a[i]]+<span class="number">1</span>)%mod;</span><br><span class="line">        suf[i]=(suf[i+<span class="number">1</span>]+f[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="abc253e.-distance-sequence"><a href="https://atcoder.jp/contests/abc253/tasks/abc253_e">ABC253E. Distance Sequence</a></h2><p>题意：问有多少个序列 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(\forall 1\le i\le n,a_i\le m\)</span> 且 <span class="math inline">\(\forall 1\le i&lt;n,\left|a_{i+1}-a_i\right|\ge K\)</span></p><p><span class="math inline">\(f[i][j]\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 位，第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(j\)</span> 的方案数，则</p><p><span class="math display">\[f[i][j]=\sum\limits_{k=1}^{j-K} f[i-1][k]+\sum\limits_{k=j+K}^m f[i-1][k]\]</span></p><p>可以使用前缀和维护。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,f[<span class="number">1010</span>][<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>,s[i]=(s[i<span class="number">-1</span>]+f[<span class="number">1</span>][i])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">            f[i][j]=((s[<span class="built_in">max</span>(j-k,<span class="number">0</span>)]+s[m])%mod-s[<span class="built_in">min</span>(j+k<span class="number">-1</span>,m)]+mod)%mod;</span><br><span class="line">            <span class="keyword">if</span>(!k) f[i][j]=(f[i][j]-f[i<span class="number">-1</span>][j]+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            s[j]=(s[j<span class="number">-1</span>]+f[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="abc251e.-takahashi-and-animals"><a href="https://atcoder.jp/contests/abc251/tasks/abc251_e">ABC251E. Takahashi and Animals</a></h2><p>题意：有 <span class="math inline">\(n\)</span> 个动物，每次操作可以花费 <span class="math inline">\(a_i\)</span> 的代价投喂第 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 个动物（特殊地，可以花费 <span class="math inline">\(a_n\)</span> 的代价投喂第 <span class="math inline">\(n\)</span> 和第 <span class="math inline">\(1\)</span> 个动物）。求喂完每个动物至少一次的最小代价。</p><p><span class="math inline">\(f[i][0/1][0/1]\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个动物，第 <span class="math inline">\(1\)</span> 个动物选/不选，第 <span class="math inline">\(i\)</span> 个动物选/不选的最小代价，则</p><p><span class="math display">\[\begin{cases}f[i][j][0]=f[i-1][j][1]\\f[i][j][1]=min(f[i-1][j][0],f[i-1][j][1])+a_i\end{cases}\]</span></p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">600010</span>],f[<span class="number">600010</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">1e18</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>],f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++) &#123;</span><br><span class="line">            f[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>])+a[i];</span><br><span class="line">            f[i][j][<span class="number">0</span>]=f[i<span class="number">-1</span>][j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(&#123;f[n][<span class="number">1</span>][<span class="number">0</span>],f[n][<span class="number">0</span>][<span class="number">1</span>],f[n][<span class="number">1</span>][<span class="number">1</span>]&#125;)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="abc249e.-rle"><a href="https://atcoder.jp/contests/abc249/tasks/abc249_e">ABC249E. RLE</a></h2><p>对于一个小写字母组成的字符串 <span class="math inline">\(S\)</span>，可以如下生成一个字符串 <span class="math inline">\(T\)</span>：将 <span class="math inline">\(S\)</span> 中每个极长的同字符子串替换为“字符+字符个数”的形式。例如 <span class="math inline">\(S=\texttt{aaabcc}\)</span> 生成 <span class="math inline">\(T=\texttt{a3b1c2}\)</span>。求有多少个长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(S\)</span> 满足 <span class="math inline">\(len_T&lt;len_S\)</span>。</p><p><span class="math inline">\(f[i][j]\)</span> 表示 <span class="math inline">\(S\)</span> 的长度为 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 的长度为 <span class="math inline">\(j\)</span> 的方案数，则</p><p><span class="math display">\[f[i][j]=(26-1)\sum\limits_{k\le i}f[i-k][j-\log_{10}(k)]\]</span></p><p>转化一下求和方式：</p><p><span class="math display">\[f[i][j]=(26-1)\sum\limits_{k\le\log_{10}i} \sum\limits_{10^{k-1}\le l&lt;10^k}f[i-l][j-k]\]</span></p><p>其中第二个 <span class="math inline">\(\sum\)</span> 可以使用前缀和维护。复杂度 <span class="math inline">\(n^2\log n\)</span>。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC-270解题报告</title>
      <link href="/2022/09/25/abc-270-jie-ti-bao-gao/"/>
      <url>/2022/09/25/abc-270-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc270">比赛传送门</a></p><h2 id="d.-stones">D. Stones</h2><p><a href="https://atcoder.jp/contests/abc270/tasks/abc270_d">题目传送门</a></p><p>常规的博弈 DP。<span class="math inline">\(f[i]\)</span> 表示还剩 <span class="math inline">\(i\)</span> 个石子的情况下，先手将会拿到多少个，则 <span class="math inline">\(f_i=\max\limits_{a_j\le i}\{i-f_{i-a_j}\}\)</span>。</p><h2 id="e.-apple-baskets-on-circle">E. Apple Baskets on Circle</h2><p><a href="https://atcoder.jp/contests/abc270/tasks/abc270_e">题目传送门</a></p><p>首先二分答案，找最大的 <span class="math inline">\(x\)</span> 使得能够完整地取 <span class="math inline">\(x\)</span> 轮。可以 <span class="math inline">\(O(n)\)</span> 得到取 <span class="math inline">\(x\)</span> 轮会取到的石子数，为 <span class="math inline">\(\sum\limits_{i=1}^n \min(a_i,x)\)</span>，以此为限制二分即可。</p><p>找到最大的 <span class="math inline">\(x\)</span> 时，先取 <span class="math inline">\(x\)</span> 轮，接下来只剩不到一轮能取，暴力取即可。</p><h2 id="f.-transportation">F. Transportation</h2><p><a href="https://atcoder.jp/contests/abc270/tasks/abc270_f">题目传送门</a></p><p>所有建机场的城市可以互相到达、所有建港口的城市可以互相到达，可以想到用虚点来维护。对每个 <span class="math inline">\(i\)</span>，向机场的虚点连一条权值为 <span class="math inline">\(x_i\)</span> 的边，向港口的虚点连一条权值为 <span class="math inline">\(y_i\)</span> 的边，再跑最小生成树即可。</p><p>需要注意的点：</p><ol type="1"><li>有可能不建港口或机场，所以最小生成树不一定要加上虚点。分四类讨论即可。</li><li>有可能在讨论里面出现生成的图不连通的情况，需要特判无解。</li></ol><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125; e[<span class="number">600010</span>];<span class="comment">//边集要开三倍，用于连虚点</span></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">findf</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> _1,<span class="keyword">int</span> _2)</span> </span>&#123;<span class="comment">//_1,_2表示不参与生成树的点，用于分类讨论</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].u==_1||e[i].u==_2) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findf</span>(e[i].u)!=<span class="built_in">findf</span>(e[i].v))</span><br><span class="line">            fa[<span class="built_in">findf</span>(e[i].u)]=<span class="built_in">findf</span>(e[i].v),res+=e[i].w,tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=n+(_1==<span class="number">0</span>)+(_2==<span class="number">0</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tot!=flag) <span class="keyword">return</span> <span class="number">1e18</span>;<span class="comment">//特判无解情况</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        e[++cnt]=&#123;n+<span class="number">1</span>,i,x&#125;;</span><br><span class="line">    &#125;<span class="comment">//连机场（虚点为n+1）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        e[++cnt]=&#123;n+<span class="number">2</span>,i,x&#125;;</span><br><span class="line">    &#125;<span class="comment">//连港口（虚点为n+2）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        e[++cnt]=&#123;u,v,w&#125;;</span><br><span class="line">    &#125;<span class="comment">//连公路</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+cnt+<span class="number">1</span>,[](edge p,edge q) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.w&lt;q.w;</span><br><span class="line">    &#125;);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">kruskal</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">kruskal</span>(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">kruskal</span>(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">kruskal</span>(n+<span class="number">1</span>,n+<span class="number">2</span>));<span class="comment">//分四类讨论</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC-267解题报告</title>
      <link href="/2022/09/23/abc-267-jie-ti-bao-gao/"/>
      <url>/2022/09/23/abc-267-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc267">比赛传送门</a></p><h2 id="d.-index-anot-continuous-ver.">D. Index × A(Not Continuous ver.)</h2><p><a href="https://atcoder.jp/contests/abc267/tasks/abc267_d">题目传送门</a></p><p>令 <span class="math inline">\(f[i][j]\)</span> 表示考虑序列的前 <span class="math inline">\(i\)</span> 位，<span class="math inline">\(i\)</span> 为取的 <span class="math inline">\(j\)</span> 个元素时的最大贡献，则 <span class="math inline">\(f[i][j]=\max\limits_{1\le k&lt;i} f[k][j-1]\)</span>。用 <span class="math inline">\(g[j]\)</span> 维护取 <span class="math inline">\(j\)</span> 个元素时的最大贡献，即可将转移优化为 <span class="math inline">\(O(1)\)</span>，总复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="e.-erasing-vertices-2">E. Erasing Vertices 2</h2><p><a href="https://atcoder.jp/contests/abc267/tasks/abc267_e">题目传送门</a></p><p>可以想到一个很显然的贪心策略：每次取邻居的权值和最小的节点删除。</p><p>具体实现上可以采用类似堆优化 <span class="math inline">\(Dijkstra\)</span> 的思想，用优先队列维护节点和邻居权值，每次取堆顶元素，松弛邻居节点。</p><h2 id="f.-exactly-k-steps">F. Exactly K Steps</h2><p><a href="https://atcoder.jp/contests/abc267/tasks/abc267_f">题目传送门</a></p><p>首先可以想到和树的直径有关。</p><h3 id="做法-1赛时做法">做法 1（赛时做法）</h3><p>对于在直径上的点，距离为 <span class="math inline">\(K\)</span> 的点要么不存在，要么在直径上。这个比较容易处理。</p><p>对于不在直径上的点，可以“向直径跑 <span class="math inline">\(K\)</span> 步”。可以对于每个直径上的点，都往直径“旁边”跑一遍 DFS 来统计答案。由于不能每个点都跑一遍 DFS，可以将询问离线下来，搜到哪个点就记录答案。</p><h3 id="做法-2">做法 2</h3><p>设直径的两端分别为 <span class="math inline">\(L,R\)</span>，则无论是不是直径上的点，距离为 <span class="math inline">\(K\)</span> 的点要么不存在、要么可以往 <span class="math inline">\(L\)</span> 跑 <span class="math inline">\(K\)</span> 步、要么可以往 <span class="math inline">\(R\)</span> 跑 <span class="math inline">\(K\)</span> 步。于是从 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(R\)</span> 分别跑一遍 DFS 即可。（当然也要离线询问）</p><h2 id="g.-increasing-k-times">G. Increasing K Times</h2><p><a href="https://atcoder.jp/contests/abc267/tasks/abc267_g">题目传送门</a></p><p>一个排列计数题，可以考虑从小往大插入数。</p><p>状态：设 <span class="math inline">\(f[i][j]\)</span> 表示插入了前 <span class="math inline">\(i\)</span> 小的数，增长 <span class="math inline">\(j\)</span> 次的方案数。可以维护一个 <span class="math inline">\(cnt\)</span> 表示已经插入了多少个“与当前插入的数相同的数”，转移会用到。</p><p>转移：新插入的数一定是所有数中最大的，从这点入手转移。先考虑什么时候增长的次数不变？放在一个本来就增长的两个数中间。这种情况的方案为 <span class="math inline">\(j\)</span> 种</p><p><img data-src="https://raw.githubusercontent.com/cxm1024/img/master/uPic/FfOmWD.png" /></p><p>只有这一种情况吗？当然不是。还可以放在“与它相同的数”的后面。这种情况有 <span class="math inline">\(cnt\)</span> 种。这两种情况并不会重复计算，因为当前数一定是最大的，所以“与它相同的数”后面的位置原先一定不会上升。还有一种容易忽略的情况时放在整个序列的开头，它不属于以上任何一种情况而满足条件。</p><p>综上，<span class="math inline">\(f[i][j]\leftarrow f[i-1][j]\times(j+cnt+1)\)</span></p><p>什么时候增长的次数会改变？自然是除了以上的情况都会改变。而显然改变只能多 1 次增长，所以 <span class="math inline">\(f[i][j]\leftarrow f[i-1][j-1]\times(i-j-cnt-1)\)</span></p><p>所以转移方程为：</p><p><span class="math display">\[f[i][j]=f[i-1][j]\times(j+cnt+1)+f[i-1][j-1]\times(i-j-cnt-1)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC-268解题报告</title>
      <link href="/2022/09/18/abc-268-jie-ti-bao-gao/"/>
      <url>/2022/09/18/abc-268-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc268">比赛传送门</a></p><h2 id="d.-unique-username">D. Unique Username</h2><p><a href="https://atcoder.jp/contests/abc268/tasks/abc268_d">题目传送门</a></p><p>暴搜即可，复杂度 <span class="math inline">\(O(能过)\)</span></p><h2 id="e.-chinese-restaurant-three-star-version">E. Chinese Restaurant (Three-Star Version)</h2><p><a href="https://atcoder.jp/contests/abc268/tasks/abc268_e">题目传送门</a></p><p>个人感觉非常好的一道题。</p><p>首先抽象一下题意：<span class="math inline">\(n\)</span> 个人和 <span class="math inline">\(n\)</span> 道菜分别呈环状排列，如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/XI0I8R.png" /></p><p>环形可以旋转，若一个人与和他编号相同的菜距离为 <span class="math inline">\(x\)</span>，会产生 <span class="math inline">\(x\)</span> 的贡献，问最小贡献和。</p><p>可以发现，有一些人用顺时针计算距离（如上图中的 <span class="math inline">\(5\)</span>），其他人用逆时针计算距离（如 <span class="math inline">\(3\)</span>）。设编号为 <span class="math inline">\(i\)</span> 的菜位于 <span class="math inline">\(a_i\)</span> ，我们预处理一个桶 <span class="math inline">\(t_x\)</span> 表示 <span class="math inline">\(a_i-i=x\)</span> 的个数。这样，用顺时针计算距离的人数可以得到，为 <span class="math inline">\(t_1+t_2+\cdots+t_{n/2}\)</span>（钦定 <span class="math inline">\(t_0\)</span> 为逆时针计算、<span class="math inline">\(t_{n/2}\)</span> 为顺时针计算，便于后面转移）。若我们当前旋转了 <span class="math inline">\(y\)</span> 格，则此时用顺时针计算距离的人数为 <span class="math inline">\(t_{y+1}+t_{y+2}+\cdots+t_{y+n/2}\)</span>。于是可以使用前缀和来优化这个步骤。为了让每一个 <span class="math inline">\(y\)</span> 都能正确地求得结果，我们将数组复制两遍（拆环为链）再求前缀和。</p><p>计算人数的用处是什么呢？是转移。考虑一次也不转的情况下，贡献和可以暴力预处理出来。每当顺时针转一格，用顺时针计算距离的人的贡献会 <span class="math inline">\(-1\)</span>，而用逆时针计算距离的人的贡献会 <span class="math inline">\(+1\)</span>，那么总贡献会减去顺时针的人数，再加上逆时针的人数。每次转移都用当前人数更新一下，即可 <span class="math inline">\(O(1)\)</span> 从 <span class="math inline">\(y-1\)</span> 的答案转移到 <span class="math inline">\(y\)</span> 的答案，每次转移后更新当前最优解。</p><p>细节：<span class="math inline">\(n\)</span> 为奇数和偶数的转移有细微差别，判断一下即可。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>],t[<span class="number">400010</span>],s[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">0</span>,maxn;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        ans+=<span class="built_in">min</span>((a[i]-i+n)%n,(i-a[i]+n)%n);<span class="comment">//暴力计算初始答案</span></span><br><span class="line">        t[(a[i]-i+n)%n]++,t[(a[i]-i+n)%n+n]++;<span class="comment">//t数组复制两遍，拆环为链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+n;j++)</span><br><span class="line">        s[j]=s[j<span class="number">-1</span>]+t[j];<span class="comment">//前缀和</span></span><br><span class="line">    maxn=ans;<span class="comment">//ans为当前答案，maxn为当前最优解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;<span class="comment">//转i格后的答案</span></span><br><span class="line">        ans-=s[i+n/<span class="number">2</span><span class="number">-1</span>]-s[i<span class="number">-1</span>];<span class="comment">//减顺时针</span></span><br><span class="line">        ans+=n-(s[i+n/<span class="number">2</span><span class="number">-1</span>]-s[i<span class="number">-1</span>]);<span class="comment">//加逆时针</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) ans-=t[i+n/<span class="number">2</span>];<span class="comment">//特殊处理n为奇数的情况</span></span><br><span class="line">        maxn=<span class="built_in">min</span>(maxn,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxn&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f.-best-concatenation">F. Best Concatenation</h2><p><a href="https://atcoder.jp/contests/abc268/tasks/abc268_f">题目传送门</a></p><p>每个字符串内部的贡献是永远不变的，于是预处理。之后，每个字符串的有用信息仅剩 “<code>x</code> 的数量 <span class="math inline">\(numx\)</span>”和“字符串的数字和 <span class="math inline">\(sum\)</span>”。</p><p>考虑相邻两个串什么时候需要交换。设它们为 <span class="math inline">\(s_i,s_{i+1}\)</span>，很容易发现，交换后只会影响它们之间的贡献，不会影响外部的贡献，所以只计算这两个之间的。</p><p>若不交换，贡献为 <span class="math inline">\(numx_i\times sum_{i+1}\)</span>；若交换，贡献为 <span class="math inline">\(numx_{i+1}\times sum_i\)</span>。要最大化贡献值，则依此排序即可。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> numx,sum;</span><br><span class="line">&#125;a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=s.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;X&#x27;</span>) ans+=now,a[i].numx++;</span><br><span class="line">            <span class="keyword">else</span> now+=s[j]-<span class="string">&#x27;0&#x27;</span>,a[i].sum+=s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,[](node p,node q) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.numx*q.sum&gt;q.numx*p.sum;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        ans+=a[i].numx*now,now+=a[i].sum;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC-269解题报告</title>
      <link href="/2022/09/18/abc-269-jie-ti-bao-gao/"/>
      <url>/2022/09/18/abc-269-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc269/">比赛传送门</a></p><h2 id="d.-do-use-hexagon-grid">D. Do use hexagon grid</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_d">题目传送门</a></p><p><span class="math inline">\(n^2\)</span> 枚举两个格点，判断是否能直接走，能则连边，最后用 dfs 计算连通块个数。</p><h2 id="e.-last-rook">E. Last Rook</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_e">题目传送门</a></p><p>由于不需要考虑斜向的冲突，所以考虑行和列分开二分。以行为例：</p><p>如果有若干连续行的棋子数量小于行数，则答案一定在这些行中，以此作为二分的 check。</p><h2 id="f.-numbered-checker">F. Numbered Checker</h2><p><a href="https://atcoder.jp/contests/abc269/tasks/abc269_f">题目传送门</a></p><p>显然每一行剩下的数都是一个等差数列。</p><p>考虑奇偶行分开计算：对于奇数行，只有奇数列能产生贡献；对于偶数行，只有偶数列能产生贡献。以奇数行为例：</p><p>具体地，若输入的四界分别为 <span class="math inline">\(u,d,l,r\)</span>，则只考虑奇数行时，我们将四界缩紧为 <span class="math inline">\(u&#39;,d&#39;,l&#39;,r&#39;\)</span>（为方便接下来处理），此时能产生贡献的列数为 <span class="math inline">\(len_{row}=(r&#39;-l&#39;)/2+1\)</span>，行数为 <span class="math inline">\(len_{column}=(d&#39;-u&#39;)/2+1\)</span>。</p><p>显然贡献的左上角的值为 <span class="math inline">\(s_1=(u&#39;-1)\times m+l&#39;\)</span>，右上角为 <span class="math inline">\(s_2=(u&#39;-1)\times m+r&#39;\)</span>，则第一行的和 <span class="math inline">\(sum_{u&#39;}=(s_1+s_2)\times len_{row}\)</span>。</p><p>第二个产生贡献的行（即 <span class="math inline">\(u&#39;+2\)</span> 行）的和为 <span class="math inline">\(sum_{u&#39;+2}=sum_{u&#39;}+len_{row}\times 2m\)</span>，第三行为 <span class="math inline">\(sum_{u&#39;+4}=sum_{u&#39;}+len_{row}\times 4m\)</span> 以此类推。可以发现每一行都含有一个 <span class="math inline">\(sum_{u&#39;}\)</span> 的项，单独提出来，得到 <span class="math inline">\(sum_{u&#39;}\times len_{column}\)</span>，而每一行新加的贡献为 <span class="math inline">\(len_{row}\times 0m+len_{row}\times 2m+len_{row}\times 4m\cdots\)</span>，这也可以很容易得用等差数列求得。</p><p>偶数行偶数列的情况同理，由于操作完全相同，可以封装成函数调用两遍。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> (a+b)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,u,d,ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;d&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">auto</span> solve=[&amp;](<span class="keyword">bool</span> flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> u1=u,d1=d,l1=l,r1=r;</span><br><span class="line">            <span class="keyword">if</span>(u1%<span class="number">2</span>==flag) u1++;</span><br><span class="line">            <span class="keyword">if</span>(d1%<span class="number">2</span>==flag) d1--;</span><br><span class="line">            <span class="keyword">if</span>(l1%<span class="number">2</span>==flag) l1++;</span><br><span class="line">            <span class="keyword">if</span>(r1%<span class="number">2</span>==flag) r1--;</span><br><span class="line">            <span class="keyword">int</span> lenrow=(r1-l1)/<span class="number">2</span>+<span class="number">1</span>,lencol=(d1-u1)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">add</span>(<span class="built_in">add</span>(<span class="built_in">mul</span>(u1<span class="number">-1</span>,m),l1),<span class="built_in">add</span>(<span class="built_in">mul</span>(u1<span class="number">-1</span>,m),r1)),lenrow),inv2);</span><br><span class="line">            (ans+=<span class="built_in">mul</span>(res,lencol))%=mod;</span><br><span class="line">            (ans+=<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="number">2</span>*(lencol<span class="number">-1</span>),m),lencol),inv2),lenrow))%=mod;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>),<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博弈论学习笔记</title>
      <link href="/2022/07/12/bo-yi-lun-xue-xi-bi-ji/"/>
      <url>/2022/07/12/bo-yi-lun-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>挖个巨坑，慢慢填。</p><h2 id="从-nim-游戏入手">从 Nim 游戏入手</h2><p>问题：有 <span class="math inline">\(n\)</span> 堆石子，第 <span class="math inline">\(i\)</span> 堆石子有 <span class="math inline">\(s_i\)</span> 个，两个人轮流取石子，每人每次只能从一堆中取任意数量的石子，可以取完，不能不取。问先手必胜还是必败。</p><blockquote><p>前置知识：</p><ol type="1"><li>异或 <span class="math inline">\(\oplus\)</span>：有两个数均为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>，若它们相等则异或结果为 <span class="math inline">\(0\)</span>，不相等结果为 <span class="math inline">\(1\)</span></li><li>按位异或 <span class="math inline">\(\oplus\)</span>：将两个正整数分别表示成二进制，对应位进行异或。易证，按位异或满足交换律、结合律，同时有自反性，即 <span class="math inline">\(a\oplus a=0\)</span></li><li>异或和：若干个正整数 <span class="math inline">\(a_1,a_2,a_3,\ldots,a_n\)</span> 的异或和为 <span class="math inline">\(a_1\oplus a_2\oplus a_3\oplus\ldots\oplus a_n\)</span>。容易发现，若 <span class="math inline">\(s\)</span>（二进制）中某一位为 <span class="math inline">\(1\)</span> 的数字个数为奇数，则异或和中该位为 <span class="math inline">\(1\)</span>；若为偶数，则异或和中该位为 <span class="math inline">\(0\)</span></li></ol></blockquote><p><strong>结论：若 <span class="math inline">\(s\)</span> 的异或和为 <span class="math inline">\(0\)</span>，先手必败，反之则先手必胜。</strong></p><p>感性理解一下。考虑只有两堆的特殊情况，如果两堆的数量相等，那么先手必败，策略为：先手从一堆中取若干个，后手从另一堆中取相同个数，则易证一定被后手取完。反之，如果两堆的数量不等，那么先手必胜，策略为：先从多的那堆里取若干个，使两堆数量相等，接下来同上（后手变为上面的先手）。</p><p>考虑用异或来解释。若先手取时两堆不相等（即异或和不为 <span class="math inline">\(0\)</span>），则从多的那堆里取若干个使两堆相等（使得异或和变为 <span class="math inline">\(0\)</span>）。接下来无论后手怎么取，一定会导致两堆数量不相等（使异或和不为 <span class="math inline">\(0\)</span>）。先手从另一堆中模仿后手操作，使两堆再次相等（异或和重新变成 <span class="math inline">\(0\)</span>），以此类推。</p><p>有了以上感性理解，我们就可以尝试推广到 <span class="math inline">\(n\)</span> 堆的普遍情况。</p><p><strong>定理一：当异或和不为 <span class="math inline">\(0\)</span> 时，一定存在一种取石子方式使得异或和变为 <span class="math inline">\(0\)</span>。</strong></p><p>证明：</p><p>若我们所在的状态满足 <span class="math inline">\(s_1\oplus s_2\oplus\ldots\oplus s_n=m (m\ne 0)\)</span>（<span class="math inline">\(s_i\)</span> 表示第 <span class="math inline">\(i\)</span> 堆的石子数），则<span class="math inline">\(s_1\oplus s_2\oplus\ldots\oplus s_n\oplus m=m\oplus m=0\)</span>（自反性），所以只要随便选择一堆 <span class="math inline">\(s_i\)</span> 变为 <span class="math inline">\(s_i\oplus m\)</span> 即可。但是由于要“取”石子，所以要求变化后石子数必须减少，那么是否一定存在一堆 <span class="math inline">\(s_i\)</span> 满足 <span class="math inline">\(s_i\oplus m&lt;s_i\)</span> 呢？答案是肯定的。</p><p><span class="math inline">\(m\)</span>（二进制）的最高位（设为第 <span class="math inline">\(k\)</span> 位）的 <span class="math inline">\(1\)</span> 一定是由 <span class="math inline">\(s\)</span> 中奇数个 <span class="math inline">\(1\)</span> 得来的，也就是在 <span class="math inline">\(s\)</span> 中一定存在至少一个第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(1\)</span> 的数。随便选一个，假设为第 <span class="math inline">\(i\)</span> 个，则将上式最后的 <span class="math inline">\(\oplus m\)</span> 与 <span class="math inline">\(s_i\)</span> 结合，结果一定会比 <span class="math inline">\(s_i\)</span> 小。因为 <span class="math inline">\(s_i\)</span> 比 <span class="math inline">\(k\)</span> 高的位不变，第 <span class="math inline">\(k\)</span> 位由 <span class="math inline">\(1\)</span> 变为了 <span class="math inline">\(0\)</span>，剩下的无论怎么变结果都会比 <span class="math inline">\(s_i\)</span> 小。</p><p>所以只要异或和不为 <span class="math inline">\(0\)</span>，一定可以通过选合适的一堆取若干个石子使得 <span class="math inline">\(s_i\to s_i\oplus m\)</span>，则异或和 <span class="math inline">\(m\to 0\)</span>。</p><p><strong>定理二：当异或和为 <span class="math inline">\(0\)</span> 时，无论如何取石子，取后异或和都将不为 <span class="math inline">\(0\)</span>。</strong></p><p>证明：</p><p>假设取后异或和仍然为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(m=0\)</span>，又因为 <span class="math inline">\(m\)</span> 只能选一堆结合，所以 <span class="math inline">\(s_i\)</span> 只能不变。但题目要求必须取，与假设矛盾，所以取后异或和一定不为 <span class="math inline">\(0\)</span>。</p><p>综上所述，当先手处于异或和不为 <span class="math inline">\(0\)</span> 的状态时：</p><ol type="1"><li>先手一定可以通过一定方式变成异或和为 <span class="math inline">\(0\)</span>（定理一）</li><li>此时后手只能变成异或和不为 <span class="math inline">\(0\)</span>（定理二），接下来重复步骤 1</li><li>胜利状态的 <span class="math inline">\(s\)</span> 全为 <span class="math inline">\(0\)</span>，异或和为 <span class="math inline">\(0\)</span>，而对手只能变成异或和不为 <span class="math inline">\(0\)</span>，所以永远取不到胜利状态</li><li>由于每步石子数必然会减少，最终一定会达到胜利状态，则胜利状态必然由先手取到</li></ol><p>若先手处于异或和为 <span class="math inline">\(0\)</span> 的状态，则任何操作都将导致异或和不为 <span class="math inline">\(0\)</span>，接下来后手如上操作，则后手必胜。</p><p>未完待续，不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>儒略日-题解</title>
      <link href="/2022/07/07/ru-lue-ri-ti-jie/"/>
      <url>/2022/07/07/ru-lue-ri-ti-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>时隔两年，这个极为经典的题目终于被我 AC 了。经过诸多优化改良，最终得到了这个个人认为比较优美的做法，写篇题解纪念一下，也供参考。</p><p>首先，建议读者先对照无注释代码自行理解一下大致过程。</p><h2 id="无注释代码">无注释代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _1=<span class="number">365</span>,_100=_1*<span class="number">100</span>+<span class="number">24</span>,_400=_100*<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span><span class="keyword">int</span> y,m,d,ru;&#125; t[<span class="number">4000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrun</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year&lt;<span class="number">0</span>) <span class="keyword">return</span> (year+<span class="number">1</span>)%<span class="number">4</span>==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;(year&lt;=<span class="number">1582</span>||year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">date <span class="title">nxtday</span><span class="params">(date a)</span> </span>&#123;</span><br><span class="line">    a.d++,a.ru++;</span><br><span class="line">    <span class="keyword">if</span>(a.y==<span class="number">1582</span>&amp;&amp;a.m==<span class="number">10</span>&amp;&amp;a.d==<span class="number">5</span>) <span class="keyword">return</span> a.d=<span class="number">15</span>,a;</span><br><span class="line">    <span class="keyword">if</span>(a.m==<span class="number">2</span>&amp;&amp;a.d==<span class="number">29</span>&amp;&amp;<span class="built_in">isrun</span>(a.y));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.d&gt;mon[a.m]) a.m++,a.d=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.m&gt;<span class="number">12</span>) a.y++,a.y+=!a.y,a.m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(date x)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;x.d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x.m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">abs</span>(x.y)&lt;&lt;(x.y&lt;<span class="number">0</span>?<span class="string">&quot; BC&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>]=&#123;<span class="number">-4713</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> _20000101;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;t[i<span class="number">-1</span>].y&lt;=<span class="number">2000</span>;i++) &#123;</span><br><span class="line">        t[i]=<span class="built_in">nxtday</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(t[i].y==<span class="number">2000</span>&amp;&amp;t[i].m==<span class="number">1</span>&amp;&amp;t[i].d==<span class="number">1</span>)</span><br><span class="line">            _20000101=t[i].ru;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _0=_20000101-_400*<span class="number">5</span>,T,x;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=_20000101) <span class="built_in">print</span>(t[x]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            date ans&#123;(x-_0)/_400*<span class="number">400</span>,<span class="number">1</span>,<span class="number">1</span>,(x-_0)/_400*_400+_0&#125;;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_100+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_100+<span class="built_in">isrun</span>(ans.y),ans.y+=<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_1+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_1+<span class="built_in">isrun</span>(ans.y),ans.y++;</span><br><span class="line">            <span class="keyword">while</span>(ans.ru&lt;x) ans=<span class="built_in">nxtday</span>(ans);</span><br><span class="line">            <span class="built_in">print</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析">解析</h2><p>大体思路是这样的：<span class="math inline">\(1582\)</span> 年之前的暴力 <code>nxtday</code> 跑出来，而 <span class="math inline">\(1582\)</span> 年之后的想办法逐渐逼近计算。</p><p>这里我们暴力跑到了 <span class="math inline">\(2000\)</span> 年（以下讲解只考虑 <span class="math inline">\(2000\)</span> 年以后），并保存了 <code>_20000101</code> 这个常数，表示 <span class="math inline">\(2000\)</span> 年 <span class="math inline">\(1\)</span> 月 <span class="math inline">\(1\)</span> 日的儒略日。原因之一是避免考虑边界情况，而原因之二，就是本做法的灵魂所在：</p><blockquote><p>重点在于 <code>_20000101</code> 这个常数。将这个常数减去五个 <span class="math inline">\(400\)</span> 年（代码中的 <code>_400</code>），就可以反推出“理想状态下”公元 <span class="math inline">\(0\)</span> 年 <span class="math inline">\(1\)</span> 月 <span class="math inline">\(1\)</span> 日的儒略日 <code>_0</code>。这样，我们就可以 <span class="math inline">\(O(1)\)</span> 计算出所求儒略日位于哪一个“<span class="math inline">\(400\)</span> 年周期”中，并得到该周期的第一天的确切 <code>date</code>：</p><ul><li><code>year=(x-_0)/_400*400</code></li><li><code>ru=(x-_0)/_400*_400+_0</code></li></ul><p>这两行为本 trick 的精华，建议仔细理解（见程序第 36 行）</p></blockquote><p>求出了本周期第一天的儒略日，接下来就是简单的逼近答案了：先尝试每次加上 <span class="math inline">\(100\)</span> 年（不超过 <span class="math inline">\(4\)</span> 次），再每次加上 <span class="math inline">\(1\)</span> 年（不超过 <span class="math inline">\(100\)</span> 次），最后暴力 <code>nxtday</code> 跑到答案（不超过 <span class="math inline">\(365\)</span> 次）。时间复杂度在可接受范围之内。</p><h2 id="详细代码">详细代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mon[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _1=<span class="number">365</span>,_100=_1*<span class="number">100</span>+<span class="number">24</span>,_400=_100*<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//方便计算，预处理出格里高利历1年、100年和400年的天数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span><span class="keyword">int</span> y,m,d,ru;&#125; t[<span class="number">4000010</span>];</span><br><span class="line"><span class="comment">//公元前的y为负数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrun</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123; <span class="comment">//闰年判断</span></span><br><span class="line">    <span class="keyword">if</span>(year&lt;<span class="number">0</span>) <span class="keyword">return</span> (year+<span class="number">1</span>)%<span class="number">4</span>==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;(year&lt;=<span class="number">1582</span>||year%<span class="number">100</span>!=<span class="number">0</span>||year%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">date <span class="title">nxtday</span><span class="params">(date a)</span> </span>&#123; <span class="comment">//暴力计算下一天</span></span><br><span class="line">    a.d++,a.ru++; <span class="comment">//天数和儒略日首先增加</span></span><br><span class="line">    <span class="keyword">if</span>(a.y==<span class="number">1582</span>&amp;&amp;a.m==<span class="number">10</span>&amp;&amp;a.d==<span class="number">5</span>) <span class="keyword">return</span> a.d=<span class="number">15</span>,a;</span><br><span class="line">    <span class="comment">//特判中间消失的10天</span></span><br><span class="line">    <span class="keyword">if</span>(a.m==<span class="number">2</span>&amp;&amp;a.d==<span class="number">29</span>&amp;&amp;<span class="built_in">isrun</span>(a.y)); <span class="comment">//闰年的2月29无需进位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.d&gt;mon[a.m]) a.m++,a.d=<span class="number">1</span>; <span class="comment">//由日向月进位</span></span><br><span class="line">    <span class="keyword">if</span>(a.m&gt;<span class="number">12</span>) a.y++,a.y+=!a.y,a.m=<span class="number">1</span>; <span class="comment">//由月向年进位（特判了公元0年不存在）</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(date x)</span> </span>&#123; <span class="comment">//输出</span></span><br><span class="line">    cout&lt;&lt;x.d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x.m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">abs</span>(x.y)&lt;&lt;(x.y&lt;<span class="number">0</span>?<span class="string">&quot; BC&quot;</span>:<span class="string">&quot;&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>]=&#123;<span class="number">-4713</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> _20000101;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;t[i<span class="number">-1</span>].y&lt;=<span class="number">2000</span>;i++) &#123; <span class="comment">//暴力打表到2000年</span></span><br><span class="line">        t[i]=<span class="built_in">nxtday</span>(t[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(t[i].y==<span class="number">2000</span>&amp;&amp;t[i].m==<span class="number">1</span>&amp;&amp;t[i].d==<span class="number">1</span>)</span><br><span class="line">            _20000101=t[i].ru; <span class="comment">//保存常数2000.1.1儒略日</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _0=_20000101-_400*<span class="number">5</span>,T,x; <span class="comment">//计算“理想状态”下0.1.1儒略日</span></span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=_20000101) <span class="built_in">print</span>(t[x]); <span class="comment">//直接查表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            date ans&#123;(x-_0)/_400*<span class="number">400</span>,<span class="number">1</span>,<span class="number">1</span>,(x-_0)/_400*_400+_0&#125;;</span><br><span class="line">            <span class="comment">//计算400周期的第一天（格式为y,m,d,ru）</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_100+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_100+<span class="built_in">isrun</span>(ans.y),ans.y+=<span class="number">100</span>;</span><br><span class="line">            <span class="comment">//100年为步长逼近</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru+_1+<span class="built_in">isrun</span>(ans.y)&lt;=x)</span><br><span class="line">                ans.ru+=_1+<span class="built_in">isrun</span>(ans.y),ans.y++;</span><br><span class="line">            <span class="comment">//1年为步长逼近</span></span><br><span class="line">            <span class="keyword">while</span>(ans.ru&lt;x) ans=<span class="built_in">nxtday</span>(ans);</span><br><span class="line">            <span class="comment">//暴力nxtday得到答案</span></span><br><span class="line">            <span class="built_in">print</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC-138解题报告</title>
      <link href="/2022/05/01/arc-138-jie-ti-bao-gao/"/>
      <url>/2022/05/01/arc-138-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/arc138">比赛传送门</a></p><h2 id="a.-larger-score"><a href="https://atcoder.jp/contests/arc138/tasks/arc138_a">A. Larger Score</a></h2><p>因为只需要增加而不限制增加量，所以找到一对前小后大的数对，设法将它们交换即可。具体来说，所以对于 <span class="math inline">\(k+1\)</span> 到 <span class="math inline">\(n\)</span> 的一个位置 <span class="math inline">\(i\)</span>，找到在前 <span class="math inline">\(k\)</span> 个当中离它最近的（最后的）、比它小的位置 <span class="math inline">\(j\)</span>（取后缀 <span class="math inline">\(\min\)</span> 后用 <code>lower_bound</code> 找出），用 <span class="math inline">\(k-j\)</span> 次操作将 <span class="math inline">\(j\)</span> 移到位置 <span class="math inline">\(k\)</span>，用 <span class="math inline">\(i-k-1\)</span> 次操作将 <span class="math inline">\(i\)</span> 移到位置 <span class="math inline">\(k+1\)</span>，再用一次操作交换即可，总操作数为 <span class="math inline">\((k-j)+(i-k-1)+1=i-j\)</span> 次。这就是一个位置的答案。计算每个位置的答案，取最小值即可。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,ans=<span class="number">1e9</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        a[i]=<span class="built_in">min</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+k+<span class="number">1</span>,a[i])-a<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,i-tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b.-01-generation"><a href="https://atcoder.jp/contests/arc138/tasks/arc138_b">B. 01 Generation</a></h2><p>由于只有前面加1反转和后面加0两种操作，所以考虑它们的分界线。</p><p>在前面的部分全部由添加1反转构成，所以一定是 <code>010101...</code> 这种形式，找出最长的满足要求的前缀，这就是第一部分。第一部分的0必须依次插入，可以发现，每插入一个0，第二部分就会受到影响，得到反转，所以当在第二部分中遇到连续的若干个0或连续的1的时候，它们一定（在最优解中）是同一块插入的。</p><p>而两块0、1的交界处必然进行了一次一操作（最优解中）。这样只需要比较操作一的次数（即最长01前缀的长度）和操作二的变化次数即可。如果操作一的次数小于第二部分的变化次数则不可行，反之可行。</p><p>这道题还有另一种思考方式，即倒序思考，将插入操作转化为删除。读者可自行考虑。</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(now&lt;n&amp;&amp;a[now]!=a[now+<span class="number">1</span>]) now++;</span><br><span class="line">    <span class="keyword">if</span>(now==n) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;now;i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[i+<span class="number">1</span>]) ans++;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=now) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c.-rotate-and-play-game"><a href="https://atcoder.jp/contests/arc138/tasks/arc138_c">C. Rotate and Play Game</a></h2><p>题目问最好情况，那么有一个很自然的猜测：最好情况一定可以取得最优解，即拿走大的那一半，留下小的那一半。这就要求我们在翻转之后，在任何一个前缀当中，小的数的个数 <span class="math inline">\(\ge\)</span> 大的数的个数（这样才能保证对方走到大的数之前，我已经把它拿掉了）。设较小的一半数为 <span class="math inline">\(+1\)</span>，较大的一半为 <span class="math inline">\(-1\)</span>，则相当于要求前缀和中不存在负数。在坐标系中表现出来就是这样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/On30hU.png" /></p><p>（数据 <code>3 4 1 2</code> 的图像）</p><p>那么，分成两半后互换就可以表示为，选一个点，以它为原点开始，再走回自己结束。这样结论就很显然了：选最低的点，以它为起点，坐标为0，那么之后无论怎么走也不会比它更低，满足要求。在此例子中，选择点 <span class="math inline">\(C\)</span> 为起点，这样答案序列为 <code>1 2 3 4</code>，满足要求。</p><p>（不得不说是一道非常巧妙的转化题）</p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>],b[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fen=b[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mini=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=fen) a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[mini])</span><br><span class="line">            mini=i;</span><br><span class="line">    cout&lt;&lt;mini&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理证明</title>
      <link href="/2022/04/28/gou-gu-ding-li-zheng-ming/"/>
      <url>/2022/04/28/gou-gu-ding-li-zheng-ming/</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/gSEQDf.png" /></p><p>在这个直角三角形中，我们设以 <span class="math inline">\(c\)</span> 为底的大三角形面积为 <span class="math inline">\(S_c\)</span>，以 <span class="math inline">\(a,b\)</span> 为底的两个小三角形的面积分别为 <span class="math inline">\(S_a,S_b\)</span>。</p><p>显然，<span class="math inline">\(S_c=\frac{ch}{2}=c^2\cdot\frac{h}{2c}\)</span>。令 <span class="math inline">\(m=\frac{h}{2c}\)</span>，则有 <span class="math inline">\(S_c=mc^2\)</span>。</p><p>同理，<span class="math inline">\(S_a=a^2\cdot\frac{h_a}{2a}\)</span>（其中 <span class="math inline">\(h_a\)</span> 表示三角形 <span class="math inline">\(BPC\)</span> 中以 <span class="math inline">\(a\)</span> 为底的高）。显然该三角形与大三角形 <span class="math inline">\(ABC\)</span> 相似，所以 <span class="math inline">\(\frac{ha}{h}=\frac{a}{c}\)</span>，即 <span class="math inline">\(\frac{h_a}{2a}=\frac{h}{2c}=m\)</span>，所以 <span class="math inline">\(S_a=ma^2\)</span>。同理 <span class="math inline">\(S_b=mb^2\)</span>。</p><p>又因为，<span class="math inline">\(S_c=S_a+S_b\)</span>，所以 <span class="math inline">\(mc^2=ma^2+mb^2\)</span>，即 <span class="math inline">\(c^2=a^2+b^2\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包DP学习笔记</title>
      <link href="/2022/01/22/bei-bao-dp-xue-xi-bi-ji/"/>
      <url>/2022/01/22/bei-bao-dp-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="背包">01背包</h2><p><strong>由于01背包太过经典，所以一定要把每一个细节理解透彻！</strong></p><blockquote><p>有 <span class="math inline">\(n\)</span> 个物品和一个容量为 <span class="math inline">\(m\)</span> 的背包，每个物品有体积 <span class="math inline">\(w_i\)</span> 和价值 <span class="math inline">\(v_i\)</span>，求用这个背包所能装下的最大价值。</p></blockquote><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示只考虑前 <span class="math inline">\(i\)</span> 个物品，体积不超过 <span class="math inline">\(j\)</span> 的最大价值。如果我们算完了前 <span class="math inline">\(i-1\)</span> 个物品的所有结果，那么第 <span class="math inline">\(i\)</span> 个物品有选和不选两种情况。如果不选，则结果为 <span class="math inline">\(f_{i-1,j}\)</span>；如果买，则：由于选了 <span class="math inline">\(i\)</span> 后体积不超过 <span class="math inline">\(j\)</span>，那么选 <span class="math inline">\(i\)</span> 之前体积就不能超过 <span class="math inline">\(j-w_i\)</span>，而选了 <span class="math inline">\(i\)</span> 之后获得的价值就多了 <span class="math inline">\(v_i\)</span>，所以结果为 <span class="math inline">\(f_{i-1,j-w_i}+v_i\)</span>。这样，我们就得出了经典的状态转移方程：<span class="math inline">\(f_{i,j}=max(f_{i-1,j},f_{i-1,j-w_i}+v_i)\)</span>。</p><p>接下来，我们再考虑一些细节。对于 <span class="math inline">\(f\)</span> 数组的初始化，我们可以将所有的方案全部赋值为 <span class="math inline">\(0\)</span>，因为无论考虑多少物品，无论体积不超过多少，都一定有一种符合要求的方案：一个也不选。这时的价值就是 <span class="math inline">\(0\)</span>。</p><p>然后就到了经典的空间优化：我们可以发现 <span class="math inline">\(f_i\)</span> 这一行只与 <span class="math inline">\(f_{i-1}\)</span> 这一行有关，所以我们可以将 <span class="math inline">\(i\)</span> 这一维省略。这样，当我们准备求 <span class="math inline">\(f_j\)</span> 时，我们要求 <span class="math inline">\(f_j\)</span> 和 <span class="math inline">\(f_{j-w_i}\)</span> 都还没有被更新过。因为我们正准备更新 <span class="math inline">\(f_j\)</span>，所以第一个要求可以保证，那么怎么保证 <span class="math inline">\(f_{j-w_i}\)</span> 没有被更新过呢？答案就是倒序更新（这样就在更新 <span class="math inline">\(f_j\)</span> 之后才会更新到 <span class="math inline">\(f_{j-w_i}\)</span> 了）。</p><p>接下来还有一个经典的常数优化：因为当 <span class="math inline">\(j&lt;w_i\)</span> 时，转移方程中 <span class="math inline">\(f_{j-w_i}\)</span> 不存在，不需要考虑更新，所以 <span class="math inline">\(j\)</span> 必须大于等于 <span class="math inline">\(w_i\)</span>，也就是倒序枚举时 <span class="math inline">\(j\)</span> 只需要从 <span class="math inline">\(m\)</span> 枚举到 <span class="math inline">\(w_i\)</span>。</p><p>所以，我们就得到了经典的01背包代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w_i;j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1048">采药</a></p><h3 id="正好填满的01背包">正好填满的01背包</h3><p>是一个01背包经典的变形，题意基本与01背包相同，但要求背包必须填满。</p><p>这时，<span class="math inline">\(f\)</span> 数组的意义发生了一点变化：<span class="math inline">\(f_{i,j}\)</span> 表示只考虑前 <span class="math inline">\(i\)</span> 个物品，体积<strong>恰好为</strong> <span class="math inline">\(j\)</span> 的最大价值。</p><p>但是，仔细推理一下，就会发现，状态转移方程和01背包一模一样，空间优化和常数优化也都通用。那不一样的地方在哪里呢？答案是初始化。由于要求体积恰好为 <span class="math inline">\(j\)</span>，所以当 <span class="math inline">\(j\ne 0\)</span> 时，不允许一个也不选，所以初始化为负无穷（表示目前没有任何方案满足条件），当 <span class="math inline">\(j=0\)</span> 时，才存在一个也不选的方案，这时才能初始化为 <span class="math inline">\(0\)</span>。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="二维费用背包">二维费用背包</h3><p>有两维费用（如：一个事件既要消耗时间也要消耗金钱，获得一定价值）的01背包。</p><p>将01背包多开两维费用，其他完全相同。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包第一维容量为m，背包第二维容量为t</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w1[i];j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=t;k&gt;=w2[i];k--)</span><br><span class="line">            f[j][k]=<span class="built_in">max</span>(f[j][k],f[j-w1[i]][k-w2[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m][t]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1855">榨取kkksc03</a></p><h2 id="完全背包">完全背包</h2><p>又是一个经典模型，也必须要理解透彻。题意与01背包基本相同，但每个物品能选无数遍。</p><p>同样设 <span class="math inline">\(f_{i,j}\)</span> 表示只考虑前 <span class="math inline">\(i\)</span> 种物品，体积不超过 <span class="math inline">\(j\)</span> 的最大价值。这时如何更新呢？如果我们不选这个物品，那么结果为 <span class="math inline">\(f_{i-1,j}\)</span>；如果选，那么结果为 <span class="math inline">\(f_{i,j-w_i}+v_i\)</span>。这是为什么呢？在01背包中，我们当前要选 <span class="math inline">\(i\)</span>，那么选这个 <span class="math inline">\(i\)</span> 之前，只能考虑前 <span class="math inline">\(i-1\)</span> 个物品，所以要从 <span class="math inline">\(f_{i-1,j-w_i}\)</span> 转移，但是在完全背包中，每个物品可以选无数次，所以选这个 <span class="math inline">\(i\)</span> 之前，<span class="math inline">\(i\)</span> 也是可以选的，所以要从 <span class="math inline">\(f_{i,j-w_i}\)</span> 转移而来。这样，我们就得到了最终的转移方程：<span class="math inline">\(f_{i,j}=max(f_{i-1,j},f_{i,j-w_i}+v_i)\)</span>。</p><p>同01背包一样，我们也可以省略掉 <span class="math inline">\(i\)</span> 这一维。这时，当我们求 <span class="math inline">\(f_j\)</span> 时，要求变成 <span class="math inline">\(f_j\)</span> 还没有更新，而 <span class="math inline">\(f_{j-w_i}\)</span> 已经更新过了（因为我们要用的是 <span class="math inline">\(f_{i,j-w_i}\)</span> 而不是 <span class="math inline">\(f_{i-1,j-w_i}\)</span>）。同样，第一个要求能直接满足，对于第二个要求，我们只需要正序枚举 <span class="math inline">\(j\)</span> 即可。所以，最终转移方程与01背包一样，但 <span class="math inline">\(j\)</span> 的枚举顺序变成了正序。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1616">疯狂的采药</a></p><h2 id="多重背包">多重背包</h2><p>题意与01背包基本相同，但每种物品能选 <span class="math inline">\(x_i\)</span> 次。</p><p>一个很容易想到的思路为将一种物品选 <span class="math inline">\(x\)</span> 次转换成 <span class="math inline">\(x\)</span> 个完全相同的物品，再做01背包。</p><p>这样的复杂度显然不够优秀，所以我们考虑优化。我们希望将每个物品选 <span class="math inline">\(x\)</span> 次转换成若干个物品，使得无论想选多少次都能用这若干个物品凑出来。一个较为明显的做法就是二进制分解。例如，我们有一个物品能选20次，我们就将它分解成一个 <span class="math inline">\(1\)</span> 倍物品、一个 <span class="math inline">\(2\)</span> 倍物品、一个 <span class="math inline">\(4\)</span> 倍物品、一个 <span class="math inline">\(8\)</span> 倍物品和一个 <span class="math inline">\(5\)</span> 倍物品（几倍物品指的是体积和价值都为原物品的几倍）。易证，这一定满足我们的条件。这样，我们就将一个物品选 <span class="math inline">\(x\)</span> 次分解成了 <span class="math inline">\(\log(x)\)</span> 个物品，然后再跑一遍01背包即可。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    for(int tmp=1;x[i];tmp*=2) &#123;</span><br><span class="line">        int num=min(tmp,x[i]);</span><br><span class="line">        int wt=w[i]*num,vt=v[i]*num;</span><br><span class="line">        for(int j=m;j&gt;=wt;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-wt]+vt);</span><br><span class="line">        x[i]-=num;</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a></p><h2 id="混合背包">混合背包</h2><p>将01背包、完全背包和多重背包缝合在一起的问题。</p><p>思路很简单，无需多讲解，分别考虑即可。形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(枚举物品)  &#123;</span><br><span class="line">    if(01背包)</span><br><span class="line">        01背包代码</span><br><span class="line">    else if(完全背包)</span><br><span class="line">        完全背包代码</span><br><span class="line">    else</span><br><span class="line">        多重背包代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，01背包和多重背包可以共用多重背包的代码，因为01背包可以当成只能取一次的多重背包。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P1833">樱花</a></p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i]==<span class="number">0</span>) &#123;<span class="comment">//完全背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//01背包和多重背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tmp=<span class="number">1</span>;x[i];tmp*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="built_in">min</span>(tmp,x[i]);</span><br><span class="line">            <span class="keyword">int</span> wt=w[i]*num,vt=v[i]*num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=wt;j--)</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-wt]+vt);</span><br><span class="line">            x[i]-=num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>至此，基本模型已经讲完，其他变种模型以后有空再更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC-229解题报告</title>
      <link href="/2021/11/28/abc-229-jie-ti-bao-gao/"/>
      <url>/2021/11/28/abc-229-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc229">比赛传送门</a></p><p>赛时做出来五道题，涨大分（开心）</p><h1 id="a.-first-grid">A. First Grid</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个两行两列的矩阵，每个格子有黑和白两种颜色，至少有两个黑色格子，问黑色格子是否构成一个连通块（四连通）。</p></details><p>显然，如果左上、右下都是白色或右上、左下都是白色，那么不能构成，否则能。</p><h1 id="b.-hard-calculation">B. Hard Calculation</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有两个正整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 做加法，问是否需要进位。</p></details><p>大水题，一位一位地判断即可。</p><h1 id="c.-cheese">C. Cheese</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 <span class="math inline">\(n\)</span> 种奶酪，第 <span class="math inline">\(i\)</span> 种奶酪每千克能提供 <span class="math inline">\(a_i\)</span> 的美味度，但最多能使用 <span class="math inline">\(b_i\)</span> 千克。你一共最多能使用 <span class="math inline">\(W\)</span> 千克奶酪，问获得的总美味度最大是多少。</p><p><span class="math inline">\(n\le 3\times 10^5,W\le 3\times 10^8,b_i\le 1000\)</span></p></details><p>这题太坑了，我本来以为是个奇怪的背包，后来发现，既然每个物品的重量都是 <span class="math inline">\(1\)</span>，那不就是优先选最美味的奶酪的简单贪心吗？</p><h1 id="d.-longest-x">D. Longest X</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个只包含 <code>X</code> 和 <code>.</code> 的字符串 <span class="math inline">\(S\)</span>，你每次可以将一个 <code>.</code> 变成 <code>X</code>，问最多 <span class="math inline">\(K\)</span> 次操作后能获得的最长连续 <code>X</code> 字串的长度。</p><p><span class="math inline">\(|S|\le 2\times 10^5,K\le 2\times 10^5\)</span></p></details><p>如果 <span class="math inline">\(K\)</span> 次操作足以把所有的 <code>.</code> 都变成 <code>X</code>（即点的个数 <span class="math inline">\(\le K\)</span>），那么答案一定是 <span class="math inline">\(|S|\)</span>。</p><p>如果不能，那么容易发现，答案一定是把 <span class="math inline">\(K\)</span> 次操作全部用完。那么我们就从后往前扫，维护一个数组 <span class="math inline">\(t_i\)</span> 表示从第 <span class="math inline">\(i\)</span> 位开始往后用 <span class="math inline">\(K\)</span> 次操作能到达的最远位置（如果用不完 <span class="math inline">\(K\)</span> 次就到了末尾，那么就是结尾下标）。维护完后就可以直接取长度最大值输出。这里放一下维护的代码实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[i]为0则是点，为1则是X</span></span><br><span class="line"><span class="comment">//now表示当前的i能到达的最远位置</span></span><br><span class="line"><span class="comment">//nowf表示到达最远位置需要花费几次操作</span></span><br><span class="line"><span class="keyword">int</span> now=n,nowf=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    nowf+=(!a[i]);</span><br><span class="line">    <span class="keyword">while</span>(nowf&gt;k)</span><br><span class="line">        nowf-=(!a[now--]);</span><br><span class="line">    t[i]=now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e.-graph-destruction">E. Graph Destruction</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>给你一个 <span class="math inline">\(n\)</span> 个点、<span class="math inline">\(m\)</span> 条边的无向图，依次删除编号为 <span class="math inline">\(1-n\)</span> 的结点，每次删完后问剩下的连通块个数。</p></details><p>正着删边没法维护，我们考虑反向处理，每次加边。仔细像一下就会知道，每次加一个点，就要加上这个点与已有结点的边，即 <span class="math inline">\(\min(u,v)=i\)</span> 的边。所以我们按照 <span class="math inline">\(\min(u,v)\)</span> 排一个序，每加一个点就加上符合条件的边，然后用并查集维护连通性即可。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元学习笔记</title>
      <link href="/2021/11/26/cheng-fa-ni-yuan-xue-xi-bi-ji/"/>
      <url>/2021/11/26/cheng-fa-ni-yuan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>有很多题的答案可能会很大，这时候通常会让我们输出模一个数的结果。当我们的计算中只用到了加法，可以边加边模；只用到了乘法，可以边乘边模。但如果有除法，就不能边除边模了。这时候就要用到乘法逆元：<span class="math inline">\(a\times inv(b)\times inv(c)\%mod=\frac{a}{b\times c}\%mod\)</span>。</p><p>有了乘法逆元，在过程中想怎么模就怎么模，非常方便。</p><h2 id="计算">计算</h2><p>我们都知道，当模数为质数时，可以用快速幂求 <span class="math inline">\(a^{mod-2}\)</span>，否则可以用扩展欧几里得来求。</p><p>在组合数中，我们经常会用到阶乘逆元。当我们算出了 <span class="math inline">\(1-n\)</span> 的阶乘（<span class="math inline">\(\%mod\)</span>）后，就可以 <span class="math inline">\(O(n)\)</span>算出每一个阶乘逆元：首先用上面两种方法之一算出 <span class="math inline">\(inv(n!)\)</span>，我们知道 <span class="math inline">\(inv(n!)=\frac{1}{n!}\%mod\)</span>，那么 <span class="math inline">\(inv((n-1)!)=\frac{1}{n!}\times n\%mod=inv(n)\times n\%mod\)</span>，以此类推即可倒推出每一个数的阶乘逆元。</p><p>将其扩展为一般形式，就能得到线性求任意 <span class="math inline">\(n\)</span> 个数的逆元：将这 <span class="math inline">\(n\)</span> 个数求出前缀积，记为 <span class="math inline">\(s_1-s_n\)</span>，求出 <span class="math inline">\(inv(s_n)\)</span>，则 <span class="math inline">\(inv(s_{n-1})=inv(s_n)\times n\)</span>，以此类推，求出每一个 <span class="math inline">\(inv(s_i)\)</span>，即可得出 <span class="math inline">\(inv(a_i)=inv(s_i)\times s_{i-1}\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan学习笔记</title>
      <link href="/2021/11/26/tarjan-xue-xi-bi-ji/"/>
      <url>/2021/11/26/tarjan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>众所周知，Tarjan 可以用来求有向图的强连通分量，我们就不扯那些 dfs 生成树，前向边、返祖边之类的东西，直接步入正题。</p><h2 id="准备工作">准备工作</h2><p>Tarjan 算法本质上是一次 dfs 的过程，我们用 <span class="math inline">\(dfn[u]\)</span> 记录 <span class="math inline">\(u\)</span> 结点是第几次被 dfs 到的，用 <span class="math inline">\(low[u]\)</span> 记录 <span class="math inline">\(u\)</span> 能到达的所有结点中最小的 <span class="math inline">\(dfn\)</span>（包括自己）（详细定义：能够回溯到的最早的已经在栈中的结点。设以 <span class="math inline">\(u\)</span> 为根的子树为 <span class="math inline">\(subtree_u\)</span>。 定义为以下结点的 <span class="math inline">\(dfn\)</span> 的最小值：<span class="math inline">\(subtree_u\)</span> 中的结点；从 <span class="math inline">\(subtree_u\)</span> 通过<strong>一条</strong>不在搜索树上的边能到达的结点。）。<span class="math inline">\(dfn\)</span> 很好维护，dfs 的过程中记录一下即可，<span class="math inline">\(low\)</span> 的维护也不难，为 <span class="math inline">\(\min\limits_{u\to v}{low[v]}\)</span>，dfs 的过程中顺便维护即可。我们还需要一个栈 <span class="math inline">\(s\)</span> 来维护有哪些结点被 dfs 过，且还没计算出属于哪个强连通分量，用一个 <span class="math inline">\(vis\)</span> 数组来记录结点是否在栈中。</p><h2 id="正式开始">正式开始</h2><p>考虑从一个结点 <span class="math inline">\(u\)</span> 到另一个结点 <span class="math inline">\(v\)</span> 的过程中会发生什么。</p><ol type="1"><li>如果 <span class="math inline">\(v\)</span> 在栈中（即那个节点还没操作完），那么 <span class="math inline">\(v\)</span> 一定是 <span class="math inline">\(u\)</span> 的祖先，则用 <span class="math inline">\(dfn[v]\)</span> 更新 <span class="math inline">\(low[u]\)</span>。</li><li>如果 <span class="math inline">\(v\)</span> 访问过且不在栈中（即访问完了），那么装作无事发生。</li><li>如果 <span class="math inline">\(v\)</span> 还没被访问过，那么递归访问。</li></ol><p>将 <span class="math inline">\(u\)</span> 能直接到达的所有 <span class="math inline">\(v\)</span> 都算完后，就可以结算强连通分量了。我们发现，如果一个结点算完后 <span class="math inline">\(low[u]=dfn[u]\)</span>，则能告诉我们两个信息：</p><ol type="1"><li>这个结点能到达自己（出现环了！）</li><li>这个结点是这个环中最先到达的（我们称之为这个强连通分量的根）</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/cxm1024/img@master/uPic/wF29Sl.png" /></p><p>在这个图中，<span class="math inline">\(2\)</span> 号节点就是强连通分量 <span class="math inline">\({2,3,4,5,6,7}\)</span> 中的根。</p><p>这时候，我们就可以处理 <span class="math inline">\(u\)</span> 的强连通分量了！循环让结点出栈，直到栈顶元素为 <span class="math inline">\(u\)</span> 自己（因为 <span class="math inline">\(u\)</span> 是强连通分量的根，所以它一定是该强连通分量在栈中最靠前的），这些节点都在同一个以 <span class="math inline">\(u\)</span> 为根的强连通分量里。</p><p>如果一个结点算完后 <span class="math inline">\(low[u]\ne dfn[u]\)</span>，则意味着它能到达一个它的祖先，我们暂时先不处理它，也不出栈（还没算完强连通分量怎么能出栈呢），直接返回，到他的那个强连通分量的根的时候再去算强连通分量。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num记录当前一共遍历了几个结点，用于计算新结点的dfn</span></span><br><span class="line"><span class="comment">//col[i]记录第节点i在哪个强连通分量里，root[i]表示i所在强连通分量的根</span></span><br><span class="line"><span class="comment">//colnum记录当前一共算完了几个强连通分量，用来计算新强连通分量的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    s.<span class="built_in">push</span>(now),vis[now]=<span class="number">1</span>;</span><br><span class="line">    low[now]=dfn[now]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[e[i].to])</span><br><span class="line">            low[now]=<span class="built_in">min</span>(low[now],<span class="built_in">tarjan</span>(e[i].to));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[e[i].to])</span><br><span class="line">            low[now]=<span class="built_in">min</span>(low[now],dfn[e[i].to]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[now]==low[now]) &#123;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        col[now]=++colnum,root[now]=now;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">top</span>()!=now) &#123;</span><br><span class="line">            col[s.<span class="built_in">top</span>()]=colnum,root[s.<span class="built_in">top</span>()]=now;</span><br><span class="line">            vis[s.<span class="built_in">top</span>()]=<span class="number">0</span>,s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读">扩展阅读</h2><p>建议参考阅读<a href="https://blog.csdn.net/qq_34374664/article/details/77488976">这篇文章</a>的手动模拟算法的部分，会有更直观的理解。</p><p>有兴趣看看更严谨的说明，请上 <a href="https://oi-wiki.org/graph/scc/">oi-wiki</a> 观看。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-116-Div.2解题报告</title>
      <link href="/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/21/edu-cfr-116-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1606">比赛传送门</a></p><p>做出来五道题。</p><h1 id="a.-ab-balance">A. AB Balance</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>给你一个只含有 <code>a</code> 和 <code>b</code> 的字符串，问怎样通过修改尽可能少的字符，使得 <code>ab</code> 的数量和 <code>ba</code> 的数量相等。</p></details><p>显然，<code>ab</code> 的数量和 <code>ba</code> 的数量最多差 <span class="math inline">\(1\)</span>，而当开头字母和结尾字母相同时，<code>ab</code> 的数量等于 <code>ba</code> 的数量。如果不同，修改开头或结尾字母使它们相同即可。</p><h1 id="b.-update-files">B. Update Files</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 <span class="math inline">\(n\)</span> 个电脑和 <span class="math inline">\(k\)</span> 个数据线，其中一个电脑上有一个文件，每次可以通过数据线将文件从一个电脑传到另一个电脑上，耗时 <span class="math inline">\(1\)</span> 小时。问至少需要几个小时才能让所有电脑都有文件。</p></details><p>设当前有 <span class="math inline">\(x\)</span> 个电脑有文件：若 <span class="math inline">\(x&lt;=k\)</span>，则通过 <span class="math inline">\(x\)</span> 条数据线将 <span class="math inline">\(x\)</span> 翻倍；若 <span class="math inline">\(x&gt;k\)</span>，则通过 <span class="math inline">\(k\)</span> 条数据线将 <span class="math inline">\(x+=k\)</span>。暴力跑第一种情况（<span class="math inline">\(\log(k)\)</span>），剩下的情况算一下就行了。</p><h1 id="c.-banknotes">C. Banknotes</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有 <span class="math inline">\(n\)</span> 中不同面值的货币，每种货币的面值为 <span class="math inline">\(10^{a_i}\)</span>，问至少需要 <span class="math inline">\(x+1\)</span> <strong>个</strong>货币才能组成的价值最小的货币是多少。</p></details><p>暴力贪心模拟。先尽可能多地用面值最小的货币，再用面值第二小的货币，以此类推。具体实现细节比较多，在这里放个代码。</p><details class="note success"><summary><p>code</p></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            <span class="keyword">int</span> cur=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(x--)</span><br><span class="line">                cur*=<span class="number">10</span>;</span><br><span class="line">            a[i]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=k;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">                cnt=<span class="built_in">min</span>(cnt,a[i+<span class="number">1</span>]/a[i]<span class="number">-1</span>);</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*cnt;</span><br><span class="line">            k-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="d.-red-blue-matrix">D. Red-Blue Matrix</h1><details class="note info no-icon"><summary><p>problem</p></summary><p>有一个 <span class="math inline">\(n\times m\)</span> 的矩阵，每个格子有一个正整数，你需要对每一行染成红色或蓝色，使得能够找到竖线，让左边所有红格子都大于所有蓝格子的值，右边相反。输出染色方案以及竖线位置。</p><p><span class="math inline">\(\sum n\times m\le 10^6\)</span></p></details><p>假设我们已经知道了竖线的位置，如何分配红蓝呢？考虑以行为单位，以每一行的第一个元素为关键字进行从大到小的排序，则我们发现，一定是上面几行为红色，下面几行为蓝色，而这个两条分界线，一横一竖，左上、右上为红，左下、右下为蓝，则必须满足左上的最小值大于左下的最大值，右上的最大值小于右下的最小值。我们可以对矩阵分别求从左上、右下开始的前缀最小值和从左下、右上开始的前缀最大值。枚举横、竖线，然后就可以 <span class="math inline">\(O(1)\)</span> 判断了。总复杂度为 <span class="math inline">\(O(n\times m)\)</span>。</p><h1 id="e.-arena">E. Arena</h1><p>待更新......</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-755-Div.2解题报告</title>
      <link href="/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/"/>
      <url>/2021/11/15/cfr-755-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1589">比赛传送门</a></p><p>赛时AC三道，补题做出一道。</p><h1 id="a.-mathematical-addition">A. Mathematical Addition</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个正整数 <span class="math inline">\(u,v\)</span>，求一对合法的 <span class="math inline">\(x,y\)</span> 使得 <span class="math inline">\(\frac{x}{u}+\frac{y}{v}=\frac{x+y}{u+v}\)</span>。</p></details><p>解方程。</p><p><span class="math display">\[\begin{array}{c} \frac{vx+uy}{uv}=\frac{x+y}{u+v} \\ (vx+uy)(u+v)=uv(x+y) \\ uvx+u^2y+v^2x+uvy=uvx+uvy \\ u^2y+v^2x=0 \end{array}\]</span></p><p>则显然一组合法解为 <span class="math inline">\(\begin{cases}x=-u^2\\y=v^2\end{cases}\)</span></p><h1 id="b.-coloring-rectangles">B. Coloring Rectangles</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>有一个 <span class="math inline">\(n\times m\)</span> 的矩阵，每个方格均为红色。你可以任意多次的横切或纵切（必须贯穿整块），不能出现 <span class="math inline">\(1\times 1\)</span> 的矩阵，问切完后最少需要涂几个蓝色格子才能使得红色格子不相邻。</p><p>example: <span class="math inline">\(2\times 5\)</span></p><p><img data-src="https://espresso.codeforces.com/594fbc0a7f610ebbd39c222d75175364a33218ec.png" /></p></details><div class="tabs" id="solution"><ul class="nav-tabs"><li class="tab active"><a href="#solution-1">Solution 1</a></li><li class="tab"><a href="#solution-2">Solution 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="solution-1"><p>容易发现，把格子割成 <span class="math inline">\(1\times 3\)</span> 是最优的，于是考虑在不对后续操作产生影响的前提下，把它切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/LMrB4f.png" /></p><p>然后再切成这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/gZylEP.png" /></p><p>最后特判剩下的。注意切的时候要时刻堤防剩下一行或剩下一列的情况，防止出现 <span class="math inline">\(1\times 1\)</span>。</p></div><div class="tab-pane" id="solution-2"><p>通过找规律，我们可以发现，答案为 <span class="math inline">\(\lceil\frac{n\times m}{3}\rceil\)</span>。</p></div></div></div><h1 id="c.-two-arrays">C. Two Arrays</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>给你两个数组 <span class="math inline">\(a,b\)</span>，问能否通过把 <span class="math inline">\(a\)</span> 进行<strong>一次</strong>变换得到 <span class="math inline">\(b\)</span>。</p><p>变换方式：在 <span class="math inline">\(a\)</span> 数组中选出若干个数分别 <span class="math inline">\(+1\)</span>，然后随意排列顺序。</p></details><p>大水题。<span class="math inline">\(a,b\)</span> 分别排序，看是否每个 <span class="math inline">\(a\)</span> 数组的元素都等于 <span class="math inline">\(b\)</span> 的对应元素或等于 <span class="math inline">\(b\)</span> 的对应元素 <span class="math inline">\(+1\)</span>。</p><h1 id="d.-guess-the-permutation">D. Guess the Permutation</h1><details class="note info no-icon"><summary><p>Problem</p></summary><p>这是一道交互题。</p><p>有一个初始数组 <span class="math inline">\(a\)</span>，满足 <span class="math inline">\(a_i=i\)</span>，即 <span class="math inline">\({1,2,3...}\)</span>。现在有 <span class="math inline">\(1&lt;=i&lt;j&lt;=k&lt;=n\)</span>，将 <span class="math inline">\([i,j-1],[j,k]\)</span> 分别翻转。你需要通过不超过 <span class="math inline">\(40\)</span> 次询问得到 <span class="math inline">\(i,j,k\)</span> 的值。</p><p>每一次询问你可以给出 <span class="math inline">\(l,r\)</span>，得到 <span class="math inline">\([l,r]\)</span> 中的逆序对个数。</p><p><span class="math inline">\(n\le 10^9(\log_2(10^9)\approx 30)\)</span></p></details><ol type="1"><li>用一次 <span class="math inline">\(\log\)</span> 找到 <span class="math inline">\(k\)</span>：二分 <span class="math inline">\(mid\)</span>，询问 <span class="math inline">\([mid,r]\)</span> 中逆序对个数，如果不为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(k\)</span> 在 <span class="math inline">\([mid+1,r]\)</span> 中，否则在 <span class="math inline">\([l,mid]\)</span> 中。</li><li>用两次询问 <span class="math inline">\([1,k]\)</span> 和 <span class="math inline">\([1,k-1]\)</span> 来获得 <span class="math inline">\(j\)</span> 的位置：一段降序区间 <span class="math inline">\([l,r]\)</span> 的逆序对数减去 <span class="math inline">\([l,r-1]\)</span> 的逆序对数等于 <span class="math inline">\(len-1\)</span>，于是 <span class="math inline">\([1,k]-[1,k-1]=len_{[j,k]}-1\)</span>（<span class="math inline">\(j\)</span> 前面的都被抵消了），用 <span class="math inline">\(k-(len-1)\)</span> 即可求出 <span class="math inline">\(j\)</span>。</li><li>同理用两次询问 <span class="math inline">\([1,j-1]\)</span> 和 <span class="math inline">\([1,j-2]\)</span> 来获得 <span class="math inline">\(i\)</span> 的位置。</li></ol><p>询问次数约为 <span class="math inline">\(\log(n)+4\)</span>。</p><p>不开 <code>long long</code> 见祖宗（逆序对个数最多有 <span class="math inline">\(n^2\)</span> 级别）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3383【模板】线性筛-题解</title>
      <link href="/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/"/>
      <url>/2021/10/21/p3383-mo-ban-xian-xing-shai-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>这道题是线性筛的模板题，所以我们考虑怎么不用线性筛。</p><p>我们都知道有一种筛法叫埃拉托色尼筛，简称埃氏筛，它比线性筛好写，也更好理解，但它过不了这道题，那怎么办呢？我们可以用 <span class="math inline">\(bitset\)</span> 代替 bool 数组来进行优化，这造成的常数优化非常显著，以至于开了 <code>ios::sync_with_stdio(false)</code> 之后能轻松过掉这道题，和线性筛的时间总差距只有 <span class="math inline">\(0.5s\)</span>，可以说是非常优秀了。</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,prime[<span class="number">6000000</span>];</span><br><span class="line">bitset&lt;100000000&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">flip</span>();p[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) &#123;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;MAXN;j+=i)</span><br><span class="line">                p[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        cout&lt;&lt;prime[x]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-53-Div.2解题报告</title>
      <link href="/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/14/edu-cfr-53-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<h1 id="a.-diverse-substring">A. Diverse Substring</h1><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>定义一个字符串为多变的，当且仅当字符串中没有一个字符的出现次数严格大于 <span class="math inline">\(n/2\)</span>。给定一个只由小写字母构成的字符串，问是否能找出一个多变的字串，如果能，任意输出一个。</p><p><span class="math inline">\(n\le 1000\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p>只有两个不同字符的字符串时多变的，所以只要给定的字符串中包含至少两个字符就一定可以，输出相邻两个不同字符即可。</p><h1 id="b.-vasya-and-books">B. Vasya and Books</h1><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>有一摞书，从上到下依次编号为 <span class="math inline">\(a_1,a_2,a_3...\)</span>，现在 Vasya 想把它们分 <span class="math inline">\(n\)</span> 次挪到别的地方，每次他会告诉你他想挪的书的编号，如果这本书还没有被挪动，他将会把这本书以上的书（包括这本书）一块搬走。对于每次挪动，回答他搬了多少本书（没搬输出 0）。</p><p><span class="math inline">\(n\le 2\times 10^5\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\)</span></h2><p>开一个桶记录每一本书的位置，记录当前搬到那个位置了，每搬一次就更新一下，减一下即可。</p><h1 id="c.-vasya-and-robot">C. Vasya and Robot</h1><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>有一个机器人，初始在 <span class="math inline">\((0,0)\)</span> 点，给你一个长度为 <span class="math inline">\(n\)</span> 的操作序列，每次让机器人向上、下、左、右中的一个方向走一步，你需要修改连续的一段操作序列（这一段中的操作不必全部都修改），使它最终走到 <span class="math inline">\((x,y)\)</span> 点，问修改的操作序列的最短长度。（不是很严谨，序列长度的详细定义见原题面）</p><p><span class="math inline">\(n\le 2\times 10^5\)</span></p><h2 id="solution-2"><span class="math inline">\(Solution\)</span></h2><p>如果修改一个长度为 <span class="math inline">\(len\)</span> 的序列可以使它走到终点，那么一定存在一种长度为 <span class="math inline">\(len+1\)</span> 的方案也能走到终点（大不了就加一个空修改），于是我们发现这是可以二分的。二分最终修改的长度 <span class="math inline">\(len\)</span>，对于一个长度，我们需要 <span class="math inline">\(O(n)\)</span> 判断是否可行，怎么判断呢？对于每一段长度为 <span class="math inline">\(len\)</span> 的修改，判断不考虑这段修改后机器人会走到哪个位置，再从这个位置开始，判断随便走 <span class="math inline">\(len\)</span> 步能否走到终点（反正允许修改这一段，那想怎么改就怎么改）。</p><p>实现上，我们维护一个走的位置的前缀和和后缀和，就可以 <span class="math inline">\(O(1)\)</span> 判断去除这段修改后机器人会走到那个位置，然后再考虑一些细节问题即可。</p><h1 id="d.-berland-fair">D. Berland Fair</h1><h2 id="problem-3"><span class="math inline">\(Problem\)</span></h2><p><del>有一个人前来买东西。</del>Polycarp 带了 <span class="math inline">\(T\)</span> 元钱，去逛商铺。有 <span class="math inline">\(n\)</span> 家商铺顺时针排成一圈，编号 <span class="math inline">\(1-n\)</span>，第 <span class="math inline">\(i\)</span> 个商铺卖一种价格为 <span class="math inline">\(a_i\)</span> 的商品（数量有无限个）。Polycarp 从一号商铺开始，只要钱足够，就买<strong>一件商品</strong>，否则跳过这家店，直到他一个商品也买不了为止，问他一共会买多少件商品。</p><p><span class="math inline">\(n\le 2\times 10^5,T\le 10^{18},a_i\le 10^9\)</span></p><h2 id="solution-3"><span class="math inline">\(Solution\)</span></h2><p>先算出来买一圈要花多少钱，让他买尽可能多的圈。为什么他买不了下一圈了呢？一定是到某一个商铺是他买不起了。现在买不起，以后也不可能买的起，于是直接把这个商铺删掉，不考虑。于是我们暴力跑一圈，看看是哪些商铺买不起，把它们都删掉，删完后再让他转圈，知道所有的商品全都被删完为止。由于每一次至少删掉一个商品，最多删 <span class="math inline">\(n\)</span> 次，每次 <span class="math inline">\(O(n)\)</span>，总时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。<del>（别问我为什么能过 <span class="math inline">\(2\times 10^5\)</span>，我也不知道）</del>（经过同学推导，复杂度为 <span class="math inline">\(O(n\log(n))\)</span>）</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-115-Div.2解题报告</title>
      <link href="/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/13/edu-cfr-115-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 3道，补题做出来一道</p><h1 id="a.-computer-game">A. Computer Game</h1><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>有一个 <span class="math inline">\(2\times n\)</span> 的01矩阵，1为障碍，你要从 <span class="math inline">\((1,1)\)</span> 走到 <span class="math inline">\((2,n)\)</span>，每一步只能向右、上、下、右上、右下走，问能不能走到。</p><p><span class="math inline">\(t\le 100,n\le 100\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p>如果有一列的两个数都是1，则一定会被堵住，否则一定能到，因为每一列至少有1个0，而我们可以斜着走，所以一定可以从一列走到下一列。</p><h1 id="b.-groups">B. Groups</h1><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>有 <span class="math inline">\(n\)</span> 个学生（<span class="math inline">\(n\)</span> 是偶数），每个学生在星期一到星期五会有若干天空闲，问能否将学生平均分成两组，使得每一组能够挑选一天组织社团活动（两组选的日子不能相同）。</p><p><span class="math inline">\(t\le 10^4,\sum n\le 10^5\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\)</span></h2><p>由于一周只有五天，考虑枚举选的是哪两天，然后判断可不可行。判断就需要一点脑洞了，我的方法是如果两天的空闲学生人数都 <span class="math inline">\(\ge n/2\)</span>，且交集能够覆盖所有学生（即每个学生都在这两天中至少有一天空闲），就一定可行。</p><h1 id="c.-delete-two-elements">C. Delete Two Elements</h1><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>给你一个长度为 <span class="math inline">\(n\)</span> 的序列，问有多少种选出两个数的方案使得删除它们后平均值不变。</p><p><span class="math inline">\(t\le 10^4,\sum n\le 2\times 10^5,a_i\le 10^9\)</span></p><h2 id="solution-2"><span class="math inline">\(Solution\)</span></h2><p>要想删除后平均值不变，取出的两个数的平均值必须等于全部的平均值，即两个数的和必须等于全部平均值的两倍，如果数列的平均值 <span class="math inline">\(\times 2\)</span> 不是整数则一定不可行（选出的两个数的和一定是整数），我们如果已经选出了一个数，就可以知道另一个数应该是多少，于是我们可以想到开一个桶，但 <span class="math inline">\(10^9\)</span> 开不了桶怎么办？用 map 即可。</p><h1 id="d.-training-session">D. Training Session</h1><h2 id="problem-3"><span class="math inline">\(Problem\)</span></h2><p>教练有 <span class="math inline">\(n\)</span> 道题，每道题有一个算法主题 <span class="math inline">\(x\)</span> 和难度 <span class="math inline">\(y\)</span>，你需要选出恰好 <span class="math inline">\(3\)</span> 道题使得 <span class="math inline">\(x\)</span> 互不相同<strong>或</strong> <span class="math inline">\(y\)</span> 互不相同。问有多少种选法。保证没有两个完全相同的题。</p><p><span class="math inline">\(t\le 50000,\sum n\le 2\times 10^5,x,y\le n\)</span></p><h2 id="solution-3"><span class="math inline">\(Solution\)</span></h2><p>考虑用总方案数减去不合法方案数，不合法的方案就是有两个题的 <span class="math inline">\(x\)</span> 相同，有两个题的 <span class="math inline">\(y\)</span> 相同，表现在坐标系上，每一个点的贡献就是横坐标相同的点数<span class="math inline">\(\times\)</span>纵坐标相同的点数，可以开两个桶维护。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EDU-CFR-114-Div.2解题报告</title>
      <link href="/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/12/edu-cfr-114-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时AC 2道题，赛后补题做出来一道（赛时交了4发，赛后交了十几发才过，太残忍了）</p><p><img data-src="https://cdn.jsdelivr.net/gh/caoxuanming/img@master/uPic/wuJBv8.png" /></p><p>总体难度比较高，可能题解会比较冗长</p><h1 id="a.-regular-bracket-sequences">A. Regular Bracket Sequences</h1><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>输入 <span class="math inline">\(n\)</span>，输出 <span class="math inline">\(n\)</span> 个互不相同的、合法的、长度为 <span class="math inline">\(2n\)</span> 的括号序列。</p><p><span class="math inline">\(t\le 50,n\le 50\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\ 1\)</span></h2><p>update: 我的解法非常复杂，可以直接看 <span class="math inline">\(Solution\ 2\)</span> CF官方题解的做法（想看看我的憨批做法也行）</p><p>考虑一开始在 <span class="math inline">\((0,0)\)</span> 点，左括号往右上走，右括号往右下走，则合法的括号序列一定在 <span class="math inline">\(x\)</span> 轴之上。现在考虑最简单的括号序列：<code>(((...(())...)))</code>，即 <span class="math display">\[{+1,+1,...,+1,+1,-1,-1,...,-1,-1}\]</span> 展现在坐标系上，就是一个山峰形，那么我们考虑将山峰的顶砍一刀，让它凹进去，变成 <span class="math display">\[{+1,+1,...,+1,-1,+1,-1,...,-1,-1}\]</span> 这样就得到了下一种合法序列，再下一种就再把左边的山峰砍一刀（自始至终都不管右边），每次砍左边的山峰，由于最初的山峰高度为 <span class="math inline">\(n\)</span>，每砍一刀左边的山峰高度 <span class="math inline">\(-1\)</span>，看 <span class="math inline">\(n-1\)</span> 刀的最终高度为 <span class="math inline">\(1\)</span>，加上最初的单峰山，就得到了 <span class="math inline">\(n\)</span> 种合法括号序列。</p><p>实现上，把最初的 <span class="math inline">\({+1,+1,...,+1,+1,-1,-1,...,-1,-1}\)</span> 序列存到数组里，每次交换一对 <span class="math inline">\(+1,-1\)</span> 变成 <span class="math inline">\(-1,+1\)</span>，再转换成括号序列输出即可。</p><h2 id="solution-2"><span class="math inline">\(Solution\ 2\)</span></h2><p>CF官方题解，让我觉得我的解法太复杂了。直接引用英文原版，肯定能看懂。</p><blockquote><p>start with the sequence <code>()()()()...</code>; merge the first <span class="math inline">\(4\)</span> characters into one sequence to get <code>(())()()...</code>; merge the first <span class="math inline">\(6\)</span> characters into one sequence to get <code>((()))()...</code>; and so on.</p></blockquote><h1 id="b.-combinatorics-homework">B. Combinatorics Homework</h1><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>你有 <span class="math inline">\(a\)</span> 个 <code>A</code>、<span class="math inline">\(b\)</span> 个 <code>B</code>、<span class="math inline">\(c\)</span> 个 <code>C</code>，问能否组成“恰好有 <span class="math inline">\(m\)</span> 对相邻两个字符相同”的字符串。</p><p><span class="math inline">\(t\le 10^4,a,b,c,m\le 10^8\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p><del>显然</del>，只要 <span class="math inline">\(m\)</span> 在“相邻两个字符相同的对数”的最大值和最小值之间，就一定可以。最大值很简单，若干个 A、若干个 B、若干个 C 这样排，<span class="math inline">\((a-1)+(b-1)+(c-1)\)</span> 就行（别忘了 <span class="math inline">\(\max(0,...)\)</span>），问题是最小值怎么求呢？我们可以发现一种典型情况：最大值太大，两个较小值用尽浑身解数拆散，最大值也还有剩余；还有一种情况就是两个较小值不需要用全部的力气拆散，数量最多的字母已经被拆得一对也没有了。针对后者，我们很轻松的就能<del>猜出来</del>一定总能互相拆的一对也不剩，无需多考虑，而针对前者，需要算出来两个数量较少的字母用尽浑身解数能把数量最大的拆得还剩几对。我们发现 <code>ABABAAAA</code> 和 <code>AABAABAA</code> 是一样的，于是我们又可以得到，尽可能多的拆散，就是把较少的两种字母分散开插进最多的字母里，怎么插无所谓，只要它们自己不连在一起就行。这样我们能够得到，针对前一种情况，能组成的对数的最小值为 <span class="math inline">\(max-1-(all-max)\)</span>（感性理解一下），将它和 <span class="math inline">\(m\)</span> 比较即可。</p><h1 id="c.-slay-the-dragon">C. Slay the Dragon</h1><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>你有 <span class="math inline">\(n\)</span> 个勇士，每个勇士有一定的能力值 <span class="math inline">\(a_i\)</span>，每组数据给出一条龙的防御力 <span class="math inline">\(x\)</span> 和攻击力 <span class="math inline">\(y\)</span>，你需要派出<strong>一个</strong>能力值 <span class="math inline">\(\ge x\)</span> 的勇士来攻击龙，剩余的勇士防御，防御的勇士能力值之和必须 <span class="math inline">\(\ge y\)</span>。你每次可以花费 <span class="math inline">\(1\)</span> 的代价将一个勇士的能力值提高 <span class="math inline">\(1\)</span>，对于每组数据，回答最少花费。<strong>注意：每组数据相互独立，每组数据提高的勇士能力值不会保存到下一组数据。</strong></p><h2 id="solution-3"><span class="math inline">\(Solution\)</span></h2><p><strong>这题竟然卡常！！！</strong>（痛骂 Codeforces）可能需要用 <code>ios::sync_with_stdio(false)</code> 才能过</p><p>很容易想到，每次可以用比龙的防御力小的能力值最大的人去打龙（给他提高一点），或是用第一个比龙的防御力大的人去打龙（不需要提高），然后再按需提高剩下的人（提高谁都没有区别，只需要考虑他们的和就行），取这两种方案中花费较小的一种。然后你就会发现细节巨多，当调了 n 遍终于调出错来时，你就会发现</p><blockquote><p>Time limit exceeded on test 6</p></blockquote><p>加上 <code>ios::sync_with_stdio(false)</code> 或快读可过（如果你是 <code>scanf</code> 党，当我没说）。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-746-Div.2解题报告</title>
      <link href="/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/09/cfr-746-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>VP做出来一道，补题又做出来3道。</p><h1 id="a.-gamer-hemose">A. Gamer Hemose</h1><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>你有 <span class="math inline">\(n\)</span> 个武器，要打一个体力为 <span class="math inline">\(H\)</span> 的敌人，第 <span class="math inline">\(i\)</span> 个武器可以对敌人造成 <span class="math inline">\(a_i\)</span> 的伤害，每把武器不能连续使用两次，问至少需要多少次才能打败敌人。</p><p><span class="math inline">\(t\le 10^5,\sum n\le 2\times 10^5\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p>（读错题意调了半天）</p><p>肯定是最厉害的武器和次厉害的武器轮番上阵，把它们看作一组，首先算要用多少组，剩余的再单独处理。</p><p>时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h1 id="b.-hemose-shopping">B. Hemose Shopping</h1><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>你有一个数组，每次操作只能将距离 <span class="math inline">\(\ge x\)</span> 的两个数交换，问能否排好序。</p><p><span class="math inline">\(t\le 10^5,\sum n\le 2\times 10^5\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\)</span></h2><p>由于每次距离只能 <span class="math inline">\(\ge x\)</span>，中间可能有一段区间是无论如何也动不了的，为 <span class="math inline">\([n-m+1,m]\)</span>。假设不用考虑这段区间，则剩下的分成左右两边，每次只能交换左右两边的数，是否能排好序呢？能。我们肯定能交换左右两边的数，所以考虑如何交换同一边的数（假设是 <span class="math inline">\(a_x,a_y\)</span>），我们需要一个在另一边的辅助变量 <span class="math inline">\(t\)</span>，就可以用我们刚学编程是学的用辅助变量来交换变量的方法交换，而 <span class="math inline">\(t\)</span> 的值也不会改变。</p><p>如此，两边的就不用管了，反正总能排好序。接下来考虑中间的部分，因为完全动不了，我们就要求它们已经排好序了。这样就结束了？不。（我就被这个坑了）它们还需要在排好序的数组里处于正确的位置，即，对于排好序的数组 <span class="math inline">\(b\)</span>，<span class="math inline">\(\forall i\in[n-m+1,m],a_i=b_i\)</span>。</p><h1 id="c.-bakry-and-partitioning">C. Bakry and Partitioning</h1><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>给你一棵有点权的树，问是否能割断至少 <span class="math inline">\(1\)</span> 条、至多 <span class="math inline">\(k-1\)</span> 条边，将树分成若干个连通块，使得每个连通块中点权的异或和相等。</p><p><span class="math inline">\(t\le 5\times 10^4,\sum n\le 2\times 10^5\)</span></p><h2 id="solution-2"><span class="math inline">\(Solution\)</span></h2><p>如果异或和是 <span class="math inline">\(0\)</span>，随便割一条边即可，因为两边的异或和相等，异或起来的结果才能等于 <span class="math inline">\(0\)</span>。</p><p>如果疑惑和不是 <span class="math inline">\(0\)</span>，而是 <span class="math inline">\(x\)</span>，我们就需要将树分成三个异或和都为 <span class="math inline">\(x\)</span> 的连通块。为什么不是五个、七个？因为可以合并三个异或和都为 <span class="math inline">\(x\)</span> 的连通块得到一个异或和为 <span class="math inline">\(x\)</span> 的连通块。具体实现中跑一边 dfs 即可，跑的过程中一发现出现异或和为 <span class="math inline">\(x\)</span> 的连通块，马上把它分割出去，统计分割了多少次，如果多于两次就成立，否则不成立。</p><h1 id="d.-hemose-in-icpc">D. Hemose in ICPC ?</h1><h2 id="problem-3"><span class="math inline">\(Problem\)</span></h2><p><strong>这是一道交互题。</strong> 给你一棵有边权的树，但你不知道边权是多少，每次你可以询问一个点集，会得到这个点集中距离最远的两个点的距离（即直径）。距离定义为路径中所有边权的 <span class="math inline">\(\gcd\)</span>。你需要在 <span class="math inline">\(12\)</span> 次询问以内输出整棵树直径的两个端点。</p><p><span class="math inline">\(n\le 10^3\)</span></p><h2 id="solution-3"><span class="math inline">\(Solution\)</span></h2><p>有一个很重要的结论，<span class="math inline">\(a\ge gcd(a,b)\)</span>，这告诉我们树的“直径”一定只有一条边，所以问题转化为我们要求得最长的边的两个端点。我们先花费一次询问得知整棵树的直径（即最长的边），设它为 <span class="math inline">\(x\)</span>。</p><p>假设我们以 <span class="math inline">\(1\)</span> 号结点为根，那么每一条边唯一对应一个点，所以我们用一个点来代表这个点与它父亲结点之间的边。考虑我们先对所有点按照 dfs 序排序，然后二分选相邻的点集（一定要加上前面的），这样它的直径一定是这个点集中最长的边，如果它是 <span class="math inline">\(x\)</span>，那么递归再这段，否则递归后面的段（也加上前面的）。</p><p>为什么选的点要相邻呢？以下图为例，如果我们问 <span class="math inline">\({1,3,4}\)</span>，它返回 <span class="math inline">\(10\)</span>，我们也不知道是否真的有一条边的权值等于 <span class="math inline">\(10\)</span>，这对我们获知答案没有什么意义。</p><p><img data-src="https://i.loli.net/2021/10/09/ahmk2zd1EYy5Rrb.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CFR-745-Div.2解题报告</title>
      <link href="/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/"/>
      <url>/2021/10/08/cfr-745-div-2-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>没打比赛，赛后做出3道。 这场比赛题目质量很高，非常巧妙。</p><h1 id="a.-cqxym-count-permutations">A. CQXYM Count Permutations</h1><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>求有多少 <span class="math inline">\(2n\)</span> 的排列满足存在超过 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(p_i&lt;p_{i+1}\)</span>，答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p><p><span class="math inline">\(\sum n\le 10^5\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p>这题就非常巧妙了，当我们使劲想想不出来时，正难则反，考虑有多少 <span class="math inline">\(2n\)</span> 的排列满足存在超过 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(p_i&gt;p_{i+1}\)</span>，这时候我们就会发现：这不是一样吗？没错，答案就是 <span class="math inline">\(\frac{(2n)!}{2}\)</span>。</p><h1 id="b.-diameter-of-graph">B. Diameter of Graph</h1><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>每次给定 <span class="math inline">\(n,m,k\)</span> 问能不能构造一个 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\(m\)</span> 条边的简单无向图使得图的直径小于 <span class="math inline">\(k-1\)</span>。</p><p>一张图的直径定义为最短路最长的两个点的最短路长度。</p><p><span class="math inline">\(t\le 10^5,n,m,k\le 10^9\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\)</span></h2><p>始终没有明白为什么要“小于 <span class="math inline">\(k-1\)</span>”，直接 <code>k-=2</code> 后变成 <span class="math inline">\(\le k\)</span>。</p><p>考虑这道题可以转化为构造一个 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\(m\)</span> 条边的直径尽可能小的图。</p><p>首先判断能否连通，即 <span class="math inline">\(m&lt;n-1\)</span>，然后判断是否必须有重边，即 <span class="math inline">\(m&gt;\frac{n(n-1)}{2}\)</span>，如果出现这两种情况则为不合法，直接排除。而且，如果 <span class="math inline">\(k&lt;1\)</span>，也直接排除，因为不可能存在两个点的距离 <span class="math inline">\(&lt;1\)</span>。</p><p>然后考虑能否构造出直径为 <span class="math inline">\(1\)</span> 的图。我们发现只有完全图的直径为 <span class="math inline">\(1\)</span>，因为任意两个点都可以直径过 <span class="math inline">\(1\)</span> 条边到达。所以，如果 <span class="math inline">\(k=1\)</span>，只有完全图才成立，否则不成立。接着在考虑能否构造出直径为 <span class="math inline">\(2\)</span> 的图。我们会发现只要图连通，就一定能构造出来直径为 <span class="math inline">\(2\)</span> 的图，因为菊花图的直径为 <span class="math inline">\(2\)</span>，而在菊花图上加边不会让直径变大，所以只要 <span class="math inline">\(k&gt;1\)</span> 就一定能构造出来。</p><h1 id="c.-portal">C. Portal</h1><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>给定一张 <span class="math inline">\(n\times m\)</span> 的矩阵，每个格子有空和黑曜石两种状态，你可以花费一步操作将空格子变成黑曜石或将黑曜石变成空格子。一个子矩阵可以形成传送门需要具备以下条件：</p><ol type="1"><li>高度 <span class="math inline">\(\ge 5\)</span>，宽度 <span class="math inline">\(\ge 4\)</span>。注意，传送门不能横过来看，宽就是宽，高就是高。</li><li>中间部分必须全是空格子。</li><li>四周边框必须全是黑曜石。</li><li>四角不限。</li></ol><p>问至少需要几次操作才能搭建一个传送门。</p><p><span class="math inline">\(\sum n\le 400,\sum m\le 400\)</span></p><h2 id="solution-2"><span class="math inline">\(Solution\)</span></h2><p>这道题我从9月30号读题一直到10月8号才做出来，历尽了千辛万苦。</p><p>记输入的矩阵为 <span class="math inline">\(a\)</span>，用 <span class="math inline">\(0\)</span> 表示空格，<span class="math inline">\(1\)</span> 表示黑曜石。</p><p>首先预处理出每一行的前缀和，以便我们 <span class="math inline">\(O(1)\)</span> 查询一段横向区间里有多少块黑曜石，我们用 <span class="math inline">\(s[i][j]\)</span> 表示。</p><p>然后，枚举合法的左右边界（<span class="math inline">\(r-l\ge 3\)</span>），我们记 <span class="math inline">\(len=r-l-1\)</span> 表示中间部分的宽度，对于每一个左右边界，记 <span class="math inline">\(t[i]\)</span> 表示前 <span class="math inline">\(i\)</span> 行全变成 <span class="math inline">\(100...001\)</span> 的格式需要花费的步数，本质上是竖向的前缀和：<span class="math inline">\(t[i]=t[i-1]+(s[i][r-1]-s[i][l])+(2-a[i][l]-a[i][r])\)</span>。然后我们考虑如何 <span class="math inline">\(O(1)\)</span> 计算搭建一段以 <span class="math inline">\(u\)</span> 为上边界，<span class="math inline">\(d\)</span> 为下边界的传送门的步数：首先让中间和左右边框合法（<span class="math inline">\(t[d-1]-t[u]\)</span>），再让上边框合法（<span class="math inline">\(len-(s[u][r-1]-s[u][l])\)</span>），同理再让下边框合法（<span class="math inline">\(len-(s[d][r-1]-s[u][l])\)</span>）。加起来，则为：</p><p><span class="math inline">\(t[d-1]-t[u]+(len-(s[d][r-1]-s[d][l]))+(len-(s[u][r-1]-s[u][l]))\)</span></p><p>将与 <span class="math inline">\(u,d\)</span> 有关的项分开，方便处理：</p><p><span class="math inline">\(2len+(t[d-1]-s[d][r-1]+s[d][l])-(t[u]+s[u][r-1]-s[u][l])\)</span></p><p>我们记 <span class="math inline">\(f[i]=t[i-1]-s[i][r-1]+s[i][l],g[i]=t[i]+s[i][r-1]-s[i][l]\)</span>，则上式可简化为 <span class="math inline">\(2len+f[d]-g[u]\)</span>。</p><p>现在考虑从上到下扫下边界，对于每一个下边界，我们要使步数尽可能小，即让 <span class="math inline">\(2len+f[d]-g[u]\)</span> 尽可能小，就要让 <span class="math inline">\(g[u]\)</span> 尽可能大，于是我们从上到下扫的时候，记录以下当前扫过的 <span class="math inline">\(g[u]\)</span> 的最大值 <span class="math inline">\(maxn[i]=\max(maxn[i-1],g[i])\)</span>，那么对于每一个下边界 <span class="math inline">\(d\)</span>，最小步数就为 <span class="math inline">\(2len+f[d]-maxn[d-4]\)</span>，整个算法的时间复杂度就可以做到 <span class="math inline">\(O(m^2n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OI术语中英对照表</title>
      <link href="/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/"/>
      <url>/2021/10/03/oi-zhu-yu-zhong-ying-dui-zhao-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="mathcala"><span class="math inline">\(\mathcal{A}\)</span></h1><ul><li><span class="math inline">\(assume\)</span> 设，令，假设</li><li><span class="math inline">\(axis\)</span> 坐标轴</li></ul><h1 id="mathcalb"><span class="math inline">\(\mathcal{B}\)</span></h1><ul><li><span class="math inline">\(block\)</span> 方块，格</li></ul><h1 id="mathcalc"><span class="math inline">\(\mathcal{C}\)</span></h1><ul><li><span class="math inline">\(column\)</span> 列</li><li><span class="math inline">\(condition\)</span> 条件</li><li><span class="math inline">\(corner\)</span> 角，角落</li><li><span class="math inline">\(calculate\)</span> 计算</li><li><span class="math inline">\(complexity\)</span> 复杂度</li><li><span class="math inline">\(contributed\)</span> 贡献</li><li><span class="math inline">\(communication\)</span> 通信</li><li><span class="math inline">\(challenge\)</span> 挑战</li><li><span class="math inline">\(capacity\)</span> 容量</li><li><span class="math inline">\(coordinate\)</span> 坐标</li></ul><h1 id="mathcald"><span class="math inline">\(\mathcal{D}\)</span></h1><ul><li><span class="math inline">\(diameter\)</span> 直径</li><li><span class="math inline">\(directed\)</span> 有向的</li></ul><h1 id="mathcale"><span class="math inline">\(\mathcal{E}\)</span></h1><ul><li><span class="math inline">\(exceed\)</span> 超过</li><li><span class="math inline">\(enumerate\)</span> 枚举</li></ul><h1 id="mathcalf"><span class="math inline">\(\mathcal{F}\)</span></h1><ul><li><span class="math inline">\(figure\)</span> 插图</li><li><span class="math inline">\(flow\)</span> 流量</li></ul><h1 id="mathcalg"><span class="math inline">\(\mathcal{G}\)</span></h1><ul><li><span class="math inline">\(guarantee\)</span> 保证</li></ul><h1 id="mathcalh"><span class="math inline">\(\mathcal{H}\)</span></h1><h1 id="mathcali"><span class="math inline">\(\mathcal{I}\)</span></h1><ul><li><span class="math inline">\(intersection\)</span> 交集，交点</li></ul><h1 id="mathcalj"><span class="math inline">\(\mathcal{J}\)</span></h1><h1 id="mathcalk"><span class="math inline">\(\mathcal{K}\)</span></h1><h1 id="mathcall"><span class="math inline">\(\mathcal{L}\)</span></h1><h1 id="mathcalm"><span class="math inline">\(\mathcal{M}\)</span></h1><ul><li><span class="math inline">\(minimum\)</span> 最少的</li><li><span class="math inline">\(maximum\)</span> 最多的</li><li><span class="math inline">\(matrix\)</span> 矩阵</li><li><span class="math inline">\(multiedges\)</span> 重边</li></ul><h1 id="mathcaln"><span class="math inline">\(\mathcal{N}\)</span></h1><h1 id="mathcalo"><span class="math inline">\(\mathcal{O}\)</span></h1><ul><li><span class="math inline">\(otherwise\)</span> 否则</li><li><span class="math inline">\(overlap\)</span> 重叠</li></ul><h1 id="mathcalp"><span class="math inline">\(\mathcal{P}\)</span></h1><ul><li><span class="math inline">\(precalculate\)</span> 预处理</li><li><span class="math inline">\(prefix\)</span> 前缀</li><li><span class="math inline">\(permutation\)</span> 排列</li><li><span class="math inline">\(preceding\)</span> 前面的</li><li><span class="math inline">\(positive\)</span> 正的</li></ul><h1 id="mathcalq"><span class="math inline">\(\mathcal{Q}\)</span></h1><h1 id="mathcalr"><span class="math inline">\(\mathcal{R}\)</span></h1><ul><li><span class="math inline">\(rectangle\)</span> 长方形，矩阵</li><li><span class="math inline">\(row\)</span> 行</li><li><span class="math inline">\(resources\)</span> 资源</li></ul><h1 id="mathcals"><span class="math inline">\(\mathcal{S}\)</span></h1><ul><li><span class="math inline">\(satisfy\)</span> 满足（条件）</li><li><span class="math inline">\(suffix\)</span> 后缀</li><li><span class="math inline">\(submatrix\)</span> 子矩阵</li></ul><h1 id="mathcalt"><span class="math inline">\(\mathcal{T}\)</span></h1><ul><li><span class="math inline">\(therefore\)</span> 因此</li><li><span class="math inline">\(tutorial\)</span> 题解</li></ul><h1 id="mathcalu"><span class="math inline">\(\mathcal{U}\)</span></h1><ul><li><span class="math inline">\(utilization\)</span> 利用</li><li><span class="math inline">\(undirected\)</span> 无向的</li></ul><h1 id="mathcalv"><span class="math inline">\(\mathcal{V}\)</span></h1><h1 id="mathcalw"><span class="math inline">\(\mathcal{W}\)</span></h1><h1 id="mathcalx"><span class="math inline">\(\mathcal{X}\)</span></h1><h1 id="mathcaly"><span class="math inline">\(\mathcal{Y}\)</span></h1><h1 id="mathcalz"><span class="math inline">\(\mathcal{Z}\)</span></h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFR-744-Div.3解题报告</title>
      <link href="/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/"/>
      <url>/2021/09/30/cfr-744-div-3-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>赛时 AC 2道题，掉大分（哭）</p><h1 id="a.-casimirs-string-solitaire">A. Casimir's String Solitaire</h1><p><a href="https://codeforces.com/contest/1579/problem/A">题目传送门</a></p><h2 id="problem"><span class="math inline">\(Problem\)</span></h2><p>给你一个仅含 A,B,C 的字符串，每次可以删掉一个 A 和一个 B，或一个 B 和一个 C，位置、顺序不限，问能不能删完。</p><p><span class="math inline">\(t\le 1000,len\le 50\)</span></p><h2 id="solution"><span class="math inline">\(Solution\)</span></h2><p>大水题，只需要判断 A 的数量加 C 的数量是否等于 B 的数量。<del>一开始脑抽还判断 A 的数量是否等于 C 的数量</del></p><h1 id="b.-shifting-sort">B. Shifting Sort</h1><p><a href="https://codeforces.com/contest/1579/problem/B">题目传送门</a></p><h2 id="problem-1"><span class="math inline">\(Problem\)</span></h2><p>定义对一段区间的 <code>Cyclically Shift</code>（以下简称<code>Shift</code>） 操作为：</p><ol type="1"><li>指定一个数 <span class="math inline">\(x(x\le len)\)</span> 为操作的周期。</li><li>每次将区间左移一位，移出去的那一位放到最右边，重复 <span class="math inline">\(x\)</span> 次。</li></ol><p>给你一个数列 <span class="math inline">\(a\)</span>，问如何用不超过 <span class="math inline">\(n\)</span> 次 <code>Shift</code> 操作将 <span class="math inline">\(a\)</span> 排好序（不要求使用次数最少，只要不超过 <span class="math inline">\(n\)</span> 就行）。</p><p><span class="math inline">\(1\le t \le 1000,2\le n\le 50\)</span></p><h2 id="solution-1"><span class="math inline">\(Solution\)</span></h2><p>注意只要求不超过 <span class="math inline">\(n\)</span> 次，也就意味着我们只需要每一次把一个数排好序就行了。我们可以每次挑选最大的数，通过一次 <code>Shift</code> 操作（<span class="math inline">\(x=1\)</span>）将它移到最右边的位置，如果已经在该在的位置就不操作，每次都能将一个数归位，重复 <span class="math inline">\(n\)</span> 次即可。</p><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原序列</span><br><span class="line">2 5 1 4 3</span><br><span class="line">将5归位</span><br><span class="line">2 1 4 3 5</span><br><span class="line">将4归位</span><br><span class="line">2 1 3 4 5</span><br><span class="line">将2归位</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>由于 <span class="math inline">\(n\)</span> 很小，暴力找最大值就可以。</p><h1 id="c.-ticks">C. Ticks</h1><p><a href="https://codeforces.com/contest/1579/problem/C">题目传送门</a></p><h2 id="problem-2"><span class="math inline">\(Problem\)</span></h2><p>给你一个 <span class="math inline">\(n\times m\)</span> 的网格图，每个格子有 <code>*</code> 和 <code>.</code> 两种状态，<code>*</code> 表示填，<code>.</code> 表示不填，问能不能通过若干个大小超过 <span class="math inline">\(k\)</span> 的“V字形”表示出这个图形（V 的两条边必须一样长，机房的两位大佬就是没判断这个而 FST 了）。</p><p>“V字形”大小的定义： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*...*</span><br><span class="line">.*.*.</span><br><span class="line">..*..</span><br></pre></td></tr></table></figure> 的大小为 <span class="math inline">\(2\)</span>。</p><p><span class="math inline">\(1\le k\le n\le 10,1\le m\le 19\)</span></p><h2 id="solution-2"><span class="math inline">\(Solution\)</span></h2><p>注意到 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 的范围很小，完全可以通过暴力求解。对于每一个格子，尽可能多的往上延伸，如果超过 <span class="math inline">\(k\)</span> 就把覆盖格子的标记一下，最后判断是否都被覆盖完。</p><h1 id="d.-productive-meeting">D. Productive Meeting</h1><p><a href="https://codeforces.com/contest/1579/problem/D">题目传送门</a></p><h2 id="problem-3"><span class="math inline">\(Problem\)</span></h2><p>在一场见面会中有 <span class="math inline">\(n\)</span> 个人，会议开始后他们会两两交谈，每个人有一定的耐心值 <span class="math inline">\(a_i\)</span>，第 <span class="math inline">\(i\)</span> 个人在交谈 <span class="math inline">\(a_i\)</span> 次后会离开会议，两个人可以交谈多次，请找出一种方案使得总交谈次数尽可能多。</p><p><span class="math inline">\(1\le t\le 1000,\sum n\le 2\times 10^5,\sum a_i\le 2\times 10^5\)</span></p><h2 id="solution-3"><span class="math inline">\(Solution\)</span></h2><p>由于 <span class="math inline">\(\sum a_i\)</span> 不大，我们可以依次考虑每一次交谈，容易想到每次让耐心值最大的两个人交谈是最优方案。</p><h3 id="实现-1">实现 1</h3><p>先排好序，每次让剩余耐心值最大的两个人交谈，耐心值--，在考虑维护序列单调性，可以通过一通 <code>lower_bound</code> 和 <code>upper_bound</code> 以及 <code>swap</code> 来实现，时间复杂度 <span class="math inline">\(O((\sum a_i)\log(n))\)</span>。</p><h3 id="实现-2">实现 2</h3><p>使用 <code>lower_bound</code> 和 <code>upper_bound</code> 来维护需要考虑一大堆细节（我调错调了一下午加一晚上），不如用堆来维护。每次从堆里拿出两个耐心值最大的人，耐心值--，如果还有剩余耐心值，就把他们再扔回堆里，用 STL 的优先队列实现非常简洁，时间复杂度也是 <span class="math inline">\(O((\sum a_i)\log(n))\)</span>。</p><h1 id="e1.-permutation-minimization-by-deque">E1. Permutation Minimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E1">题目传送门</a></p><p>在 Codeforces 中首次被 hack 祭。</p><h2 id="problem-4"><span class="math inline">\(Problem\)</span></h2><p>给你一个 <span class="math inline">\(1-n\)</span> 的排列，你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的数的字典序最小。</p><p><span class="math inline">\(1\le t\le 1000,\sum n\le 2\times 10^5\)</span></p><h2 id="solution-1-1"><span class="math inline">\(Solution\ 1\)</span></h2><p>由于要让字典序最小，肯定最小的值放在最前面，最小值之前的数的放法先不管，放完最小值之前的数之后在把最小值放在最前面，最小值后面的数就只能从后面挨个放了。而最小值之前的数我们可以递归处理。</p><p>具体实现中我们需要用 ST 表维护区间最小值，再用分治递归的方法实现。</p><h2 id="solution-2-1"><span class="math inline">\(Solution\ 2\)</span></h2><p>从通过人数上看，这道题的简单程度可是仅次于 A 题，怎么会这么复杂呢？</p><p>考虑用贪心的思想，先扔进去第一个数，以后对于每一个数，如果它比队首小，就扔到队首（这样可以让结果的字典序尽可能小），否则就扔到队尾（如果还扔到队首字典序就大了）。就是这么简单。</p><h1 id="e2.-array-optimization-by-deque">E2. Array Optimization by Deque</h1><p><a href="https://codeforces.com/contest/1579/problem/E2">题目传送门</a></p><h2 id="problem-5"><span class="math inline">\(Problem\)</span></h2><p>给你一个长度为 <span class="math inline">\(n\)</span> 的数列（注意不是排列），你需要把它们按顺序扔进双端队列里，你可以决定从哪一端扔。需要使得最终双端队列里的<a href="https://baike.baidu.com/item/逆序对/11035554">逆序对</a>尽可能少。</p><p><span class="math inline">\(1\le t\le 1000,\sum n\le 2\times 10^5,-10^9\le a_i\le 10^9\)</span></p><h2 id="solution-4"><span class="math inline">\(Solution\)</span></h2><p>同样是贪心，对于每个数，如果放在队首，则贡献的逆序对数为前面比它小的数的个数，反之则为比它大的数的个数，这个数放在队首还是队尾对以后的方法不会产生干扰，所以只需要判断它前面是比它大的多还是比它小的多，这可以用树状数组或权值线段树维护。由于 <span class="math inline">\(a_i\)</span> 的值跨度过大，需要先进行离散化处理。</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-latex折腾记</title>
      <link href="/2021/09/09/hexo-latex-zhe-teng-ji/"/>
      <url>/2021/09/09/hexo-latex-zhe-teng-ji/</url>
      
        <content type="html"><![CDATA[<p>hexo的LaTeX可算把我给折腾死了。。。</p><p>问题：多行公式无法显示（hexo-renderer-marked，mathjax）</p><p>看到网上说是因为渲染引擎把<code>\\</code>渲染成<code>\</code>，然后才交给mathjax渲染公式</p><p>都说把hexo-renderer-marked换成hexo-renderer-kramed，然后再node_modules/kramed/lib/rules/inline.js里修改escape项，照做了，确实解决了问题，但是却出现了新的问题：复杂公式显示错乱，遂放弃。</p><p>又看到在node_modules/marked/lib/marked.js里修改escape项，失败。</p><p>后来发现那些文章都比较老，于是把hexo-renderer-marked换成了2018年的1.0.0版本，再修改escape，终于成功。</p><p>最终解决步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-marked@1.0.0</span><br></pre></td></tr></table></figure><p>编辑node_modules/marked/lib/marked.js</p><p>第539行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/,</span><br><span class="line">改成</span><br><span class="line">escape: /^\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/,</span><br></pre></td></tr></table></figure><p>第564行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline._escapes = /\\([!&quot;#$%&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]\\^_`&#123;|&#125;~])/g;</span><br><span class="line">改成</span><br><span class="line">inline._escapes = /\\([!&quot;#$&amp;&#x27;()*+,\-./:;&lt;=&gt;?@\[\]^_`|~])/g;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2285打鼹鼠 题解</title>
      <link href="/2021/09/05/p2285-da-yan-shu-ti-jie/"/>
      <url>/2021/09/05/p2285-da-yan-shu-ti-jie/</url>
      
        <content type="html"><![CDATA[<p>基础的DP各位大佬已经讲得很明白了，本文主要讲一讲优化</p><p>DP状态很<del>容易</del>想到：<span class="math inline">\(f[i]\)</span> 表示打完第 <span class="math inline">\(i\)</span> 只鼹鼠能获得的最多数量。</p><p>转移：<span class="math inline">\(f[i]=\min\limits_{j&lt;i,\ t[i]-t[j]&gt;=dis(i,j)}f[j]+1\)</span> ，即对于每一个打完第 <span class="math inline">\(j\)</span> 个能来得及走到第 <span class="math inline">\(i\)</span> 个的 <span class="math inline">\(j\)</span>，算最大的 <span class="math inline">\(f[j]+1\)</span>。</p><h3 id="重点来了">重点来了！！</h3><p><strong>优化</strong></p><p>我们发现，如果时间差大于 <span class="math inline">\(2\times n\)</span>，无论在<del>天涯海角</del>哪里都能走到，又因为输入的时间是升序排列，我们只需要在转移时维护 <span class="math inline">\(g[i]\)</span> 表示 <span class="math inline">\(\max\limits_{j&lt;=i}f[i]\)</span>，这样在转移 <span class="math inline">\(f[i]\)</span> 时就可以先用 <span class="math inline">\(start=upper \\_ bound-1\)</span> 找出最后一个“时间差大于 <span class="math inline">\(2\times n\)</span>” 的鼹鼠，他前面的鼹鼠无论多远都能到达，就可以直接用 <span class="math inline">\(g[start]\)</span> 来代替，枚举时就只需要从 <span class="math inline">\(start\)</span> 开始枚举了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+<span class="number">1</span>,t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续优化</strong></p><p>我们发现，由于时间是递增的，所以 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(start\)</span> 一定不会小于 <span class="math inline">\(i-1\)</span> 的 <span class="math inline">\(start\)</span>，所以我们用 <span class="math inline">\(start[i]\)</span> 记录第 <span class="math inline">\(i\)</span> 只鼹鼠的 <span class="math inline">\(start\)</span>，那么 <span class="math inline">\(upper \\_ bound\)</span> 时就只需要从 <span class="math inline">\(start[i-1]\)</span> 开始查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        start[i]=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">upper_bound</span>(t+start[i<span class="number">-1</span>],t+i,t[i]<span class="number">-2</span>*n)-t<span class="number">-1</span>));</span><br><span class="line">        f[i]=g[start[i]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start[i]);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎哎哎，别急着走，后面还有：</p><p><strong>继续继续优化</strong></p><p>我们甚至可以直接不用 <span class="math inline">\(upper \\_ bound\)</span> 和 <span class="math inline">\(start\)</span> 数组了（没错），开一个变量 <span class="math inline">\(start\)</span>，维护当前的 <span class="math inline">\(start\)</span>，转移之前用一个</p><p><code>for(;t[i]-t[start+1]&gt;=2*n;start++);</code></p><p>来更新 <span class="math inline">\(start\)</span>，可以发现，整个程序运行下来，<span class="math inline">\(start\)</span> 最多只会更新 <span class="math inline">\(n\)</span>次，所以复杂度可忽略。</p><p>最终代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10010</span>],g[<span class="number">10010</span>],start;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t[i],&amp;x[i],&amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;t[i]-t[start+<span class="number">1</span>]&gt;=<span class="number">2</span>*n;start++);</span><br><span class="line">        f[i]=g[start]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">1</span>,start);j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]-t[j]&gt;=<span class="built_in">dis</span>(i,j))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g[i]=<span class="built_in">max</span>(g[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不开O2可达48ms，可见优化非常显著。</p><p><strong>请勿抄袭，如果一定要抄，请理解明白后再抄</strong></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4363一双木棋 题解</title>
      <link href="/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/"/>
      <url>/2021/08/14/p4363-yi-shuang-mu-qi-ti-jie/</url>
      
        <content type="html"><![CDATA[<p><del>本篇题解献给和我一样看不懂其他题解的状压DP小白</del></p><p>相信大家都是看了其他题解看不懂才看到这篇题解的（莫名自信），所以什么<strong>每行棋子数递减</strong>啊，<strong>每行的棋子都排在左边</strong>啊，就不用我多说了，直接切入正题（大段文字多，请耐心观看）。</p><h2 id="轮廓线dp">轮廓线DP</h2><p>没见过不用慌，我也没见过（雾</p><p>轮廓线，就是把矩阵从右上角到左下角沿着有棋子和没棋子的分界线描一下，往下走就用1表示，往左走就用0表示。这样我们就得到了一个01串，即一个二进制数，这就是我们的DP状态。</p><p>例如（图丑勿喷）</p><p><img data-src="https://i.loli.net/2021/08/14/6RlDkBPy2JnVS7W.png" /></p><p>这种情况下轮廓线状态为左左下左下下左左下，即<span class="math inline">\(001011001_{(2)}=89\)</span></p><p>我们设<span class="math inline">\(f[s]\)</span>（<span class="math inline">\(s\)</span>就是轮廓线状态）表示从轮廓线表示的局面一直下到最终下满的过程中“先手-后手”最大是多少。我们可以发现，只根据s就可以知道已经下了那些棋，但不能知道具体是黑棋还是白棋，然而根据<span class="math inline">\(f\)</span>的定义，<span class="math inline">\(f[s]\)</span>的值和前面怎么下的没有关系，它只管之后怎么下，所以我们只用一维轮廓线就OK，不需要记录之前怎么下的。</p><p>那么状态有了，怎么转移呢？以上图为例，即将要白棋（后手）下棋，后手肯定希望他下的一步棋能使得从现在开始（以前的我们不管）先手-后手得分尽可能小（如果是负数那他更开心了），所以<span class="math inline">\(f[s]=\min\limits_{所有再下一步棋可能得到的方案s&#39;}f[s&#39;]-b[x][y]\)</span>（<span class="math inline">\(x,y\)</span>就是即将下的那一步棋的坐标）。</p><p>同理，如果即将先手下，就把上面的式子里min改成max（因为他希望下这步棋能使得他的得分-对方的得分最大），<span class="math inline">\(-b[x][y]\)</span>改成<span class="math inline">\(+a[x][y]\)</span>。</p><p>这样我们就可以用记忆化搜索很容易地跑出来了。</p><p>哎等等，我们还有两个问题没解决，观察上面的式子，我们还不知道怎么枚举“所有再下一步棋可能得到的方案<span class="math inline">\(s&#39;\)</span>”，也不知道怎么根据轮廓线的变化找出具体坐标x和y啊？</p><p>我们一个一个解决，先看第一个问题。还是以上图为例，白棋（后手）可以下在<span class="math inline">\((1,4),(2,3),(4,1)\)</span>三个位置，但转移的时候电脑只知道当前的轮廓线，所以我们需要找这三个点的共同特点，那就是处在轮廓线左和下的拐角处，也就是轮廓线中先出现一个0，再出现一个1。现在我们知道了轮廓线上放棋子的位置，怎么得出放棋子后的轮廓线状态呢？我们还是以上图为例，如果我们放在<span class="math inline">\((2,3)\)</span>处，进行一个对比。</p><p>原：<span class="math inline">\(001011001_{(2)}\)</span></p><p>新：<span class="math inline">\(001101001_{(2)}\)</span></p><p><img data-src="https://i.loli.net/2021/08/15/YyPqDZpzrfl43kO.png" /></p><p>我们发现只有第四位和第五位变了，而原先的第四位和第五位就是我们之前说的先出现一个0，再出现一个1，那么转移就是把0变成1，把1变成0。</p><p>具体来说，就是当我们枚举到一个<span class="math inline">\(i\)</span>，使得原状态的（从低位数）第<span class="math inline">\(i\)</span>位是1，第<span class="math inline">\(i+1\)</span>位是0，那么就把状态异或上<span class="math inline">\(3&lt;&lt;i\)</span>（可以对照例子手推一下）。</p><p>开始讨论第二个问题，我们知道该在轮廓线的哪一位上下棋，怎么知道那步棋的具体坐标呢？这个问题比较容易解决，只需要在枚举<span class="math inline">\(i\)</span>时维护当前看到哪个坐标即可（详见代码）。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>],b[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1048580</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1048580</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">bool</span> now)</span><span class="comment">//s是轮廓线状态，now记录是先手还是后手（虽然可以根据s算出来，但这样比较方便）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[s])<span class="comment">//记忆化搜索标配</span></span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;(n+m))-(<span class="number">1</span>&lt;&lt;m))<span class="comment">//已经填满棋子（即n个下加m个左）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num0=<span class="number">0</span>,num1=<span class="number">0</span>;<span class="comment">//维护坐标（已经出现多少个左/多少个下</span></span><br><span class="line">    <span class="keyword">if</span>(now)<span class="comment">//先手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">-2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;<span class="number">0</span>&amp;&amp;(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>)))==<span class="number">0</span>)</span><br><span class="line">                f[s]=<span class="built_in">max</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">0</span>)+a[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//后手</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[s]=<span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+m<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num1+=((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i);</span><br><span class="line">            num0+=(!((s&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i));</span><br><span class="line">            <span class="keyword">if</span>((s&amp;(<span class="number">1</span>&lt;&lt;i))&amp;&amp;!(s&amp;(<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>))))</span><br><span class="line">                f[s]=<span class="built_in">min</span>(f[s],<span class="built_in">dfs</span>(s^(<span class="number">3</span>&lt;&lt;i),<span class="number">1</span>)-b[n-num1+<span class="number">1</span>][num0+<span class="number">1</span>]);<span class="comment">//递归计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cin&gt;&gt;b[i][j];</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//(1&lt;&lt;n)-1是初始状态，即m个左加n个下（一步棋也没下）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能的高精度模板</title>
      <link href="/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/"/>
      <url>/2021/08/14/wan-neng-de-gao-jing-du-mo-ban/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL=<span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len,z[MAXL];</span><br><span class="line">    <span class="built_in">Int</span>()&#123; <span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(z)); len=<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clean_pre_zero</span><span class="params">()</span></span>&#123; <span class="keyword">while</span>(len&gt;<span class="number">1</span> &amp;&amp; !z[len<span class="number">-1</span>]) len--; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="keyword">char</span> s[MAXL]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); *<span class="keyword">this</span>=s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,z[i]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">    &#123;</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            z[i]=num[len-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[MAXL];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">int</span> num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">const</span> <span class="keyword">char</span> *num)&#123; *<span class="keyword">this</span>=num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=<span class="built_in">max</span>(len,b.len)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]+b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int &amp;b)<span class="comment">// 必须保证结果为正数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++) res.z[i]=z[i]-b.z[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            <span class="keyword">if</span>(res.z[i]&lt;<span class="number">0</span>)</span><br><span class="line">                res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span><span class="number">-1</span>,</span><br><span class="line">                res.z[i]%=<span class="number">10</span>,res.z[i]+=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res;</span><br><span class="line">        res.len=len+b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">                res.z[i+j]+=z[i]*b.z[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</span><br><span class="line">            res.z[i+<span class="number">1</span>]+=res.z[i]/<span class="number">10</span>,</span><br><span class="line">            res.z[i]%=<span class="number">10</span>;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Int <span class="keyword">operator</span> / (<span class="keyword">const</span> Int &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        Int res,cur;</span><br><span class="line">        res.len=len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur*<span class="number">10</span>+z[i];</span><br><span class="line">            <span class="keyword">while</span>(cur&gt;=b)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur-b;</span><br><span class="line">                res.z[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clean_pre_zero</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=b.len) <span class="keyword">return</span> len&lt;b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(z[i]!=b.z[i])</span><br><span class="line">                <span class="keyword">return</span> z[i]&lt;b.z[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> b&lt;*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span>&gt;b) &amp;&amp; !(*<span class="keyword">this</span>&lt;b); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&gt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span>&lt;b || *<span class="keyword">this</span>==b; &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(b==*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得学习笔记</title>
      <link href="/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/"/>
      <url>/2021/08/14/kuo-zhan-ou-ji-li-de-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>温馨提示：本文推式子比较多，建议跟着文章自己推一推。</p><h2 id="扩展欧几里得是什么">扩展欧几里得是什么</h2><p>扩展欧几里得（exgcd）是一个可以用来求 <span class="math inline">\(ax+by=c\)</span>（<span class="math inline">\(c\%\gcd(a,b)=0\)</span>，否则无解）的解的算法</p><h2 id="求解-axbygcdab">求解 <span class="math inline">\(ax+by=\gcd(a,b)\)</span></h2><p>首先，如果 <span class="math inline">\(b=0\)</span> 的话，<span class="math inline">\(\gcd(a,b)=a\)</span>，则解为 <span class="math inline">\(\begin{cases}x=1 \\ y=0\end{cases}\)</span></p><p>设此方程的解为 <span class="math inline">\(\begin{cases}x=x_0 \\ y=y_0\end{cases}\)</span></p><p>那么我们需要做的就是将 <span class="math inline">\(ax_0+by_0=\gcd(a,b)\)</span> 转化为 <span class="math inline">\(b=0\)</span> 的格式，这就要用到辗转相除法了。</p><p>设另一个方程：<span class="math inline">\(bx_1+(a\%b)y_1=\gcd(b,a\%b)\)</span></p><p>令 <span class="math inline">\(a_1=b,b_1=a\%b\)</span></p><p>则该方程转化为 <span class="math inline">\(a_1x_1+b_1y_1=\gcd(a_1,b_1)\)</span></p><p>我们会发现它和原方程的格式是一样的，而且根据欧几里得原理，它可以一直递推到 <span class="math inline">\(a_nx_n+b_ny_n=\gcd(a_n,b_n)\)</span> 使得 <span class="math inline">\(b_n=0\)</span>，就可以求得解 <span class="math inline">\(\begin{cases}x_n=1 \\ y_n=0\end{cases}\)</span></p><p>那假设我们已经求得了该结果，那如何推导出 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(y_0\)</span> 呢？</p><p>我们首先研究如何从 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(y_1\)</span> 推导出一组合法的 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(y_0\)</span>，其他的就同理了</p><p>因为</p><p><span class="math display">\[\begin{cases}bx_1+(a\%b)y_1=\gcd(b,a\%b) \\ ax_0+by_0=\gcd(a,b)\end{cases}\]</span></p><p>且根据欧几里得定理，<span class="math inline">\(\gcd(a,b)=\gcd(b,a\%b)\)</span></p><p>所以</p><p><span class="math display">\[ax_0+by_0=bx_1+(a\%b)y_1\]</span></p><p>且 <span class="math inline">\(a\%b=a-\lfloor\frac{a}{b}\rfloor b\)</span>（模运算的意义）</p><p>所以</p><p><span class="math display">\[\begin{matrix} \begin{aligned} ax_0+by_0&amp;=bx_1+(a-\lfloor\frac{a}{b}\rfloor b)y_1 \\ &amp;=bx_1+ay_1-\lfloor\frac{a}{b}\rfloor b y_1 \\ &amp;=b(x1-\lfloor\frac{a}{b}\rfloor y_1)+ay_1 \\ &amp;=ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1) \end{aligned} \\ \begin{cases}x_0=y_1 \\ y_0=x_1-\lfloor\frac{a}{b}\rfloor y_1 \end{cases} \end{matrix}\]</span></p><p>这样，我们就由 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(y_1\)</span> 推导出了 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(y_0\)</span>，其他同理</p><p>于是乎：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp;</span><br><span class="line">        tmp.x=<span class="number">1</span>,tmp.y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    node tmp=<span class="built_in">exgcd</span>(b,a%b);<span class="comment">//递归求出x_(k+1)和y_(k+1)</span></span><br><span class="line">    node ans;</span><br><span class="line">    ans.x=tmp.y,ans.y=(tmp.x)-a/b*(tmp.y);<span class="comment">//推导出x_k和y_k</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就求出了 <span class="math inline">\(ax+by=\gcd(a,b)\)</span> 的一组解</p><h2 id="axbyc-的一组解-begincases-xx_tmpyy_tmp-endcases"><span class="math inline">\(ax+by=c\)</span> 的一组解 <span class="math inline">\(\begin{cases} x=x_{tmp}\\y=y_{tmp} \end{cases}\)</span></h2><p>我们已经求出了 <span class="math inline">\(ax+by=\gcd(a,b)\)</span> 的一组解 <span class="math inline">\(\begin{cases} x=x_0 \\ y=y_0 \end{cases}\)</span></p><p>那么我们就可以知道 <span class="math inline">\(akx_0+bky_0=k\gcd(a,b)\)</span></p><p>又因为要求 <span class="math inline">\(c\)</span> 是 <span class="math inline">\(\gcd(a,b)\)</span> 的倍数（否则无解）</p><p>所以 <span class="math inline">\(k=\frac{c}{\gcd(a,b)}\)</span></p><p>所以很简单：</p><p><span class="math display">\[\begin{cases} x_{tmp}=kx_0=\frac{c}{\gcd(a,b)}x_0 \\ y_{tmp}=ky_0=\frac{c}{\gcd(a,b)}y_0 \end{cases}\]</span></p><h2 id="axbyc-的所有解-begincases-xx_ansyy_ans-endcases">3.<span class="math inline">\(ax+by=c\)</span> 的所有解 <span class="math inline">\(\begin{cases} x=x_{ans}\\y=y_{ans} \end{cases}\)</span></h2><p>我们已经求出了 <span class="math inline">\(ax+by=c\)</span> 的一组解 <span class="math inline">\(\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}\)</span></p><p>即 <span class="math inline">\(ax_{tmp}+by_{tmp}=c\)</span></p><p>将它加上再减去 <span class="math inline">\(\frac{ab}{\gcd(a,b)}\)</span>，得到</p><p><span class="math display">\[\begin{matrix} ax_{tmp}+\frac{ab}{\gcd(a,b)}+by_{tmp}-\frac{ab}{\gcd(a,b)}=c \\ a(x_{tmp}+\frac{b}{\gcd(a,b)})+b(y_{tmp}-\frac{a}{\gcd(a,b)})=c \end{matrix}\]</span></p><p>在 <span class="math inline">\(x_{tmp}\)</span> 上减，在 <span class="math inline">\(y_{tmp}\)</span> 上加也同理</p><p>所以 <span class="math inline">\(\begin{cases} x=x_{tmp}\pm\frac{b}{\gcd(a,b)} \\ y=y_{tmp}\mp\frac{a}{\gcd(a,b)} \end{cases}\)</span> 也是一组解</p><p>这个变换进行多次，即可得到</p><p><span class="math display">\[\begin{cases} x_{ans}=x_{tmp}+t\times\frac{b}{\gcd(a,b)} \\ y_{ans}=y_{tmp}-t\times\frac{a}{\gcd(a,b)} \end{cases}\]</span></p><h2 id="x-和-y-各自的最小正整数解"><span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 各自的最小正整数解</h2><p>以 <span class="math inline">\(x\)</span> 的最小正整数解为例：</p><p>求出任意一组解 <span class="math inline">\(\begin{cases}x=x_{tmp} \\ y=y_{tmp}\end{cases}\)</span></p><p>因为将 <span class="math inline">\(x_{tmp}\)</span> 加或减 <span class="math inline">\(\frac{b}{\gcd(a,b)}\)</span> 也成立，所以可设 <span class="math inline">\(d=\frac{b}{\gcd(a,b)}\)</span>（注意这里分子是 <span class="math inline">\(b\)</span> ）</p><p><span class="math inline">\(x_{min}=(x_{tmp}\%d+d)\%d\)</span>（因为 <span class="math inline">\(x_{tmp}\)</span> 有可能是负数）</p><p>同理对于 <span class="math inline">\(y\)</span>，设 <span class="math inline">\(d=\frac{a}{\gcd(a,b)}\)</span>（注意这里分子是 <span class="math inline">\(a\)</span>）</p><p><span class="math inline">\(y_{min}=(y_{tmp}\%d+d)\%d\)</span></p><h2 id="完结撒花">完结撒花</h2><p>至此，你已经学完了扩展欧几里得的基础用法，如有不懂的地方，建议对照着文章自己推一推，悟一悟。</p><p>做个题练习一下吧：<a href="https://www.luogu.com.cn/problem/P5656">洛谷 P5656 【模板】二元一次不定方程 (exgcd)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
